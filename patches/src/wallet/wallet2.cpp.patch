diff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp
index c3ba34260..f9f75cea5 100644
--- a/src/wallet/wallet2.cpp
+++ b/src/wallet/wallet2.cpp
@@ -29,6 +29,7 @@
 // Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers
 
 #include <numeric>
+#include <random>
 #include <tuple>
 #include <boost/format.hpp>
 #include <boost/optional/optional.hpp>
@@ -39,6 +40,7 @@
 #include <boost/asio/ip/address.hpp>
 #include <boost/range/adaptor/transformed.hpp>
 #include <boost/preprocessor/stringize.hpp>
+#include <boost/multiprecision/cpp_int.hpp>
 #include <openssl/evp.h>
 #include "include_base_utils.h"
 using namespace epee;
@@ -102,9 +104,9 @@ using namespace cryptonote;
 // used to target a given block weight (additional outputs may be added on top to build fee)
 #define TX_WEIGHT_TARGET(bytes) (bytes * 2 / 3)
 
-#define UNSIGNED_TX_PREFIX "Monero unsigned tx set\004"
-#define SIGNED_TX_PREFIX "Monero signed tx set\004"
-#define MULTISIG_UNSIGNED_TX_PREFIX "Monero multisig unsigned tx set\001"
+#define UNSIGNED_TX_PREFIX "Haven unsigned tx set\004"
+#define SIGNED_TX_PREFIX "Haven signed tx set\004"
+#define MULTISIG_UNSIGNED_TX_PREFIX "Haven multisig unsigned tx set\001"
 
 #define RECENT_OUTPUT_RATIO (0.5) // 50% of outputs are from the recent zone
 #define RECENT_OUTPUT_DAYS (1.8)  // last 1.8 day makes up the recent zone (taken from monerolink.pdf, Miller et al)
@@ -118,9 +120,9 @@ using namespace cryptonote;
 #define SUBADDRESS_LOOKAHEAD_MAJOR 50
 #define SUBADDRESS_LOOKAHEAD_MINOR 200
 
-#define KEY_IMAGE_EXPORT_FILE_MAGIC "Monero key image export\003"
+#define KEY_IMAGE_EXPORT_FILE_MAGIC "Haven key image export\003"
 
-#define MULTISIG_EXPORT_FILE_MAGIC "Monero multisig export\001"
+#define MULTISIG_EXPORT_FILE_MAGIC "Haven multisig export\001"
 
 #define OUTPUT_EXPORT_FILE_MAGIC "Monero output export\004"
 
@@ -242,12 +244,29 @@ namespace
       add_reason(reason, "tx was not relayed");
     return reason;
   }
+
+  size_t get_num_outputs(const std::vector<cryptonote::tx_destination_entry> &dsts, const std::vector<tools::wallet2::transfer_details> &transfers, const std::vector<size_t> &selected_transfers)
+  {
+    size_t outputs = dsts.size();
+    uint64_t needed_money = 0;
+    for (const auto &dt : dsts)
+      needed_money += dt.amount;
+    uint64_t found_money = 0;
+    for (size_t idx : selected_transfers)
+      found_money += transfers[idx].amount();
+    if (found_money != needed_money)
+      ++outputs; // change
+    if (outputs < 2)
+      ++outputs; // extra 0 dummy output
+    return outputs;
   }
+} // namespace
 
 namespace
 {
   // Create on-demand to prevent static initialization order fiasco issues.
-struct options {
+  struct options
+  {
     const command_line::arg_descriptor<std::string> daemon_address = {"daemon-address", tools::wallet2::tr("Use daemon instance at <host>:<port>"), ""};
     const command_line::arg_descriptor<std::string> daemon_host = {"daemon-host", tools::wallet2::tr("Use daemon instance at host <arg> instead of localhost"), ""};
     const command_line::arg_descriptor<std::string> proxy = {"proxy", tools::wallet2::tr("[<ip>:]<port> socks proxy to use for daemon connections"), {}, true};
@@ -267,17 +286,13 @@ struct options {
     const command_line::arg_descriptor<bool> testnet = {"testnet", tools::wallet2::tr("For testnet. Daemon must also be launched with --testnet flag"), false};
     const command_line::arg_descriptor<bool> stagenet = {"stagenet", tools::wallet2::tr("For stagenet. Daemon must also be launched with --stagenet flag"), false};
     const command_line::arg_descriptor<std::string, false, true, 2> shared_ringdb_dir = {
-    "shared-ringdb-dir", tools::wallet2::tr("Set shared ring database path"),
-    get_default_ringdb_path(),
-    {{ &testnet, &stagenet }},
-    [](std::array<bool, 2> testnet_stagenet, bool defaulted, std::string val)->std::string {
+        "shared-ringdb-dir", tools::wallet2::tr("Set shared ring database path"), get_default_ringdb_path(), {{&testnet, &stagenet}}, [](std::array<bool, 2> testnet_stagenet, bool defaulted, std::string val) -> std::string {
           if (testnet_stagenet[0])
             return (boost::filesystem::path(val) / "testnet").string();
           else if (testnet_stagenet[1])
             return (boost::filesystem::path(val) / "stagenet").string();
           return val;
-    }
-  };
+        }};
     const command_line::arg_descriptor<uint64_t> kdf_rounds = {"kdf-rounds", tools::wallet2::tr("Number of rounds for the key derivation function"), 1};
     const command_line::arg_descriptor<std::string> hw_device = {"hw-device", tools::wallet2::tr("HW device to use"), ""};
     const command_line::arg_descriptor<std::string> hw_device_derivation_path = {"hw-device-deriv-path", tools::wallet2::tr("HW device wallet derivation path (e.g., SLIP-10)"), ""};
@@ -295,7 +310,8 @@ void do_prepare_file_names(const std::string& file_path, std::string& keys_file,
     if (string_tools::get_extension(keys_file) == "keys")
     { //provided keys file name
       wallet_file = string_tools::cut_off_extension(wallet_file);
-  }else
+    }
+    else
     { //provided wallet file name
       keys_file += ".keys";
     }
@@ -363,8 +379,7 @@ std::unique_ptr<tools::wallet2> make_basic(const boost::program_options::variabl
       }
 
       ssl_options = epee::net_utils::ssl_options_t{
-      std::move(ssl_allowed_fingerprints), std::move(daemon_ssl_ca_file)
-    };
+          std::move(ssl_allowed_fingerprints), std::move(daemon_ssl_ca_file)};
 
       if (command_line::get_arg(vm, opts.daemon_ssl_allow_chained))
         ssl_options.verification = epee::net_utils::ssl_verification_t::user_ca;
@@ -377,8 +392,7 @@ std::unique_ptr<tools::wallet2> make_basic(const boost::program_options::variabl
     }
 
     ssl_options.auth = epee::net_utils::ssl_authentication_t{
-    std::move(daemon_ssl_private_key), std::move(daemon_ssl_certificate)
-  };
+        std::move(daemon_ssl_private_key), std::move(daemon_ssl_certificate)};
 
     THROW_WALLET_EXCEPTION_IF(!daemon_address.empty() && !daemon_host.empty() && 0 != daemon_port,
                               tools::error::wallet_internal_error, tools::wallet2::tr("can't specify daemon host or port more than once"));
@@ -394,8 +408,7 @@ std::unique_ptr<tools::wallet2> make_basic(const boost::program_options::variabl
               return boost::optional<tools::password_container>();
             }
             return password_prompter("Daemon client password", verify);
-      }
-    );
+          });
       if (!parsed)
         return nullptr;
 
@@ -436,8 +449,7 @@ std::unique_ptr<tools::wallet2> make_basic(const boost::program_options::variabl
           tools::error::wallet_internal_error,
           tools::wallet2::tr("Enabling --") + std::string{use_proxy ? opts.proxy.name : opts.daemon_ssl.name} + tools::wallet2::tr(" requires --") +
               opts.daemon_ssl_allow_any_cert.name + tools::wallet2::tr(" or --") +
-        opts.daemon_ssl_ca_certificates.name + tools::wallet2::tr(" or --") + opts.daemon_ssl_allowed_fingerprints.name + tools::wallet2::tr(" or use of a .onion/.i2p domain")
-    );
+              opts.daemon_ssl_ca_certificates.name + tools::wallet2::tr(" or --") + opts.daemon_ssl_allowed_fingerprints.name + tools::wallet2::tr(" or use of a .onion/.i2p domain"));
     }
 
     boost::asio::ip::tcp::endpoint proxy{};
@@ -458,8 +470,7 @@ std::unique_ptr<tools::wallet2> make_basic(const boost::program_options::variabl
       THROW_WALLET_EXCEPTION_IF(
           !epee::string_tools::get_xtype_from_string(port_value, std::string{proxy_port}),
           tools::error::wallet_internal_error,
-      std::string{"Invalid port specified for --"} + opts.proxy.name
-    );
+          std::string{"Invalid port specified for --"} + opts.proxy.name);
 
       boost::system::error_code error{};
       proxy = ip::tcp::endpoint{ip::address::from_string(std::string{proxy_host}, error), port_value};
@@ -484,7 +495,9 @@ std::unique_ptr<tools::wallet2> make_basic(const boost::program_options::variabl
           trusted_daemon = true;
         }
       }
-    catch (const std::exception &e) { }
+      catch (const std::exception &e)
+      {
+      }
     }
 
     std::unique_ptr<tools::wallet2> wallet(new tools::wallet2(nettype, kdf_rounds, unattended));
@@ -565,13 +578,15 @@ std::pair<std::unique_ptr<tools::wallet2>, tools::password_container> generate_f
     epee::wipeable_string password;
     const auto do_generate = [&]() -> bool {
       std::string buf;
-    if (!epee::file_io_utils::load_file_to_string(json_file, buf)) {
+      if (!epee::file_io_utils::load_file_to_string(json_file, buf))
+      {
         THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, std::string(tools::wallet2::tr("Failed to load file ")) + json_file);
         return false;
       }
 
       rapidjson::Document json;
-    if (json.Parse(buf.c_str()).HasParseError()) {
+      if (json.Parse(buf.c_str()).HasParseError())
+      {
         THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("Failed to parse JSON"));
         return false;
       }
@@ -601,7 +616,8 @@ std::pair<std::unique_ptr<tools::wallet2>, tools::password_container> generate_f
         crypto::public_key pkey;
         if (viewkey == crypto::null_skey)
           THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("view secret key may not be all zeroes"));
-      if (!crypto::secret_key_to_public_key(viewkey, pkey)) {
+        if (!crypto::secret_key_to_public_key(viewkey, pkey))
+        {
           THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("failed to verify view key secret key"));
         }
       }
@@ -619,7 +635,8 @@ std::pair<std::unique_ptr<tools::wallet2>, tools::password_container> generate_f
         crypto::public_key pkey;
         if (spendkey == crypto::null_skey)
           THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("spend secret key may not be all zeroes"));
-      if (!crypto::secret_key_to_public_key(spendkey, pkey)) {
+        if (!crypto::secret_key_to_public_key(spendkey, pkey))
+        {
           THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("failed to verify spend key secret key"));
         }
       }
@@ -671,20 +688,24 @@ std::pair<std::unique_ptr<tools::wallet2>, tools::password_container> generate_f
         if (field_viewkey_found)
         {
           crypto::public_key pkey;
-        if (!crypto::secret_key_to_public_key(viewkey, pkey)) {
+          if (!crypto::secret_key_to_public_key(viewkey, pkey))
+          {
             THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("failed to verify view key secret key"));
           }
-        if (info.address.m_view_public_key != pkey) {
+          if (info.address.m_view_public_key != pkey)
+          {
             THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("view key does not match standard address"));
           }
         }
         if (field_spendkey_found)
         {
           crypto::public_key pkey;
-        if (!crypto::secret_key_to_public_key(spendkey, pkey)) {
+          if (!crypto::secret_key_to_public_key(spendkey, pkey))
+          {
             THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("failed to verify spend key secret key"));
           }
-        if (info.address.m_spend_public_key != pkey) {
+          if (info.address.m_spend_public_key != pkey)
+          {
             THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("spend key does not match standard address"));
           }
         }
@@ -716,7 +737,8 @@ std::pair<std::unique_ptr<tools::wallet2>, tools::password_container> generate_f
         else
         {
           cryptonote::account_public_address address;
-        if (!crypto::secret_key_to_public_key(viewkey, address.m_view_public_key)) {
+          if (!crypto::secret_key_to_public_key(viewkey, address.m_view_public_key))
+          {
             THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("failed to verify view key secret key"));
           }
 
@@ -742,7 +764,8 @@ std::pair<std::unique_ptr<tools::wallet2>, tools::password_container> generate_f
           }
           else
           {
-          if (!crypto::secret_key_to_public_key(spendkey, address.m_spend_public_key)) {
+            if (!crypto::secret_key_to_public_key(spendkey, address.m_spend_public_key))
+            {
               THROW_WALLET_EXCEPTION(tools::error::wallet_internal_error, tools::wallet2::tr("failed to verify spend key secret key"));
             }
             wallet->generate(field_filename, field_password, address, spendkey, viewkey, create_address_file);
@@ -798,7 +821,8 @@ void drop_from_short_history(std::list<crypto::hash> &short_chain_history, size_
   {
     std::list<crypto::hash>::iterator right;
     // drop early N off, skipping the genesis block
-  if (short_chain_history.size() > N) {
+    if (short_chain_history.size() > N)
+    {
       right = short_chain_history.end();
       std::advance(right, -1);
       std::list<crypto::hash>::iterator left = right;
@@ -807,7 +831,7 @@ void drop_from_short_history(std::list<crypto::hash> &short_chain_history, size_
     }
   }
 
-size_t estimate_rct_tx_size(int n_inputs, int mixin, int n_outputs, size_t extra_size, bool bulletproof)
+  size_t estimate_rct_tx_size(int n_inputs, int mixin, int n_outputs, size_t extra_size, bool bulletproof, bool clsag)
   {
     size_t size = 0;
 
@@ -841,7 +865,10 @@ size_t estimate_rct_tx_size(int n_inputs, int mixin, int n_outputs, size_t extra
     else
       size += (2 * 64 * 32 + 32 + 64 * 32) * n_outputs;
 
-  // MGs
+    // MGs/CLSAGs
+    if (clsag)
+      size += n_inputs * (32 * (mixin + 1) + 64);
+    else
       size += n_inputs * (64 * (mixin + 1) + 32);
 
     // mixRing - not serialized, can be reconstructed
@@ -860,17 +887,17 @@ size_t estimate_rct_tx_size(int n_inputs, int mixin, int n_outputs, size_t extra
     return size;
   }
 
-size_t estimate_tx_size(bool use_rct, int n_inputs, int mixin, int n_outputs, size_t extra_size, bool bulletproof)
+  size_t estimate_tx_size(bool use_rct, int n_inputs, int mixin, int n_outputs, size_t extra_size, bool bulletproof, bool clsag)
   {
     if (use_rct)
-    return estimate_rct_tx_size(n_inputs, mixin, n_outputs, extra_size, bulletproof);
+      return estimate_rct_tx_size(n_inputs, mixin, n_outputs, extra_size, bulletproof, clsag);
     else
       return n_inputs * (mixin + 1) * APPROXIMATE_INPUT_BYTES + extra_size;
   }
 
-uint64_t estimate_tx_weight(bool use_rct, int n_inputs, int mixin, int n_outputs, size_t extra_size, bool bulletproof)
+  uint64_t estimate_tx_weight(bool use_rct, int n_inputs, int mixin, int n_outputs, size_t extra_size, bool bulletproof, bool clsag)
   {
-  size_t size = estimate_tx_size(use_rct, n_inputs, mixin, n_outputs, extra_size, bulletproof);
+    size_t size = estimate_tx_size(use_rct, n_inputs, mixin, n_outputs, extra_size, bulletproof, clsag);
     if (use_rct && bulletproof && n_outputs > 2)
     {
       const uint64_t bp_base = 368;
@@ -888,7 +915,7 @@ uint64_t estimate_tx_weight(bool use_rct, int n_inputs, int mixin, int n_outputs
 
   uint8_t get_bulletproof_fork()
   {
-  return 8;
+    return 5;
   }
 
   uint64_t calculate_fee(bool use_per_byte_fee, const cryptonote::transaction &tx, size_t blob_size, uint64_t base_fee, uint64_t fee_multiplier, uint64_t fee_quantization_mask)
@@ -998,8 +1025,7 @@ const size_t MAX_SPLIT_ATTEMPTS = 30;
   constexpr const std::chrono::seconds wallet2::rpc_timeout;
   const char *wallet2::tr(const char *str) { return i18n_translate(str, "tools::wallet2"); }
 
-gamma_picker::gamma_picker(const std::vector<uint64_t> &rct_offsets, double shape, double scale):
-    rct_offsets(rct_offsets)
+  gamma_picker::gamma_picker(const std::vector<uint64_t> &rct_offsets, double shape, double scale) : rct_offsets(rct_offsets)
   {
     gamma = std::gamma_distribution<double>(shape, scale);
     THROW_WALLET_EXCEPTION_IF(rct_offsets.size() <= CRYPTONOTE_DEFAULT_TX_SPENDABLE_AGE, error::wallet_internal_error, "Bad offset calculation");
@@ -1010,7 +1036,8 @@ gamma_picker::gamma_picker(const std::vector<uint64_t> &rct_offsets, double shap
     end = rct_offsets.data() + rct_offsets.size() - CRYPTONOTE_DEFAULT_TX_SPENDABLE_AGE;
     num_rct_outputs = *(end - 1);
     THROW_WALLET_EXCEPTION_IF(num_rct_outputs == 0, error::wallet_internal_error, "No rct outputs");
-  average_output_time = DIFFICULTY_TARGET_V2 * blocks_to_consider / outputs_to_consider; // this assumes constant target over the whole rct range
+    average_output_time = ((double)DIFFICULTY_TARGET_V2 * blocks_to_consider) / outputs_to_consider; // this assumes constant target over the whole rct range
+    THROW_WALLET_EXCEPTION_IF(average_output_time == 0.0, error::wallet_internal_error, "average_output_time is 0 - FIXME");
   };
 
   gamma_picker::gamma_picker(const std::vector<uint64_t> &rct_offsets) : gamma_picker(rct_offsets, GAMMA_SHAPE, GAMMA_SCALE) {}
@@ -1038,8 +1065,7 @@ uint64_t gamma_picker::pick()
 
   boost::mutex wallet_keys_unlocker::lockers_lock;
   unsigned int wallet_keys_unlocker::lockers = 0;
-wallet_keys_unlocker::wallet_keys_unlocker(wallet2 &w, const boost::optional<tools::password_container> &password):
-  w(w),
+  wallet_keys_unlocker::wallet_keys_unlocker(wallet2 &w, const boost::optional<tools::password_container> &password) : w(w),
                                                                                                                        locked(password != boost::none)
   {
     boost::lock_guard<boost::mutex> lock(lockers_lock);
@@ -1055,8 +1081,7 @@ wallet_keys_unlocker::wallet_keys_unlocker(wallet2 &w, const boost::optional<too
     w.decrypt_keys(key);
   }
 
-wallet_keys_unlocker::wallet_keys_unlocker(wallet2 &w, bool locked, const epee::wipeable_string &password):
-  w(w),
+  wallet_keys_unlocker::wallet_keys_unlocker(wallet2 &w, bool locked, const epee::wipeable_string &password) : w(w),
                                                                                                                locked(locked)
   {
     boost::lock_guard<boost::mutex> lock(lockers_lock);
@@ -1124,10 +1149,11 @@ void wallet_device_callback::on_progress(const hw::device_progress& event)
       wallet->on_device_progress(event);
   }
 
-wallet2::wallet2(network_type nettype, uint64_t kdf_rounds, bool unattended, std::unique_ptr<epee::net_utils::http::http_client_factory> http_client_factory):
-  m_http_client(std::move(http_client_factory->create())),
+  wallet2::wallet2(network_type nettype, uint64_t kdf_rounds, bool unattended, std::unique_ptr<epee::net_utils::http::http_client_factory> http_client_factory) : m_http_client(std::move(http_client_factory->create())),
                                                                                                                                                                   m_multisig_rescan_info(NULL),
                                                                                                                                                                   m_multisig_rescan_k(NULL),
+                                                                                                                                                                  m_multisig_rescan_offshore_info(NULL),
+                                                                                                                                                                  m_multisig_rescan_offshore_k(NULL),
                                                                                                                                                                   m_upper_transaction_weight_limit(0),
                                                                                                                                                                   m_run(true),
                                                                                                                                                                   m_callback(0),
@@ -1416,7 +1442,8 @@ bool wallet2::get_multisig_seed(epee::wipeable_string& seed, const epee::wipeabl
     if (!passphrase.empty())
     {
       crypto::secret_key key;
-    crypto::cn_slow_hash(passphrase.data(), passphrase.size(), (crypto::hash&)key);
+      cn_pow_hash_v3 cph;
+      cph.hash(passphrase.data(), passphrase.size(), key.data);
       sc_reduce32((unsigned char *)key.data);
       data = encrypt(data, key, true);
     }
@@ -1446,13 +1473,15 @@ bool wallet2::reconnect_device()
     hwdev.set_derivation_path(m_device_derivation_path);
     hwdev.set_callback(get_device_callback());
     r = hwdev.init();
-  if (!r){
+    if (!r)
+    {
       MERROR("Could not init device");
       return false;
     }
 
     r = hwdev.connect();
-  if (!r){
+    if (!r)
+    {
       MERROR("Could not connect to the device");
       return false;
     }
@@ -1651,6 +1680,22 @@ bool wallet2::is_spent(size_t idx, bool strict) const
     return is_spent(td, strict);
   }
   //----------------------------------------------------------------------------------------------------
+  void wallet2::set_offshore_spent(size_t idx, uint64_t height)
+  {
+    transfer_details &td = m_offshore_transfers[idx];
+    LOG_PRINT_L2("Setting SPENT at " << height << ": ki " << td.m_key_image << ", amount " << print_money(td.m_amount));
+    td.m_spent = true;
+    td.m_spent_height = height;
+  }
+  //----------------------------------------------------------------------------------------------------
+  void wallet2::set_offshore_unspent(size_t idx)
+  {
+    transfer_details &td = m_offshore_transfers[idx];
+    LOG_PRINT_L2("Setting UNSPENT: ki " << td.m_key_image << ", amount " << print_money(td.m_amount));
+    td.m_spent = false;
+    td.m_spent_height = 0;
+  }
+  //----------------------------------------------------------------------------------------------------
   void wallet2::freeze(size_t idx)
   {
     CHECK_AND_ASSERT_THROW_MES(idx < m_transfers.size(), "Invalid transfer_details index");
@@ -1708,13 +1753,20 @@ void wallet2::check_acc_out_precomp(const tx_out &o, const crypto::key_derivatio
     hw::device &hwdev = m_account.get_device();
     boost::unique_lock<hw::device> hwdev_lock(hwdev);
     hwdev.set_mode(hw::device::TRANSACTION_PARSE);
-  if (o.target.type() !=  typeid(txout_to_key))
+    if (o.target.type() != typeid(txout_to_key) && o.target.type() != typeid(txout_offshore))
     {
       tx_scan_info.error = true;
       LOG_ERROR("wrong type id in transaction out");
       return;
     }
+    if (o.target.type() == typeid(txout_to_key))
+    {
       tx_scan_info.received = is_out_to_acc_precomp(m_subaddresses, boost::get<txout_to_key>(o.target).key, derivation, additional_derivations, i, hwdev);
+    }
+    else
+    {
+      tx_scan_info.received = is_out_to_acc_precomp(m_subaddresses, boost::get<txout_offshore>(o.target).key, derivation, additional_derivations, i, hwdev);
+    }
     if (tx_scan_info.received)
     {
       tx_scan_info.money_transfered = o.amount; // may be 0 for ringct outputs
@@ -1764,6 +1816,7 @@ static uint64_t decodeRct(const rct::rctSig & rv, const crypto::key_derivation &
       case rct::RCTTypeSimple:
       case rct::RCTTypeBulletproof:
       case rct::RCTTypeBulletproof2:
+      case rct::RCTTypeCLSAG:
         return rct::decodeRctSimple(rv, rct::sk2rct(scalar1), i, mask, hwdev);
       case rct::RCTTypeFull:
         return rct::decodeRct(rv, rct::sk2rct(scalar1), i, mask, hwdev);
@@ -1791,8 +1844,8 @@ void wallet2::scan_output(const cryptonote::transaction &tx, bool miner_tx, cons
       if (!m_encrypt_keys_after_refresh)
       {
         boost::optional<epee::wipeable_string> pwd = m_callback->on_get_password(pool ? "output found in pool" : "output received");
-      THROW_WALLET_EXCEPTION_IF(!pwd, error::password_needed, tr("Password is needed to compute key image for incoming monero"));
-      THROW_WALLET_EXCEPTION_IF(!verify_password(*pwd), error::password_needed, tr("Invalid password: password is needed to compute key image for incoming monero"));
+        THROW_WALLET_EXCEPTION_IF(!pwd, error::password_needed, tr("Password is needed to compute key image for incoming haven"));
+        THROW_WALLET_EXCEPTION_IF(!verify_password(*pwd), error::password_needed, tr("Invalid password: password is needed to compute key image for incoming haven"));
         decrypt_keys(*pwd);
         m_encrypt_keys_after_refresh = *pwd;
       }
@@ -1831,6 +1884,58 @@ void wallet2::scan_output(const cryptonote::transaction &tx, bool miner_tx, cons
     ++num_vouts_received;
   }
   //----------------------------------------------------------------------------------------------------
+  void wallet2::scan_offshore_output(const cryptonote::transaction &tx, bool miner_tx, const crypto::public_key &tx_pub_key, size_t i, tx_scan_info_t &tx_scan_info, int &num_vouts_received, std::unordered_map<cryptonote::subaddress_index, uint64_t> &tx_money_got_in_outs, std::vector<size_t> &outs, bool pool)
+  {
+    THROW_WALLET_EXCEPTION_IF(i >= tx.vout.size(), error::wallet_internal_error, "Invalid vout index");
+
+    // if keys are encrypted, ask for password
+    if (m_ask_password == AskPasswordToDecrypt && !m_unattended && !m_watch_only && !m_multisig_rescan_k)
+    {
+      static critical_section password_lock;
+      CRITICAL_REGION_LOCAL(password_lock);
+      if (!m_encrypt_keys_after_refresh)
+      {
+        boost::optional<epee::wipeable_string> pwd = m_callback->on_get_password(pool ? "output found in pool" : "output received");
+        THROW_WALLET_EXCEPTION_IF(!pwd, error::password_needed, tr("Password is needed to compute key image for incoming haven"));
+        THROW_WALLET_EXCEPTION_IF(!verify_password(*pwd), error::password_needed, tr("Invalid password: password is needed to compute key image for incoming haven"));
+        decrypt_keys(*pwd);
+        m_encrypt_keys_after_refresh = *pwd;
+      }
+    }
+
+    if (m_multisig)
+    {
+      tx_scan_info.in_ephemeral.pub = boost::get<cryptonote::txout_offshore>(tx.vout[i].target).key;
+      tx_scan_info.in_ephemeral.sec = crypto::null_skey;
+      tx_scan_info.ki = rct::rct2ki(rct::zero());
+    }
+    else
+    {
+      bool r = cryptonote::generate_key_image_helper_precomp(m_account.get_keys(), boost::get<cryptonote::txout_offshore>(tx.vout[i].target).key, tx_scan_info.received->derivation, i, tx_scan_info.received->index, tx_scan_info.in_ephemeral, tx_scan_info.ki, m_account.get_device());
+      THROW_WALLET_EXCEPTION_IF(!r, error::wallet_internal_error, "Failed to generate key image");
+      THROW_WALLET_EXCEPTION_IF(tx_scan_info.in_ephemeral.pub != boost::get<cryptonote::txout_offshore>(tx.vout[i].target).key,
+                                error::wallet_internal_error, "key_image generated ephemeral public key not matched with output_key");
+    }
+
+    THROW_WALLET_EXCEPTION_IF(std::find(outs.begin(), outs.end(), i) != outs.end(), error::wallet_internal_error, "Same output cannot be added twice");
+    if (tx_scan_info.money_transfered == 0 && !miner_tx)
+    {
+      tx_scan_info.money_transfered = tools::decodeRct(tx.rct_signatures, tx_scan_info.received->derivation, i, tx_scan_info.mask, m_account.get_device());
+    }
+    if (tx_scan_info.money_transfered == 0)
+    {
+      MERROR("Invalid output amount, skipping");
+      tx_scan_info.error = true;
+      return;
+    }
+    outs.push_back(i);
+    THROW_WALLET_EXCEPTION_IF(tx_money_got_in_outs[tx_scan_info.received->index] >= std::numeric_limits<uint64_t>::max() - tx_scan_info.money_transfered,
+                              error::wallet_internal_error, "Overflow in received amounts");
+    tx_money_got_in_outs[tx_scan_info.received->index] += tx_scan_info.money_transfered;
+    tx_scan_info.amount = tx_scan_info.money_transfered;
+    ++num_vouts_received;
+  }
+  //----------------------------------------------------------------------------------------------------
   void wallet2::cache_tx_data(const cryptonote::transaction &tx, const crypto::hash &txid, tx_cache_data &tx_cache_data) const
   {
     if (!parse_tx_extra(tx.extra, tx_cache_data.tx_extra_fields))
@@ -1881,16 +1986,178 @@ bool wallet2::spends_one_of_ours(const cryptonote::transaction &tx) const
     return false;
   }
   //----------------------------------------------------------------------------------------------------
+  bool wallet2::get_pricing_record(offshore::pricing_record &pr, const uint64_t height)
+  {
+    // Issue an RPC call to get the block header (and thus the pricing record) at the specified height
+    cryptonote::COMMAND_RPC_GET_BLOCK_HEADER_BY_HEIGHT::request req = AUTO_VAL_INIT(req);
+    cryptonote::COMMAND_RPC_GET_BLOCK_HEADER_BY_HEIGHT::response res = AUTO_VAL_INIT(res);
+    m_daemon_rpc_mutex.lock();
+    req.height = height;
+    bool r = invoke_http_json_rpc("/json_rpc", "getblockheaderbyheight", req, res, rpc_timeout);
+    m_daemon_rpc_mutex.unlock();
+    if (r && res.status == CORE_RPC_STATUS_OK)
+    {
+      // Got the block header - verify the pricing record
+      THROW_WALLET_EXCEPTION_IF(res.block_header.pricing_record == offshore::pricing_record(),
+                                error::wallet_internal_error, "Invalid pricing record in block header - offshore TXs disabled. Please try again later.");
+
+      // Return the pricing record we retrieved
+      pr = res.block_header.pricing_record;
+      return true;
+    }
+    else
+    {
+      MERROR("Failed to request block header from daemon");
+      return false;
+    }
+  }
+  //----------------------------------------------------------------------------------------------------
+  uint64_t wallet2::get_xusd_amount(const uint64_t xhv_amount, const uint64_t height)
+  {
+    // Issue an RPC call to get the block header (and thus the pricing record) at the specified height
+    cryptonote::COMMAND_RPC_GET_BLOCK_HEADER_BY_HEIGHT::request req = AUTO_VAL_INIT(req);
+    cryptonote::COMMAND_RPC_GET_BLOCK_HEADER_BY_HEIGHT::response res = AUTO_VAL_INIT(res);
+    m_daemon_rpc_mutex.lock();
+    req.height = height;
+    bool r = invoke_http_json_rpc("/json_rpc", "getblockheaderbyheight", req, res, rpc_timeout);
+    m_daemon_rpc_mutex.unlock();
+    if (r && res.status == CORE_RPC_STATUS_OK)
+    {
+      // Got the block header - verify the pricing record
+      THROW_WALLET_EXCEPTION_IF(res.block_header.pricing_record == offshore::pricing_record(),
+                                error::wallet_internal_error, "Invalid pricing record in block header - offshore TXs disabled. Please try again later.");
+
+      // Now work out the amount
+      //double d_xhv_amount = boost::lexical_cast<double>(xhv_amount) / 1000000000000.0;
+      //double d_exchange_rate = boost::lexical_cast<double>(res.block_header.pricing_record.unused1);
+      //uint64_t xusd_amount = (uint64_t)(d_xhv_amount * d_exchange_rate);
+      boost::multiprecision::uint128_t xhv_128 = xhv_amount;
+      boost::multiprecision::uint128_t exchange_128 = res.block_header.pricing_record.unused1;
+      boost::multiprecision::uint128_t xusd_128 = xhv_128 * exchange_128;
+      xusd_128 /= 1000000000000;
+      //if (xusd_128 != xusd_amount) {
+      //  MERROR("Conversion error detected in get_xusd_amount() : double=" << xusd_amount << ", 128-bit=" << xusd_128);
+      //  THROW_WALLET_EXCEPTION_IF(xusd_128 != xusd_amount, error::wallet_internal_error, "get_xusd_amount() conversion error");
+      //}
+      //LOG_PRINT_L0("XHV = " << xhv_amount << ", USD = " << xusd_amount << ", ER = " << res.block_header.pricing_record.unused1);
+      return (uint64_t)xusd_128;
+    }
+    else
+    {
+      MERROR("Failed to request block header from daemon");
+      return 0;
+    }
+  }
+  //----------------------------------------------------------------------------------------------------
+  uint64_t wallet2::get_xhv_amount(const uint64_t xusd_amount, const uint64_t height)
+  {
+    // Issue an RPC call to get the block header (and thus the pricing record) at the specified height
+    cryptonote::COMMAND_RPC_GET_BLOCK_HEADER_BY_HEIGHT::request req = AUTO_VAL_INIT(req);
+    cryptonote::COMMAND_RPC_GET_BLOCK_HEADER_BY_HEIGHT::response res = AUTO_VAL_INIT(res);
+    m_daemon_rpc_mutex.lock();
+    req.height = height;
+    bool r = invoke_http_json_rpc("/json_rpc", "getblockheaderbyheight", req, res, rpc_timeout);
+    m_daemon_rpc_mutex.unlock();
+    if (r && res.status == CORE_RPC_STATUS_OK)
+    {
+      // Got the block header - verify the pricing record
+      THROW_WALLET_EXCEPTION_IF(res.block_header.pricing_record == offshore::pricing_record(),
+                                error::wallet_internal_error, "Invalid pricing record in block header - offshore TXs disabled. Please try again later.");
+
+      // Now work out the amount
+      //double d_xusd_amount = boost::lexical_cast<double>(xusd_amount);
+      //double d_exchange_rate = boost::lexical_cast<double>(res.block_header.pricing_record.unused1);
+      //uint64_t xhv_amount = (uint64_t)((d_xusd_amount / d_exchange_rate) * 1000000000000.0);
+      boost::multiprecision::uint128_t xusd_128 = xusd_amount;
+      boost::multiprecision::uint128_t exchange_128 = res.block_header.pricing_record.unused1;
+      boost::multiprecision::uint128_t xhv_128 = xusd_128 * 1000000000000;
+      xhv_128 /= exchange_128;
+      //if (xhv_128 != xhv_amount) {
+      //  MERROR("Conversion error detected in get_xhv_amount() : double=" << xhv_amount << ", 128-bit=" << xhv_128);
+      //  THROW_WALLET_EXCEPTION_IF(xhv_128 != xhv_amount, error::wallet_internal_error, "get_xhv_amount() conversion error");
+      //}
+      //LOG_PRINT_L0("XHV = " << xhv_amount << ", USD = " << xusd_amount << ", ER = " << res.block_header.pricing_record.unused1);
+      return (uint64_t)xhv_128;
+    }
+    else
+    {
+      MERROR("Failed to request block header from daemon");
+      return 0;
+    }
+  }
+  //----------------------------------------------------------------------------------------------------
   void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote::transaction &tx, const std::vector<uint64_t> &o_indices, uint64_t height, uint8_t block_version, uint64_t ts, bool miner_tx, bool pool, bool double_spend_seen, const tx_cache_data &tx_cache_data, std::map<std::pair<uint64_t, uint64_t>, size_t> *output_tracker_cache)
   {
     PERF_TIMER(process_new_transaction);
     // In this function, tx (probably) only contains the base information
     // (that is, the prunable stuff may or may not be included)
-  if (!miner_tx && !pool)
+
+    // Check to see if this is an offshore TX
+    bool bOffshoreTx = false;
+    tx_extra_offshore offshore_data;
+    if (tx.extra.size())
+    {
+      // Check to see if this is an offshore tx
+      bOffshoreTx = get_offshore_from_tx_extra(tx.extra, offshore_data);
+      if (bOffshoreTx)
+      {
+      }
+    }
+
+    // Flags to track offshore TX direction
+    bool offshore = false;
+    bool onshore = false;
+    bool offshore_to_offshore = false;
+    if (bOffshoreTx)
+    {
+      // Set the bool flags
+      if ((offshore_data.data.at(0) > 'A') && (offshore_data.data.at(1) > 'A'))
+      {
+        offshore_to_offshore = true;
+      }
+      else if (offshore_data.data.at(0) > 'A')
+      {
+        onshore = true;
+      }
+      else
+      {
+        offshore = true;
+      }
+    }
+
+    // Should check all inputs and outputs.
+    bool onshore_in = false;
+    bool offshore_in = false;
+    bool offshore_out = false;
+    for (size_t i = 0; i < tx.vin.size(); i++)
+    {
+      if (tx.vin[i].type() == typeid(txin_onshore))
+      {
+        onshore_in = true;
+      }
+      else if (tx.vin[i].type() == typeid(txin_offshore))
+      {
+        offshore_in = true;
+      }
+    }
+    for (size_t i = 0; i < tx.vout.size(); i++)
+    {
+      if (tx.vout[i].target.type() == typeid(txout_offshore))
+        offshore_out = true;
+    }
+
+    if (offshore_out && !miner_tx && !pool)
+    {
+      process_offshore_unconfirmed(txid, tx, height);
+    }
+    else if (!miner_tx && !pool)
+    {
       process_unconfirmed(txid, tx, height);
+    }
 
     // per receiving subaddress index
     std::unordered_map<cryptonote::subaddress_index, uint64_t> tx_money_got_in_outs;
+    std::unordered_map<cryptonote::subaddress_index, uint64_t> tx_money_got_in_offshore_outs;
     std::unordered_map<cryptonote::subaddress_index, amounts_container> tx_amounts_individual_outs;
 
     crypto::public_key tx_pub_key = null_pkey;
@@ -1912,9 +2179,11 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
     std::vector<tx_scan_info_t> tx_scan_info(tx.vout.size());
     std::deque<bool> output_found(tx.vout.size(), false);
     uint64_t total_received_1 = 0;
+    uint64_t total_received_offshore = 0;
     while (!tx.vout.empty())
     {
       std::vector<size_t> outs;
+      std::vector<size_t> offshore_outs;
       // if tx.vout is not empty, we loop through all tx pubkeys
 
       tx_extra_pub_key pub_key_field;
@@ -1934,6 +2203,7 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
       }
 
       int num_vouts_received = 0;
+      int num_offshore_vouts_received = 0;
       tx_pub_key = pub_key_field.pub_key;
       tools::threadpool &tpool = tools::threadpool::getInstance();
       tools::threadpool::waiter waiter;
@@ -2006,8 +2276,7 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
           // the first one was already checked
           for (size_t i = 1; i < tx.vout.size(); ++i)
           {
-          tpool.submit(&waiter, boost::bind(&wallet2::check_acc_out_precomp_once, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,
-            std::cref(is_out_data_ptr), std::ref(tx_scan_info[i]), std::ref(output_found[i])), true);
+            tpool.submit(&waiter, boost::bind(&wallet2::check_acc_out_precomp_once, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i, std::cref(is_out_data_ptr), std::ref(tx_scan_info[i]), std::ref(output_found[i])), true);
           }
           waiter.wait(&tpool);
           // then scan all outputs from 0
@@ -2020,7 +2289,14 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
             if (tx_scan_info[i].received)
             {
               hwdev.conceal_derivation(tx_scan_info[i].received->derivation, tx_pub_key, additional_tx_pub_keys.data, derivation, additional_derivations);
+              if (tx.vout[i].target.type() == typeid(txout_to_key))
+              {
                 scan_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs, pool);
+              }
+              else
+              {
+                scan_offshore_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_offshore_vouts_received, tx_money_got_in_offshore_outs, offshore_outs, pool);
+              }
               if (!tx_scan_info[i].error)
               {
                 tx_amounts_individual_outs[tx_scan_info[i].received->index].push_back(tx_scan_info[i].money_transfered);
@@ -2033,8 +2309,7 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
       {
         for (size_t i = 0; i < tx.vout.size(); ++i)
         {
-        tpool.submit(&waiter, boost::bind(&wallet2::check_acc_out_precomp_once, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i,
-            std::cref(is_out_data_ptr), std::ref(tx_scan_info[i]), std::ref(output_found[i])), true);
+          tpool.submit(&waiter, boost::bind(&wallet2::check_acc_out_precomp_once, this, std::cref(tx.vout[i]), std::cref(derivation), std::cref(additional_derivations), i, std::cref(is_out_data_ptr), std::ref(tx_scan_info[i]), std::ref(output_found[i])), true);
         }
         waiter.wait(&tpool);
 
@@ -2047,7 +2322,14 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
           if (tx_scan_info[i].received)
           {
             hwdev.conceal_derivation(tx_scan_info[i].received->derivation, tx_pub_key, additional_tx_pub_keys.data, derivation, additional_derivations);
+            if (tx.vout[i].target.type() == typeid(txout_to_key))
+            {
               scan_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs, pool);
+            }
+            else
+            {
+              scan_offshore_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_offshore_vouts_received, tx_money_got_in_offshore_outs, offshore_outs, pool);
+            }
             if (!tx_scan_info[i].error)
             {
               tx_amounts_individual_outs[tx_scan_info[i].received->index].push_back(tx_scan_info[i].money_transfered);
@@ -2067,7 +2349,14 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
             boost::unique_lock<hw::device> hwdev_lock(hwdev);
             hwdev.set_mode(hw::device::NONE);
             hwdev.conceal_derivation(tx_scan_info[i].received->derivation, tx_pub_key, additional_tx_pub_keys.data, derivation, additional_derivations);
+            if (tx.vout[i].target.type() == typeid(txout_to_key))
+            {
               scan_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs, pool);
+            }
+            else
+            {
+              scan_offshore_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_offshore_vouts_received, tx_money_got_in_offshore_outs, offshore_outs, pool);
+            }
             if (!tx_scan_info[i].error)
             {
               tx_amounts_individual_outs[tx_scan_info[i].received->index].push_back(tx_scan_info[i].money_transfered);
@@ -2089,14 +2378,11 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
 
         for (size_t o : outs)
         {
-	THROW_WALLET_EXCEPTION_IF(tx.vout.size() <= o, error::wallet_internal_error, "wrong out in transaction: internal index=" +
-				  std::to_string(o) + ", total_outs=" + std::to_string(tx.vout.size()));
+          THROW_WALLET_EXCEPTION_IF(tx.vout.size() <= o, error::wallet_internal_error, "wrong out in transaction: internal index=" + std::to_string(o) + ", total_outs=" + std::to_string(tx.vout.size()));
 
           auto kit = m_pub_keys.find(tx_scan_info[o].in_ephemeral.pub);
           THROW_WALLET_EXCEPTION_IF(kit != m_pub_keys.end() && kit->second >= m_transfers.size(),
-            error::wallet_internal_error, std::string("Unexpected transfer index from public key: ")
-            + "got " + (kit == m_pub_keys.end() ? "<none>" : boost::lexical_cast<std::string>(kit->second))
-            + ", m_transfers.size() is " + boost::lexical_cast<std::string>(m_transfers.size()));
+                                    error::wallet_internal_error, std::string("Unexpected transfer index from public key: ") + "got " + (kit == m_pub_keys.end() ? "<none>" : boost::lexical_cast<std::string>(kit->second)) + ", m_transfers.size() is " + boost::lexical_cast<std::string>(m_transfers.size()));
           if (kit == m_pub_keys.end())
           {
             uint64_t amount = tx.vout[o].amount ? tx.vout[o].amount : tx_scan_info[o].amount;
@@ -2141,7 +2427,7 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
                 td.m_mask = tx_scan_info[o].mask;
                 td.m_rct = true;
               }
-            else if (miner_tx && tx.version == 2)
+              else if (miner_tx && tx.version >= 2)
               {
                 td.m_mask = rct::identity();
                 td.m_rct = true;
@@ -2220,7 +2506,7 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
                 td.m_mask = tx_scan_info[o].mask;
                 td.m_rct = true;
               }
-            else if (miner_tx && tx.version == 2)
+              else if (miner_tx && tx.version >= 2)
               {
                 td.m_mask = rct::identity();
                 td.m_rct = true;
@@ -2251,60 +2537,315 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
           }
         }
       }
+
+      if (!offshore_outs.empty() && num_offshore_vouts_received > 0)
+      {
+        //good news - got money! take care about it
+        //usually we have only one transfer for user in transaction
+        if (!pool)
+        {
+          THROW_WALLET_EXCEPTION_IF(tx.vout.size() != o_indices.size(), error::wallet_internal_error,
+                                    "transactions outputs size=" + std::to_string(tx.vout.size()) +
+                                        " not match with daemon response size=" + std::to_string(o_indices.size()));
         }
 
-  THROW_WALLET_EXCEPTION_IF(tx_money_got_in_outs.size() != tx_amounts_individual_outs.size(), error::wallet_internal_error, "Inconsistent size of output arrays");
+        for (size_t o : offshore_outs)
+        {
+          THROW_WALLET_EXCEPTION_IF(tx.vout.size() <= o, error::wallet_internal_error, "wrong out in transaction: internal index=" + std::to_string(o) + ", total_outs=" + std::to_string(tx.vout.size()));
 
-  uint64_t tx_money_spent_in_ins = 0;
-  // The line below is equivalent to "boost::optional<uint32_t> subaddr_account;", but avoids the GCC warning: ‘*((void*)& subaddr_account +4)’ may be used uninitialized in this function
-  // It's a GCC bug with boost::optional, see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=47679
-  auto subaddr_account ([]()->boost::optional<uint32_t> {return boost::none;}());
-  std::set<uint32_t> subaddr_indices;
-  // check all outputs for spending (compare key images)
-  for(auto& in: tx.vin)
+          auto kit = m_pub_keys.find(tx_scan_info[o].in_ephemeral.pub);
+          THROW_WALLET_EXCEPTION_IF(kit != m_pub_keys.end() && kit->second >= m_offshore_transfers.size(),
+                                    error::wallet_internal_error, std::string("Unexpected transfer index from public key: ") + "got " + (kit == m_pub_keys.end() ? "<none>" : boost::lexical_cast<std::string>(kit->second)) + ", m_offshore_transfers.size() is " + boost::lexical_cast<std::string>(m_offshore_transfers.size()));
+          if (kit == m_pub_keys.end())
           {
-    if(in.type() != typeid(cryptonote::txin_to_key))
-      continue;
-    const cryptonote::txin_to_key &in_to_key = boost::get<cryptonote::txin_to_key>(in);
-    auto it = m_key_images.find(in_to_key.k_image);
-    if(it != m_key_images.end())
+            uint64_t amount = tx.vout[o].amount ? tx.vout[o].amount : tx_scan_info[o].amount;
+            if (!pool)
             {
-      transfer_details& td = m_transfers[it->second];
-      uint64_t amount = in_to_key.amount;
-      if (amount > 0)
+              m_offshore_transfers.push_back(boost::value_initialized<transfer_details>());
+              transfer_details &td = m_offshore_transfers.back();
+              td.m_block_height = height;
+              td.m_internal_output_index = o;
+              td.m_global_output_index = o_indices[o];
+              td.m_tx = (const cryptonote::transaction_prefix &)tx;
+              td.m_txid = txid;
+              td.m_key_image = tx_scan_info[o].ki;
+              td.m_key_image_known = !m_watch_only && !m_multisig;
+              if (!td.m_key_image_known)
               {
-        if(amount != td.amount())
+                // we might have cold signed, and have a mapping to key images
+                std::unordered_map<crypto::public_key, crypto::key_image>::const_iterator i = m_cold_key_images.find(tx_scan_info[o].in_ephemeral.pub);
+                if (i != m_cold_key_images.end())
                 {
-          MERROR("Inconsistent amount in tx input: got " << print_money(amount) <<
-            ", expected " << print_money(td.amount()));
-          // this means:
-          //   1) the same output pub key was used as destination multiple times,
-          //   2) the wallet set the highest amount among them to transfer_details::m_amount, and
-          //   3) the wallet somehow spent that output with an amount smaller than the above amount, causing inconsistency
-          td.m_amount = amount;
+                  td.m_key_image = i->second;
+                  td.m_key_image_known = true;
                 }
               }
-      else
+              if (m_watch_only)
               {
-        amount = td.amount();
+                // for view wallets, that flag means "we want to request it"
+                td.m_key_image_request = true;
               }
-      tx_money_spent_in_ins += amount;
-      if (subaddr_account && *subaddr_account != td.m_subaddr_index.major)
-        LOG_ERROR("spent funds are from different subaddress accounts; count of incoming/outgoing payments will be incorrect");
-      subaddr_account = td.m_subaddr_index.major;
-      subaddr_indices.insert(td.m_subaddr_index.minor);
-      if (!pool)
+              else
               {
-        LOG_PRINT_L0("Spent money: " << print_money(amount) << ", with tx: " << txid);
-        set_spent(it->second, height);
-        if (0 != m_callback)
-          m_callback->on_money_spent(height, txid, tx, amount, tx, td.m_subaddr_index);
-      }
+                td.m_key_image_request = false;
               }
-
+              td.m_key_image_partial = m_multisig;
+              td.m_amount = amount;
+              td.m_pk_index = pk_index - 1;
+              td.m_subaddr_index = tx_scan_info[o].received->index;
+              expand_subaddresses(tx_scan_info[o].received->index);
+              if (tx.vout[o].amount == 0)
+              {
+                td.m_mask = tx_scan_info[o].mask;
+                td.m_rct = true;
+              }
+              else if (miner_tx && tx.version >= 2)
+              {
+                td.m_mask = rct::identity();
+                td.m_rct = true;
+              }
+              else
+              {
+                td.m_mask = rct::identity();
+                td.m_rct = false;
+              }
+              td.m_frozen = false;
+              set_offshore_unspent(m_offshore_transfers.size() - 1);
+              if (td.m_key_image_known)
+                m_key_images[td.m_key_image] = m_offshore_transfers.size() - 1;
+              m_pub_keys[tx_scan_info[o].in_ephemeral.pub] = m_offshore_transfers.size() - 1;
+              if (output_tracker_cache)
+                (*output_tracker_cache)[std::make_pair(tx.vout[o].amount, td.m_global_output_index)] = m_offshore_transfers.size() - 1;
+              if (m_multisig)
+              {
+                THROW_WALLET_EXCEPTION_IF(!m_multisig_rescan_offshore_k && m_multisig_rescan_offshore_info,
+                                          error::wallet_internal_error, "NULL m_multisig_rescan_offshore_k");
+                if (m_multisig_rescan_offshore_info && m_multisig_rescan_offshore_info->front().size() >= m_offshore_transfers.size())
+                  update_multisig_rescan_info(*m_multisig_rescan_offshore_k, *m_multisig_rescan_offshore_info, m_offshore_transfers.size() - 1, true);
+              }
+              LOG_PRINT_L0("Received money: " << print_money(td.amount()) << ", with tx: " << txid);
+              if (0 != m_callback)
+                m_callback->on_money_received(height, txid, tx, td.m_amount, td.m_subaddr_index, td.m_tx.unlock_time, true);
+            }
+            total_received_1 += amount;
+            notify = true;
+          }
+          else if (m_offshore_transfers[kit->second].m_spent || m_offshore_transfers[kit->second].amount() >= tx_scan_info[o].amount)
+          {
+            LOG_ERROR("Public key " << epee::string_tools::pod_to_hex(kit->first)
+                                    << " from received " << print_money(tx_scan_info[o].amount) << " output already exists with "
+                                    << (m_offshore_transfers[kit->second].m_spent ? "spent" : "unspent") << " "
+                                    << print_money(m_offshore_transfers[kit->second].amount()) << " in tx " << m_offshore_transfers[kit->second].m_txid << ", received output ignored");
+            THROW_WALLET_EXCEPTION_IF(tx_money_got_in_offshore_outs[tx_scan_info[o].received->index] < tx_scan_info[o].amount,
+                                      error::wallet_internal_error, "Unexpected values of new and old outputs");
+            tx_money_got_in_offshore_outs[tx_scan_info[o].received->index] -= tx_scan_info[o].amount;
+
+            amounts_container &tx_amounts_this_out = tx_amounts_individual_outs[tx_scan_info[o].received->index]; // Only for readability on the following lines
+            auto amount_iterator = std::find(tx_amounts_this_out.begin(), tx_amounts_this_out.end(), tx_scan_info[o].amount);
+            THROW_WALLET_EXCEPTION_IF(amount_iterator == tx_amounts_this_out.end(),
+                                      error::wallet_internal_error, "Unexpected values of new and old outputs");
+            tx_amounts_this_out.erase(amount_iterator);
+          }
+          else
+          {
+            LOG_ERROR("Public key " << epee::string_tools::pod_to_hex(kit->first)
+                                    << " from received " << print_money(tx_scan_info[o].amount) << " output already exists with "
+                                    << print_money(m_offshore_transfers[kit->second].amount()) << ", replacing with new output");
+            // The new larger output replaced a previous smaller one
+            THROW_WALLET_EXCEPTION_IF(tx_money_got_in_offshore_outs[tx_scan_info[o].received->index] < tx_scan_info[o].amount,
+                                      error::wallet_internal_error, "Unexpected values of new and old outputs");
+            THROW_WALLET_EXCEPTION_IF(m_offshore_transfers[kit->second].amount() > tx_scan_info[o].amount,
+                                      error::wallet_internal_error, "Unexpected values of new and old outputs");
+            tx_money_got_in_offshore_outs[tx_scan_info[o].received->index] -= m_offshore_transfers[kit->second].amount();
+
+            uint64_t amount = tx.vout[o].amount ? tx.vout[o].amount : tx_scan_info[o].amount;
+            uint64_t extra_amount = amount - m_offshore_transfers[kit->second].amount();
+            if (!pool)
+            {
+              transfer_details &td = m_offshore_transfers[kit->second];
+              td.m_block_height = height;
+              td.m_internal_output_index = o;
+              td.m_global_output_index = o_indices[o];
+              td.m_tx = (const cryptonote::transaction_prefix &)tx;
+              td.m_txid = txid;
+              td.m_amount = amount;
+              td.m_pk_index = pk_index - 1;
+              td.m_subaddr_index = tx_scan_info[o].received->index;
+              expand_subaddresses(tx_scan_info[o].received->index);
+              if (tx.vout[o].amount == 0)
+              {
+                td.m_mask = tx_scan_info[o].mask;
+                td.m_rct = true;
+              }
+              else if (miner_tx && tx.version >= 2)
+              {
+                td.m_mask = rct::identity();
+                td.m_rct = true;
+              }
+              else
+              {
+                td.m_mask = rct::identity();
+                td.m_rct = false;
+              }
+              if (output_tracker_cache)
+                (*output_tracker_cache)[std::make_pair(tx.vout[o].amount, td.m_global_output_index)] = kit->second;
+              if (m_multisig)
+              {
+                THROW_WALLET_EXCEPTION_IF(!m_multisig_rescan_offshore_k && m_multisig_rescan_offshore_info,
+                                          error::wallet_internal_error, "NULL m_multisig_rescan_offshore_k");
+                if (m_multisig_rescan_offshore_info && m_multisig_rescan_offshore_info->front().size() >= m_offshore_transfers.size())
+                  update_multisig_rescan_info(*m_multisig_rescan_offshore_k, *m_multisig_rescan_offshore_info, m_offshore_transfers.size() - 1, true);
+              }
+              THROW_WALLET_EXCEPTION_IF(td.get_public_key() != tx_scan_info[o].in_ephemeral.pub, error::wallet_internal_error, "Inconsistent public keys");
+              THROW_WALLET_EXCEPTION_IF(td.m_spent, error::wallet_internal_error, "Inconsistent spent status");
+
+              LOG_PRINT_L0("Received money: " << print_money(td.amount()) << ", with tx: " << txid);
+              if (0 != m_callback)
+                m_callback->on_money_received(height, txid, tx, td.m_amount, td.m_subaddr_index, td.m_tx.unlock_time, true);
+            }
+            total_received_offshore += extra_amount;
+            notify = true;
+          }
+        }
+      }
+    }
+
+    // HERE BE DRAGONS!!!
+    // THROW_WALLET_EXCEPTION_IF((tx_money_got_in_outs.size() + tx_money_got_in_offshore_outs.size()) != tx_amounts_individual_outs.size(), error::wallet_internal_error, "Inconsistent size of output arrays");
+    // LAND AHOY!!!
+
+    uint64_t tx_money_spent_in_ins = 0;
+    // The line below is equivalent to "boost::optional<uint32_t> subaddr_account;", but avoids the GCC warning: ‘*((void*)& subaddr_account +4)’ may be used uninitialized in this function
+    // It's a GCC bug with boost::optional, see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=47679
+    auto subaddr_account([]() -> boost::optional<uint32_t> { return boost::none; }());
+    std::set<uint32_t> subaddr_indices;
+    // check all outputs for spending (compare key images)
+    for (auto &in : tx.vin)
+    {
+      if (in.type() == typeid(cryptonote::txin_to_key))
+      {
+        const cryptonote::txin_to_key &in_to_key = boost::get<cryptonote::txin_to_key>(in);
+        auto it = m_key_images.find(in_to_key.k_image);
+        if (it != m_key_images.end())
+        {
+          transfer_details &td = m_transfers[it->second];
+          uint64_t amount = in_to_key.amount;
+          if (amount > 0)
+          {
+            if (amount != td.amount())
+            {
+              MERROR("Inconsistent amount in tx input: got " << print_money(amount) << ", expected " << print_money(td.amount()));
+              // this means:
+              //   1) the same output pub key was used as destination multiple times,
+              //   2) the wallet set the highest amount among them to transfer_details::m_amount, and
+              //   3) the wallet somehow spent that output with an amount smaller than the above amount, causing inconsistency
+              td.m_amount = amount;
+            }
+          }
+          else
+          {
+            amount = td.amount();
+          }
+          tx_money_spent_in_ins += amount;
+          if (subaddr_account && *subaddr_account != td.m_subaddr_index.major)
+            LOG_ERROR("spent funds are from different subaddress accounts; count of incoming/outgoing payments will be incorrect");
+          subaddr_account = td.m_subaddr_index.major;
+          subaddr_indices.insert(td.m_subaddr_index.minor);
+          if (!pool)
+          {
+            LOG_PRINT_L0("Spent money: " << print_money(amount) << ", with tx: " << txid);
+            set_spent(it->second, height);
+            if (0 != m_callback)
+              m_callback->on_money_spent(height, txid, tx, amount, tx, td.m_subaddr_index);
+          }
+        }
+      }
+      else if (in.type() == typeid(cryptonote::txin_offshore))
+      {
+        const cryptonote::txin_offshore &in_offshore = boost::get<cryptonote::txin_offshore>(in);
+        auto it = m_key_images.find(in_offshore.k_image);
+        if (it != m_key_images.end())
+        {
+          transfer_details &td = m_offshore_transfers[it->second];
+          uint64_t amount = in_offshore.amount;
+          if (amount > 0)
+          {
+            if (amount != td.amount())
+            {
+              MERROR("Inconsistent amount in tx input: got " << print_money(amount) << ", expected " << print_money(td.amount()));
+              // this means:
+              //   1) the same output pub key was used as destination multiple times,
+              //   2) the wallet set the highest amount among them to transfer_details::m_amount, and
+              //   3) the wallet somehow spent that output with an amount smaller than the above amount, causing inconsistency
+              td.m_amount = amount;
+            }
+          }
+          else
+          {
+            amount = td.amount();
+          }
+          tx_money_spent_in_ins += amount;
+          if (subaddr_account && *subaddr_account != td.m_subaddr_index.major)
+            LOG_ERROR("spent funds are from different subaddress accounts; count of incoming/outgoing payments will be incorrect");
+          subaddr_account = td.m_subaddr_index.major;
+          subaddr_indices.insert(td.m_subaddr_index.minor);
+          if (!pool)
+          {
+            LOG_PRINT_L0("Spent money: " << print_money(amount) << ", with tx: " << txid);
+            set_offshore_spent(it->second, height);
+            if (0 != m_callback)
+              m_callback->on_money_spent(height, txid, tx, amount, tx, td.m_subaddr_index, true);
+          }
+        }
+      }
+      else if (in.type() == typeid(cryptonote::txin_onshore))
+      {
+        const cryptonote::txin_onshore &in_onshore = boost::get<cryptonote::txin_onshore>(in);
+        auto it = m_key_images.find(in_onshore.k_image);
+        if (it != m_key_images.end())
+        {
+          transfer_details &td = m_offshore_transfers[it->second];
+          uint64_t amount = in_onshore.amount;
+          if (amount > 0)
+          {
+            if (amount != td.amount())
+            {
+              MERROR("Inconsistent amount in tx input: got " << print_money(amount) << ", expected " << print_money(td.amount()));
+              // this means:
+              //   1) the same output pub key was used as destination multiple times,
+              //   2) the wallet set the highest amount among them to transfer_details::m_amount, and
+              //   3) the wallet somehow spent that output with an amount smaller than the above amount, causing inconsistency
+              td.m_amount = amount;
+            }
+          }
+          else
+          {
+            amount = td.amount();
+          }
+          tx_money_spent_in_ins += amount;
+          if (subaddr_account && *subaddr_account != td.m_subaddr_index.major)
+            LOG_ERROR("spent funds are from different subaddress accounts; count of incoming/outgoing payments will be incorrect");
+          subaddr_account = td.m_subaddr_index.major;
+          subaddr_indices.insert(td.m_subaddr_index.minor);
+          if (!pool)
+          {
+            LOG_PRINT_L0("Spent money: " << print_money(amount) << ", with tx: " << txid);
+            set_offshore_spent(it->second, height);
+            if (0 != m_callback)
+              m_callback->on_money_spent(height, txid, tx, amount, tx, td.m_subaddr_index, true);
+          }
+        }
+      }
+      else
+      {
+      }
+
       if (!pool && m_track_uses)
       {
         PERF_TIMER(track_uses);
+        if (in.type() == typeid(cryptonote::txin_to_key))
+        {
+          const cryptonote::txin_to_key &in_to_key = boost::get<cryptonote::txin_to_key>(in);
           const uint64_t amount = in_to_key.amount;
           std::vector<uint64_t> offsets = cryptonote::relative_output_offsets_to_absolute(in_to_key.key_offsets);
           if (output_tracker_cache)
@@ -2320,7 +2861,36 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
               }
             }
           }
-      else for (transfer_details &td: m_transfers)
+          else
+            for (transfer_details &td : m_transfers)
+            {
+              if (amount != in_to_key.amount)
+                continue;
+              for (uint64_t offset : offsets)
+                if (offset == td.m_global_output_index)
+                  td.m_uses.push_back(std::make_pair(height, txid));
+            }
+        }
+        else if (in.type() == typeid(cryptonote::txin_offshore))
+        {
+          const cryptonote::txin_offshore &in_to_key = boost::get<cryptonote::txin_offshore>(in);
+          const uint64_t amount = in_to_key.amount;
+          std::vector<uint64_t> offsets = cryptonote::relative_output_offsets_to_absolute(in_to_key.key_offsets);
+          if (output_tracker_cache)
+          {
+            for (uint64_t offset : offsets)
+            {
+              const std::map<std::pair<uint64_t, uint64_t>, size_t>::const_iterator i = output_tracker_cache->find(std::make_pair(amount, offset));
+              if (i != output_tracker_cache->end())
+              {
+                size_t idx = i->second;
+                THROW_WALLET_EXCEPTION_IF(idx >= m_offshore_transfers.size(), error::wallet_internal_error, "Output tracker cache index out of range");
+                m_offshore_transfers[idx].m_uses.push_back(std::make_pair(height, txid));
+              }
+            }
+          }
+          else
+            for (transfer_details &td : m_offshore_transfers)
             {
               if (amount != in_to_key.amount)
                 continue;
@@ -2329,19 +2899,83 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
                   td.m_uses.push_back(std::make_pair(height, txid));
             }
         }
+        else if (in.type() == typeid(cryptonote::txin_onshore))
+        {
+          const cryptonote::txin_onshore &in_to_key = boost::get<cryptonote::txin_onshore>(in);
+          const uint64_t amount = in_to_key.amount;
+          std::vector<uint64_t> offsets = cryptonote::relative_output_offsets_to_absolute(in_to_key.key_offsets);
+          if (output_tracker_cache)
+          {
+            for (uint64_t offset : offsets)
+            {
+              const std::map<std::pair<uint64_t, uint64_t>, size_t>::const_iterator i = output_tracker_cache->find(std::make_pair(amount, offset));
+              if (i != output_tracker_cache->end())
+              {
+                size_t idx = i->second;
+                THROW_WALLET_EXCEPTION_IF(idx >= m_offshore_transfers.size(), error::wallet_internal_error, "Output tracker cache index out of range");
+                m_offshore_transfers[idx].m_uses.push_back(std::make_pair(height, txid));
+              }
+            }
+          }
+          else
+            for (transfer_details &td : m_offshore_transfers)
+            {
+              if (amount != in_to_key.amount)
+                continue;
+              for (uint64_t offset : offsets)
+                if (offset == td.m_global_output_index)
+                  td.m_uses.push_back(std::make_pair(height, txid));
+            }
+        }
+      }
+    }
+
+    uint64_t fee = miner_tx ? 0 : tx.version == 1 ? tx_money_spent_in_ins - get_outs_money_amount(tx) : (offshore_to_offshore || onshore) ? tx.rct_signatures.txnFee + tx.rct_signatures.txnOffshoreFee : tx.rct_signatures.txnFee_usd + tx.rct_signatures.txnOffshoreFee_usd;
+
+    if (tx_money_spent_in_ins > 0 && !pool)
+    {
+      if (offshore_to_offshore || onshore)
+      {
+        uint64_t self_received = std::accumulate<decltype(tx_money_got_in_outs.begin()), uint64_t>(tx_money_got_in_outs.begin(), tx_money_got_in_outs.end(), 0,
+                                                                                                   [&subaddr_account](uint64_t acc, const std::pair<cryptonote::subaddress_index, uint64_t> &p) {
+                                                                                                     return acc + (p.first.major == *subaddr_account ? p.second : 0);
+                                                                                                   });
+
+        uint64_t self_received_offshore = std::accumulate<decltype(tx_money_got_in_offshore_outs.begin()), uint64_t>(tx_money_got_in_offshore_outs.begin(), tx_money_got_in_offshore_outs.end(), 0,
+                                                                                                                     [&subaddr_account](uint64_t acc, const std::pair<cryptonote::subaddress_index, uint64_t> &p) {
+                                                                                                                       return acc + (p.first.major == *subaddr_account ? p.second : 0);
+                                                                                                                     });
+
+        if (onshore)
+        {
+          process_offshore_outgoing(txid, tx, height, ts, tx_money_spent_in_ins, self_received_offshore, *subaddr_account, subaddr_indices, offshore, offshore_to_offshore, onshore);
+
+          uint64_t fee = tx.rct_signatures.txnFee;
+          if (tx_money_spent_in_ins == self_received_offshore + fee)
+          {
+            auto i = m_confirmed_offshore_txs.find(txid);
+            THROW_WALLET_EXCEPTION_IF(i == m_confirmed_offshore_txs.end(), error::wallet_internal_error,
+                                      "confirmed tx wasn't found: " + string_tools::pod_to_hex(txid));
+            i->second.m_change = self_received_offshore;
+          }
+        }
+        else
+        {
+          process_offshore_outgoing(txid, tx, height, ts, tx_money_spent_in_ins, self_received_offshore, *subaddr_account, subaddr_indices, offshore, offshore_to_offshore, onshore);
         }
-
-  uint64_t fee = miner_tx ? 0 : tx.version == 1 ? tx_money_spent_in_ins - get_outs_money_amount(tx) : tx.rct_signatures.txnFee;
-
-  if (tx_money_spent_in_ins > 0 && !pool)
+      }
+      else
       {
-    uint64_t self_received = std::accumulate<decltype(tx_money_got_in_outs.begin()), uint64_t>(tx_money_got_in_outs.begin(), tx_money_got_in_outs.end(), 0,
-      [&subaddr_account] (uint64_t acc, const std::pair<cryptonote::subaddress_index, uint64_t>& p)
+        if (!onshore_in)
         {
+          uint64_t self_received = std::accumulate<decltype(tx_money_got_in_outs.begin()), uint64_t>(tx_money_got_in_outs.begin(), tx_money_got_in_outs.end(), 0,
+                                                                                                     [&subaddr_account](uint64_t acc, const std::pair<cryptonote::subaddress_index, uint64_t> &p) {
                                                                                                        return acc + (p.first.major == *subaddr_account ? p.second : 0);
                                                                                                      });
-    process_outgoing(txid, tx, height, ts, tx_money_spent_in_ins, self_received, *subaddr_account, subaddr_indices);
+          process_outgoing(txid, tx, height, ts, tx_money_spent_in_ins, self_received, *subaddr_account, subaddr_indices, offshore, offshore_to_offshore, onshore);
+
           // if sending to yourself at the same subaddress account, set the outgoing payment amount to 0 so that it's less confusing
+          uint64_t fee = tx.rct_signatures.txnFee;
           if (tx_money_spent_in_ins == self_received + fee)
           {
             auto i = m_confirmed_txs.find(txid);
@@ -2350,23 +2984,119 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
             i->second.m_change = self_received;
           }
         }
+        else
+        {
+          uint64_t self_received = std::accumulate<decltype(tx_money_got_in_offshore_outs.begin()), uint64_t>(tx_money_got_in_offshore_outs.begin(), tx_money_got_in_offshore_outs.end(), 0,
+                                                                                                              [&subaddr_account](uint64_t acc, const std::pair<cryptonote::subaddress_index, uint64_t> &p) {
+                                                                                                                return acc + (p.first.major == *subaddr_account ? p.second : 0);
+                                                                                                              });
+          process_outgoing(txid, tx, height, ts, tx_money_spent_in_ins, self_received, *subaddr_account, subaddr_indices, offshore, offshore_to_offshore, onshore);
+        }
+      }
+    }
 
+    if (offshore_out)
+    {
+      if (offshore_in)
+      {
         // remove change sent to the spending subaddress account from the list of received funds
-  uint64_t sub_change = 0;
-  for (auto i = tx_money_got_in_outs.begin(); i != tx_money_got_in_outs.end();)
+        for (auto i = tx_money_got_in_offshore_outs.begin(); i != tx_money_got_in_offshore_outs.end();)
         {
           if (subaddr_account && i->first.major == *subaddr_account)
+            i = tx_money_got_in_offshore_outs.erase(tx_money_got_in_offshore_outs.begin());
+          else
+            ++i;
+        }
+      }
+    }
+    else
+    {
+      if (!offshore_in)
+      {
+        // remove change sent to the spending subaddress account from the list of received funds
+        for (auto i = tx_money_got_in_outs.begin(); i != tx_money_got_in_outs.end();)
         {
-      sub_change += i->second;
-      tx_amounts_individual_outs.erase(i->first);
+          if (subaddr_account && i->first.major == *subaddr_account)
             i = tx_money_got_in_outs.erase(i);
-    }
           else
             ++i;
         }
+      }
+    }
+
+    // create payment_details for each incoming transfer to a subaddress index
+    if (tx_money_got_in_outs.size() > 0 && (!bOffshoreTx || onshore))
+    {
+      tx_extra_nonce extra_nonce;
+      crypto::hash payment_id = null_hash;
+      if (find_tx_extra_field_by_type(tx_extra_fields, extra_nonce))
+      {
+        crypto::hash8 payment_id8 = null_hash8;
+        if (get_encrypted_payment_id_from_tx_extra_nonce(extra_nonce.nonce, payment_id8))
+        {
+          // We got a payment ID to go with this tx
+          LOG_PRINT_L2("Found encrypted payment ID: " << payment_id8);
+          MINFO("Consider using subaddresses instead of encrypted payment IDs");
+          if (tx_pub_key != null_pkey)
+          {
+            if (!m_account.get_device().decrypt_payment_id(payment_id8, tx_pub_key, m_account.get_keys().m_view_secret_key))
+            {
+              LOG_PRINT_L0("Failed to decrypt payment ID: " << payment_id8);
+            }
+            else
+            {
+              LOG_PRINT_L2("Decrypted payment ID: " << payment_id8);
+              // put the 64 bit decrypted payment id in the first 8 bytes
+              memcpy(payment_id.data, payment_id8.data, 8);
+              // rest is already 0, but guard against code changes above
+              memset(payment_id.data + 8, 0, 24);
+            }
+          }
+          else
+          {
+            LOG_PRINT_L1("No public key found in tx, unable to decrypt payment id");
+          }
+        }
+        else if (get_payment_id_from_tx_extra_nonce(extra_nonce.nonce, payment_id))
+        {
+          LOG_PRINT_L2("Found unencrypted payment ID: " << payment_id);
+          MWARNING("Found unencrypted payment ID: these are bad for privacy, consider using subaddresses instead");
+        }
+      }
+      bool all_same = true;
+      for (const auto &i : tx_money_got_in_outs)
+      {
+        payment_details payment;
+        payment.m_tx_hash = txid;
+        payment.m_fee = fee;
+        payment.m_amount = i.second;
+        payment.m_block_height = height;
+        payment.m_unlock_time = tx.unlock_time;
+        payment.m_timestamp = ts;
+        payment.m_coinbase = miner_tx;
+        payment.m_offshore = offshore;
+        payment.m_offshore_to_offshore = offshore_to_offshore;
+        payment.m_onshore = onshore;
+        payment.m_subaddr_index = i.first;
+        if (pool)
+        {
+          if (emplace_or_replace(m_unconfirmed_payments, payment_id, pool_payment_details{payment, double_spend_seen}))
+            all_same = false;
+          if (0 != m_callback)
+            m_callback->on_unconfirmed_money_received(height, txid, tx, payment.m_amount, payment.m_subaddr_index);
+        }
+        else
+          m_payments.emplace(payment_id, payment);
+        LOG_PRINT_L2("Payment found in " << (pool ? "pool" : "block") << ": " << payment_id << " / " << payment.m_tx_hash << " / " << payment.m_amount);
+      }
+
+      // if it's a pool tx and we already had it, don't notify again
+      if (pool && all_same)
+        notify = false;
+    }
 
     // create payment_details for each incoming transfer to a subaddress index
-  if (tx_money_got_in_outs.size() > 0)
+    if (tx_money_got_in_offshore_outs.size() > 0 && (offshore || offshore_to_offshore))
     {
       tx_extra_nonce extra_nonce;
       crypto::hash payment_id = null_hash;
@@ -2415,6 +3145,7 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
         }
       }
 
+      /*
     uint64_t total_received_2 = sub_change;
     for (const auto& i : tx_money_got_in_outs)
       total_received_2 += i.second;
@@ -2428,9 +3159,10 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
       exit(1);
       return;
     }
+    */
 
       bool all_same = true;
-    for (const auto& i : tx_money_got_in_outs)
+      for (const auto &i : tx_money_got_in_offshore_outs)
       {
         payment_details payment;
         payment.m_tx_hash = txid;
@@ -2441,8 +3173,12 @@ void wallet2::process_new_transaction(const crypto::hash &txid, const cryptonote
         payment.m_unlock_time = tx.unlock_time;
         payment.m_timestamp = ts;
         payment.m_coinbase = miner_tx;
+        payment.m_offshore = offshore;
+        payment.m_offshore_to_offshore = offshore_to_offshore;
+        payment.m_onshore = onshore;
         payment.m_subaddr_index = i.first;
-      if (pool) {
+        if (pool)
+        {
           if (emplace_or_replace(m_unconfirmed_payments, payment_id, pool_payment_details{payment, double_spend_seen}))
             all_same = false;
           if (0 != m_callback)
@@ -2472,12 +3208,16 @@ void wallet2::process_unconfirmed(const crypto::hash &txid, const cryptonote::tr
       return;
 
     auto unconf_it = m_unconfirmed_txs.find(txid);
-  if(unconf_it != m_unconfirmed_txs.end()) {
-    if (store_tx_info()) {
-      try {
+    if (unconf_it != m_unconfirmed_txs.end())
+    {
+      if (store_tx_info())
+      {
+        try
+        {
           m_confirmed_txs.insert(std::make_pair(txid, confirmed_transfer_details(unconf_it->second, height)));
         }
-      catch (...) {
+        catch (...)
+        {
           // can fail if the tx has unexpected input types
           LOG_PRINT_L0("Failed to add outgoing transaction to confirmed transaction map");
         }
@@ -2486,7 +3226,32 @@ void wallet2::process_unconfirmed(const crypto::hash &txid, const cryptonote::tr
     }
   }
   //----------------------------------------------------------------------------------------------------
-void wallet2::process_outgoing(const crypto::hash &txid, const cryptonote::transaction &tx, uint64_t height, uint64_t ts, uint64_t spent, uint64_t received, uint32_t subaddr_account, const std::set<uint32_t>& subaddr_indices)
+  void wallet2::process_offshore_unconfirmed(const crypto::hash &txid, const cryptonote::transaction &tx, uint64_t height)
+  {
+    if (m_unconfirmed_txs.empty())
+      return;
+
+    auto unconf_it = m_unconfirmed_txs.find(txid);
+    if (unconf_it != m_unconfirmed_txs.end())
+    {
+      if (store_tx_info())
+      {
+        try
+        {
+          unconf_it->second.m_offshore = true;
+          m_confirmed_offshore_txs.insert(std::make_pair(txid, confirmed_transfer_details(unconf_it->second, height)));
+        }
+        catch (...)
+        {
+          // can fail if the tx has unexpected input types
+          LOG_PRINT_L0("Failed to add outgoing transaction to offshore transaction map");
+        }
+      }
+      m_unconfirmed_txs.erase(unconf_it);
+    }
+  }
+  //----------------------------------------------------------------------------------------------------
+  void wallet2::process_outgoing(const crypto::hash &txid, const cryptonote::transaction &tx, uint64_t height, uint64_t ts, uint64_t spent, uint64_t received, uint32_t subaddr_account, const std::set<uint32_t> &subaddr_indices, bool offshore, bool offshore_to_offshore, bool onshore)
   {
     std::pair<std::unordered_map<crypto::hash, confirmed_transfer_details>::iterator, bool> entry = m_confirmed_txs.insert(std::make_pair(txid, confirmed_transfer_details()));
     // fill with the info we know, some info might already be there
@@ -2499,7 +3264,7 @@ void wallet2::process_outgoing(const crypto::hash &txid, const cryptonote::trans
       if (tx.version == 1)
         entry.first->second.m_amount_out = get_outs_money_amount(tx);
       else
-      entry.first->second.m_amount_out = spent - tx.rct_signatures.txnFee;
+        entry.first->second.m_amount_out = spent - tx.rct_signatures.txnFee - tx.rct_signatures.txnOffshoreFee;
       entry.first->second.m_change = received;
 
       std::vector<tx_extra_field> tx_extra_fields;
@@ -2527,6 +3292,70 @@ void wallet2::process_outgoing(const crypto::hash &txid, const cryptonote::trans
     entry.first->second.m_unlock_time = tx.unlock_time;
 
     add_rings(tx);
+
+    entry.first->second.m_offshore = offshore;
+    entry.first->second.m_offshore_to_offshore = offshore_to_offshore;
+    entry.first->second.m_onshore = onshore;
+  }
+  //----------------------------------------------------------------------------------------------------
+  void wallet2::process_offshore_outgoing(const crypto::hash &txid, const cryptonote::transaction &tx, uint64_t height, uint64_t ts, uint64_t spent, uint64_t received, uint32_t subaddr_account, const std::set<uint32_t> &subaddr_indices, bool offshore, bool offshore_to_offshore, bool onshore)
+  {
+    std::pair<std::unordered_map<crypto::hash, confirmed_transfer_details>::iterator, bool> entry = m_confirmed_offshore_txs.insert(std::make_pair(txid, confirmed_transfer_details()));
+    // fill with the info we know, some info might already be there
+    if (entry.second)
+    {
+      // this case will happen if the tx is from our outputs, but was sent by another
+      // wallet (eg, we're a cold wallet and the hot wallet sent it). For RCT transactions,
+      // we only see 0 input amounts, so have to deduce amount out from other parameters.
+      entry.first->second.m_amount_in = spent;
+      if (tx.version == 1)
+        entry.first->second.m_amount_out = get_outs_money_amount(tx);
+      else
+        entry.first->second.m_amount_out = spent - tx.rct_signatures.txnFee_usd - tx.rct_signatures.txnOffshoreFee_usd;
+      entry.first->second.m_change = received;
+
+      std::vector<tx_extra_field> tx_extra_fields;
+      parse_tx_extra(tx.extra, tx_extra_fields); // ok if partially parsed
+      tx_extra_nonce extra_nonce;
+      if (find_tx_extra_field_by_type(tx_extra_fields, extra_nonce))
+      {
+        // we do not care about failure here
+        get_payment_id_from_tx_extra_nonce(extra_nonce.nonce, entry.first->second.m_payment_id);
+      }
+      entry.first->second.m_subaddr_account = subaddr_account;
+      entry.first->second.m_subaddr_indices = subaddr_indices;
+    }
+
+    entry.first->second.m_rings.clear();
+    for (const auto &in : tx.vin)
+    {
+      if (in.type() == typeid(cryptonote::txin_to_key))
+      {
+        const auto &txin = boost::get<cryptonote::txin_to_key>(in);
+        entry.first->second.m_rings.push_back(std::make_pair(txin.k_image, txin.key_offsets));
+      }
+      else if (in.type() == typeid(cryptonote::txin_offshore))
+      {
+        const auto &txin = boost::get<cryptonote::txin_offshore>(in);
+        entry.first->second.m_rings.push_back(std::make_pair(txin.k_image, txin.key_offsets));
+      }
+      else if (in.type() == typeid(cryptonote::txin_onshore))
+      {
+        const auto &txin = boost::get<cryptonote::txin_onshore>(in);
+        entry.first->second.m_rings.push_back(std::make_pair(txin.k_image, txin.key_offsets));
+      }
+      else
+        continue;
+    }
+    entry.first->second.m_block_height = height;
+    entry.first->second.m_timestamp = ts;
+    entry.first->second.m_unlock_time = tx.unlock_time;
+
+    add_rings(tx);
+
+    entry.first->second.m_offshore = offshore;
+    entry.first->second.m_offshore_to_offshore = offshore_to_offshore;
+    entry.first->second.m_onshore = onshore;
   }
   //----------------------------------------------------------------------------------------------------
   bool wallet2::should_skip_block(const cryptonote::block &b, uint64_t height) const
@@ -2562,7 +3391,8 @@ void wallet2::process_new_blockchain_entry(const cryptonote::block& b, const cry
       TIME_MEASURE_FINISH(txs_handle_time);
       m_last_block_reward = cryptonote::get_outs_money_amount(b.miner_tx);
       LOG_PRINT_L2("Processed block: " << bl_id << ", height " << height << ", " << miner_tx_handle_time + txs_handle_time << "(" << miner_tx_handle_time << "/" << txs_handle_time << ")ms");
-  }else
+    }
+    else
     {
       if (!(height % 128))
         LOG_PRINT_L2("Skipped block by timestamp, height: " << height << ", block time " << b.timestamp << ", account time " << m_account.get_createtime());
@@ -2594,7 +3424,8 @@ void wallet2::get_short_chain_history(std::list<crypto::hash>& ids, uint64_t gra
       if (i < 10)
       {
         ++current_back_offset;
-    }else
+      }
+      else
       {
         current_back_offset += current_multiplier *= 2;
       }
@@ -2721,14 +3552,16 @@ void wallet2::process_parsed_blocks(uint64_t start_height, const std::vector<cry
     {
       if (tx_cache_data[i].empty())
         continue;
-    tpool.submit(&waiter, [&hwdev, &gender, &tx_cache_data, i]() {
+      tpool.submit(
+          &waiter, [&hwdev, &gender, &tx_cache_data, i]() {
             auto &slot = tx_cache_data[i];
             boost::unique_lock<hw::device> hwdev_lock(hwdev);
             for (auto &iod : slot.primary)
               gender(iod);
             for (auto &iod : slot.additional)
               gender(iod);
-    }, true);
+          },
+          true);
     }
     waiter.wait(&tpool);
 
@@ -2736,13 +3569,15 @@ void wallet2::process_parsed_blocks(uint64_t start_height, const std::vector<cry
       for (size_t k = 0; k < n_vouts; ++k)
       {
         const auto &o = tx.vout[k];
-      if (o.target.type() == typeid(cryptonote::txout_to_key))
+        if ((o.target.type() == typeid(cryptonote::txout_to_key)) || (o.target.type() == typeid(cryptonote::txout_offshore)))
         {
           std::vector<crypto::key_derivation> additional_derivations;
           additional_derivations.reserve(tx_cache_data[txidx].additional.size());
           for (const auto &iod : tx_cache_data[txidx].additional)
             additional_derivations.push_back(iod.derivation);
-        const auto &key = boost::get<txout_to_key>(o.target).key;
+          const auto &key = (o.target.type() == typeid(cryptonote::txout_to_key))
+                                ? boost::get<txout_to_key>(o.target).key
+                                : boost::get<txout_offshore>(o.target).key;
           for (size_t l = 0; l < tx_cache_data[txidx].primary.size(); ++l)
           {
             THROW_WALLET_EXCEPTION_IF(tx_cache_data[txidx].primary[l].received.size() != n_vouts,
@@ -2767,13 +3602,15 @@ void wallet2::process_parsed_blocks(uint64_t start_height, const std::vector<cry
       {
         THROW_WALLET_EXCEPTION_IF(txidx >= tx_cache_data.size(), error::wallet_internal_error, "txidx out of range");
         const size_t n_vouts = m_refresh_type == RefreshType::RefreshOptimizeCoinbase ? 1 : parsed_blocks[i].block.miner_tx.vout.size();
-      tpool.submit(&waiter, [&, i, n_vouts, txidx](){ geniod(parsed_blocks[i].block.miner_tx, n_vouts, txidx); }, true);
+        tpool.submit(
+            &waiter, [&, i, n_vouts, txidx]() { geniod(parsed_blocks[i].block.miner_tx, n_vouts, txidx); }, true);
       }
       ++txidx;
       for (size_t j = 0; j < parsed_blocks[i].txes.size(); ++j)
       {
         THROW_WALLET_EXCEPTION_IF(txidx >= tx_cache_data.size(), error::wallet_internal_error, "txidx out of range");
-      tpool.submit(&waiter, [&, i, j, txidx](){ geniod(parsed_blocks[i].txes[j], parsed_blocks[i].txes[j].vout.size(), txidx); }, true);
+        tpool.submit(
+            &waiter, [&, i, j, txidx]() { geniod(parsed_blocks[i].txes[j], parsed_blocks[i].txes[j].vout.size(), txidx); }, true);
         ++txidx;
       }
     }
@@ -2800,7 +3637,11 @@ void wallet2::process_parsed_blocks(uint64_t start_height, const std::vector<cry
                                       " (height " + std::to_string(start_height) + "), local block id at this height: " +
                                       string_tools::pod_to_hex(m_blockchain[current_index]));
 
-      detach_blockchain(current_index, output_tracker_cache);
+        detach_blockchain(current_index, false, output_tracker_cache);
+        // HERE BE DRAGONS!!!
+        // Call detach_blockchain a second time to ensure offshore TXs are cleaned up as well
+        detach_blockchain(current_index, true, output_tracker_cache);
+        // LAND AHOY!!!
         process_new_blockchain_entry(bl, blocks[i], parsed_blocks[i], bl_id, current_index, tx_cache_data, tx_cache_data_offset, output_tracker_cache);
       }
       else
@@ -2854,8 +3695,7 @@ void wallet2::pull_and_parse_next_blocks(uint64_t start_height, uint64_t &blocks
       parsed_blocks.resize(blocks.size());
       for (size_t i = 0; i < blocks.size(); ++i)
       {
-      tpool.submit(&waiter, boost::bind(&wallet2::parse_block_round, this, std::cref(blocks[i].block),
-        std::ref(parsed_blocks[i].block), std::ref(parsed_blocks[i].hash), std::ref(parsed_blocks[i].error)), true);
+        tpool.submit(&waiter, boost::bind(&wallet2::parse_block_round, this, std::cref(blocks[i].block), std::ref(parsed_blocks[i].block), std::ref(parsed_blocks[i].hash), std::ref(parsed_blocks[i].error)), true);
       }
       waiter.wait(&tpool);
       for (size_t i = 0; i < blocks.size(); ++i)
@@ -2874,13 +3714,15 @@ void wallet2::pull_and_parse_next_blocks(uint64_t start_height, uint64_t &blocks
         parsed_blocks[i].txes.resize(blocks[i].txs.size());
         for (size_t j = 0; j < blocks[i].txs.size(); ++j)
         {
-        tpool.submit(&waiter, [&, i, j](){
+          tpool.submit(
+              &waiter, [&, i, j]() {
                 if (!parse_and_validate_tx_base_from_blob(blocks[i].txs[j].blob, parsed_blocks[i].txes[j]))
                 {
                   boost::unique_lock<boost::mutex> lock(error_lock);
                   error = true;
                 }
-        }, true);
+              },
+              true);
         }
       }
       waiter.wait(&tpool);
@@ -3188,11 +4030,13 @@ void wallet2::fast_refresh(uint64_t stop_height, uint64_t &blocks_start_height,
         return;
       }
       current_index = blocks_start_height;
-    if (hashes.size() + current_index < stop_height) {
+      if (hashes.size() + current_index < stop_height)
+      {
         drop_from_short_history(short_chain_history, 3);
         std::vector<crypto::hash>::iterator right = hashes.end();
         // prepend 3 more
-      for (int i = 0; i<3; i++) {
+        for (int i = 0; i < 3; i++)
+        {
           right--;
           short_chain_history.push_front(*right);
         }
@@ -3223,7 +4067,6 @@ void wallet2::fast_refresh(uint64_t stop_height, uint64_t &blocks_start_height,
     }
   }
 
-
   bool wallet2::add_address_book_row(const cryptonote::account_public_address &address, const crypto::hash8 *payment_id, const std::string &description, bool is_subaddress)
   {
     wallet2::address_book_row a;
@@ -3256,7 +4099,8 @@ bool wallet2::set_address_book_row(size_t row_id, const cryptonote::account_publ
     return true;
   }
 
-bool wallet2::delete_address_book_row(std::size_t row_id) {
+  bool wallet2::delete_address_book_row(std::size_t row_id)
+  {
     if (m_address_book.size() <= row_id)
       return false;
 
@@ -3286,14 +4130,16 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t & blo
       return;
     }
 
-  if(m_light_wallet) {
+    if (m_light_wallet)
+    {
 
       // MyMonero get_address_info needs to be called occasionally to trigger wallet sync.
       // This call is not really needed for other purposes and can be removed if mymonero changes their backend.
       tools::COMMAND_RPC_GET_ADDRESS_INFO::response res;
 
       // Get basic info
-    if(light_wallet_get_address_info(res)) {
+      if (light_wallet_get_address_info(res))
+      {
         // Last stored block height
         uint64_t prev_height = m_light_wallet_blockchain_height;
         // Update lw heights
@@ -3312,7 +4158,8 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t & blo
         // TODO: add wallet created block info
 
         light_wallet_get_address_txs();
-    } else
+      }
+      else
         m_light_wallet_connected = false;
 
       // Lighwallet refresh done
@@ -3336,7 +4183,8 @@ void wallet2::refresh(bool trusted_daemon, uint64_t start_height, uint64_t & blo
     // pull the first set of blocks
     get_short_chain_history(short_chain_history, (m_first_refresh_done || trusted_daemon) ? 1 : FIRST_REFRESH_GRANULARITY);
     m_run.store(true, std::memory_order_relaxed);
-  if (start_height > m_blockchain.size() || m_refresh_from_block_height > m_blockchain.size()) {
+    if (start_height > m_blockchain.size() || m_refresh_from_block_height > m_blockchain.size())
+    {
       if (!start_height)
         start_height = m_refresh_from_block_height;
       // we can shortcut by only pulling hashes up to the start_height
@@ -3562,7 +4410,7 @@ bool wallet2::get_rct_distribution(uint64_t &start_height, std::vector<uint64_t>
     cryptonote::COMMAND_RPC_GET_OUTPUT_DISTRIBUTION::response res = AUTO_VAL_INIT(res);
     req.amounts.push_back(0);
     req.from_height = 0;
-  req.cumulative = false;
+    req.cumulative = true;
     req.binary = true;
     req.compress = true;
 
@@ -3590,14 +4438,12 @@ bool wallet2::get_rct_distribution(uint64_t &start_height, std::vector<uint64_t>
       MWARNING("Failed to request output distribution: results are not for amount 0");
       return false;
     }
-  for (size_t i = 1; i < res.distributions[0].data.distribution.size(); ++i)
-    res.distributions[0].data.distribution[i] += res.distributions[0].data.distribution[i-1];
     start_height = res.distributions[0].data.start_height;
     distribution = std::move(res.distributions[0].data.distribution);
     return true;
   }
   //----------------------------------------------------------------------------------------------------
-void wallet2::detach_blockchain(uint64_t height, std::map<std::pair<uint64_t, uint64_t>, size_t> *output_tracker_cache)
+  void wallet2::detach_blockchain(uint64_t height, bool use_offshore_outputs, std::map<std::pair<uint64_t, uint64_t>, size_t> *output_tracker_cache)
   {
     LOG_PRINT_L0("Detaching blockchain on height " << height);
 
@@ -3607,11 +4453,13 @@ void wallet2::detach_blockchain(uint64_t height, std::map<std::pair<uint64_t, ui
     THROW_WALLET_EXCEPTION_IF(height < m_blockchain.offset() && m_blockchain.size() > m_blockchain.offset(),
                               error::wallet_internal_error, "Daemon claims reorg below last checkpoint");
 
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
+
     size_t transfers_detached = 0;
 
-  for (size_t i = 0; i < m_transfers.size(); ++i)
+    for (size_t i = 0; i < specific_transfers.size(); ++i)
     {
-    wallet2::transfer_details &td = m_transfers[i];
+      wallet2::transfer_details &td = specific_transfers[i];
       if (td.m_spent && td.m_spent_height >= height)
       {
         LOG_PRINT_L1("Resetting spent/frozen status for output " << i << ": " << td.m_key_image);
@@ -3620,7 +4468,7 @@ void wallet2::detach_blockchain(uint64_t height, std::map<std::pair<uint64_t, ui
       }
     }
 
-  for (transfer_details &td: m_transfers)
+    for (transfer_details &td : specific_transfers)
     {
       while (!td.m_uses.empty() && td.m_uses.back().first >= height)
         td.m_uses.pop_back();
@@ -3629,26 +4477,26 @@ void wallet2::detach_blockchain(uint64_t height, std::map<std::pair<uint64_t, ui
     if (output_tracker_cache)
       output_tracker_cache->clear();
 
-  auto it = std::find_if(m_transfers.begin(), m_transfers.end(), [&](const transfer_details& td){return td.m_block_height >= height;});
-  size_t i_start = it - m_transfers.begin();
+    auto it = std::find_if(specific_transfers.begin(), specific_transfers.end(), [&](const transfer_details &td) { return td.m_block_height >= height; });
+    size_t i_start = it - specific_transfers.begin();
 
-  for(size_t i = i_start; i!= m_transfers.size();i++)
+    for (size_t i = i_start; i != specific_transfers.size(); i++)
     {
-    if (!m_transfers[i].m_key_image_known || m_transfers[i].m_key_image_partial)
+      if (!specific_transfers[i].m_key_image_known || specific_transfers[i].m_key_image_partial)
         continue;
-    auto it_ki = m_key_images.find(m_transfers[i].m_key_image);
-    THROW_WALLET_EXCEPTION_IF(it_ki == m_key_images.end(), error::wallet_internal_error, "key image not found: index " + std::to_string(i) + ", ki " + epee::string_tools::pod_to_hex(m_transfers[i].m_key_image) + ", " + std::to_string(m_key_images.size()) + " key images known");
+      auto it_ki = m_key_images.find(specific_transfers[i].m_key_image);
+      THROW_WALLET_EXCEPTION_IF(it_ki == m_key_images.end(), error::wallet_internal_error, "key image not found: index " + std::to_string(i) + ", ki " + epee::string_tools::pod_to_hex(specific_transfers[i].m_key_image) + ", " + std::to_string(m_key_images.size()) + " key images known");
       m_key_images.erase(it_ki);
     }
 
-  for(size_t i = i_start; i!= m_transfers.size();i++)
+    for (size_t i = i_start; i != specific_transfers.size(); i++)
     {
-    auto it_pk = m_pub_keys.find(m_transfers[i].get_public_key());
+      auto it_pk = m_pub_keys.find(specific_transfers[i].get_public_key());
       THROW_WALLET_EXCEPTION_IF(it_pk == m_pub_keys.end(), error::wallet_internal_error, "public key not found");
       m_pub_keys.erase(it_pk);
     }
     transfers_detached = std::distance(it, m_transfers.end());
-  m_transfers.erase(it, m_transfers.end());
+    specific_transfers.erase(it, specific_transfers.end());
 
     size_t blocks_detached = m_blockchain.size() - height;
     m_blockchain.crop(height);
@@ -3661,6 +4509,18 @@ void wallet2::detach_blockchain(uint64_t height, std::map<std::pair<uint64_t, ui
         ++it;
     }
 
+    if (use_offshore_outputs)
+    {
+      for (auto it = m_confirmed_offshore_txs.begin(); it != m_confirmed_offshore_txs.end();)
+      {
+        if (height <= it->second.m_block_height)
+          it = m_confirmed_offshore_txs.erase(it);
+        else
+          ++it;
+      }
+    }
+    else
+    {
       for (auto it = m_confirmed_txs.begin(); it != m_confirmed_txs.end();)
       {
         if (height <= it->second.m_block_height)
@@ -3668,6 +4528,7 @@ void wallet2::detach_blockchain(uint64_t height, std::map<std::pair<uint64_t, ui
         else
           ++it;
       }
+    }
 
     LOG_PRINT_L0("Detached blockchain on height " << height << ", transfers detached " << transfers_detached << ", blocks detached " << blocks_detached);
   }
@@ -3684,6 +4545,7 @@ bool wallet2::clear()
   {
     m_blockchain.clear();
     m_transfers.clear();
+    m_offshore_transfers.clear();
     m_key_images.clear();
     m_pub_keys.clear();
     m_unconfirmed_txs.clear();
@@ -3691,6 +4553,7 @@ bool wallet2::clear()
     m_tx_keys.clear();
     m_additional_tx_keys.clear();
     m_confirmed_txs.clear();
+    m_confirmed_offshore_txs.clear();
     m_unconfirmed_payments.clear();
     m_scanned_pool_txs[0].clear();
     m_scanned_pool_txs[1].clear();
@@ -3706,12 +4569,14 @@ void wallet2::clear_soft(bool keep_key_images)
   {
     m_blockchain.clear();
     m_transfers.clear();
+    m_offshore_transfers.clear();
     if (!keep_key_images)
       m_key_images.clear();
     m_pub_keys.clear();
     m_unconfirmed_txs.clear();
     m_payments.clear();
     m_confirmed_txs.clear();
+    m_confirmed_offshore_txs.clear();
     m_unconfirmed_payments.clear();
     m_scanned_pool_txs[0].clear();
     m_scanned_pool_txs[1].clear();
@@ -3744,7 +4609,8 @@ bool wallet2::store_keys(const std::string& keys_file_name, const epee::wipeable
     std::error_code e = tools::replace_file(tmp_file_name, keys_file_name);
     lock_keys_file();
 
-  if (e) {
+    if (e)
+    {
       boost::filesystem::remove(tmp_file_name);
       LOG_ERROR("failed to update wallet keys file " << keys_file_name);
       return false;
@@ -4024,12 +4890,14 @@ bool wallet2::load_keys(const std::string& keys_file_name, const epee::wipeable_
     return r;
   }
   //----------------------------------------------------------------------------------------------------
-bool wallet2::load_keys_buf(const std::string& keys_buf, const epee::wipeable_string& password) {
+  bool wallet2::load_keys_buf(const std::string &keys_buf, const epee::wipeable_string &password)
+  {
     boost::optional<crypto::chacha_key> keys_to_encrypt;
     return wallet2::load_keys_buf(keys_buf, password, keys_to_encrypt);
   }
   //----------------------------------------------------------------------------------------------------
-bool wallet2::load_keys_buf(const std::string& keys_buf, const epee::wipeable_string& password, boost::optional<crypto::chacha_key>& keys_to_encrypt) {
+  bool wallet2::load_keys_buf(const std::string &keys_buf, const epee::wipeable_string &password, boost::optional<crypto::chacha_key> &keys_to_encrypt)
+  {
 
     // Decrypt the contents
     rapidjson::Document json;
@@ -4233,9 +5101,7 @@ bool wallet2::load_keys_buf(const std::string& keys_buf, const epee::wipeable_st
       GET_FIELD_FROM_JSON_RETURN_ON_ERROR(json, nettype, uint8_t, Uint, false, static_cast<uint8_t>(m_nettype));
       // The network type given in the program argument is inconsistent with the network type saved in the wallet
       THROW_WALLET_EXCEPTION_IF(static_cast<uint8_t>(m_nettype) != field_nettype, error::wallet_internal_error,
-    (boost::format("%s wallet cannot be opened as %s wallet")
-    % (field_nettype == 0 ? "Mainnet" : field_nettype == 1 ? "Testnet" : "Stagenet")
-    % (m_nettype == MAINNET ? "mainnet" : m_nettype == TESTNET ? "testnet" : "stagenet")).str());
+                                (boost::format("%s wallet cannot be opened as %s wallet") % (field_nettype == 0 ? "Mainnet" : field_nettype == 1 ? "Testnet" : "Stagenet") % (m_nettype == MAINNET ? "mainnet" : m_nettype == TESTNET ? "testnet" : "stagenet")).str());
       GET_FIELD_FROM_JSON_RETURN_ON_ERROR(json, segregate_pre_fork_outputs, int, Int, false, true);
       m_segregate_pre_fork_outputs = field_segregate_pre_fork_outputs;
       GET_FIELD_FROM_JSON_RETURN_ON_ERROR(json, key_reuse_mitigation2, int, Int, false, true);
@@ -4326,7 +5192,8 @@ bool wallet2::load_keys_buf(const std::string& keys_buf, const epee::wipeable_st
 
     r = epee::serialization::load_t_from_binary(m_account, account_data);
     THROW_WALLET_EXCEPTION_IF(!r, error::invalid_password);
-  if (m_key_device_type == hw::device::device_type::LEDGER || m_key_device_type == hw::device::device_type::TREZOR) {
+    if (m_key_device_type == hw::device::device_type::LEDGER || m_key_device_type == hw::device::device_type::TREZOR)
+    {
       LOG_PRINT_L0("Account on device. Initing device...");
       hw::device &hwdev = lookup_device(m_device_name);
       THROW_WALLET_EXCEPTION_IF(!hwdev.set_name(m_device_name), error::wallet_internal_error, "Could not set device name " + m_device_name);
@@ -4340,10 +5207,12 @@ bool wallet2::load_keys_buf(const std::string& keys_buf, const epee::wipeable_st
       account_public_address device_account_public_address;
       THROW_WALLET_EXCEPTION_IF(!hwdev.get_public_address(device_account_public_address), error::wallet_internal_error, "Cannot get a device address");
       THROW_WALLET_EXCEPTION_IF(device_account_public_address != m_account.get_keys().m_account_address, error::wallet_internal_error, "Device wallet does not match wallet address. "
-                                                                                                                                     "Device address: " + cryptonote::get_account_address_as_str(m_nettype, false, device_account_public_address) +
-                                                                                                                                     ", wallet address: " + m_account.get_public_address_str(m_nettype));
+                                                                                                                                       "Device address: " +
+                                                                                                                                           cryptonote::get_account_address_as_str(m_nettype, false, device_account_public_address) + ", wallet address: " + m_account.get_public_address_str(m_nettype));
       LOG_PRINT_L0("Device inited...");
-  } else if (key_on_device()) {
+    }
+    else if (key_on_device())
+    {
       THROW_WALLET_EXCEPTION(error::wallet_internal_error, "hardware device not supported");
     }
 
@@ -4501,12 +5370,12 @@ void wallet2::create_keys_file(const std::string &wallet_, bool watch_only, cons
       if (create_address_file)
       {
         r = save_to_file(m_wallet_file + ".address.txt", m_account.get_public_address_str(m_nettype), true);
-      if(!r) MERROR("String with address text not saved");
+        if (!r)
+          MERROR("String with address text not saved");
       }
     }
   }
 
-
   /*!
  * \brief determine the key storage for the specified wallet file
  * \param device_type     (OUT) wallet backend as enumerated in hw::device::device_type
@@ -4557,7 +5426,8 @@ bool wallet2::query_device(hw::device::device_type& device_type, const std::stri
     cryptonote::account_base account_data_check;
 
     r = epee::serialization::load_t_from_binary(account_data_check, account_data);
-  if (!r) return false;
+    if (!r)
+      return false;
     return true;
   }
 
@@ -4686,7 +5556,8 @@ crypto::secret_key wallet2::generate(const std::string& wallet_, const epee::wip
     setup_keys(password);
 
     // calculate a starting refresh height
-  if(m_refresh_from_block_height == 0 && !recover){
+    if (m_refresh_from_block_height == 0 && !recover)
+    {
       m_refresh_from_block_height = estimate_blockchain_height();
     }
 
@@ -4726,10 +5597,13 @@ crypto::secret_key wallet2::generate(const std::string& wallet_, const epee::wip
     // a safety margin.
     height = get_approximate_blockchain_height();
     uint64_t target_height = get_daemon_blockchain_target_height(err);
-   if (err.empty()) {
+    if (err.empty())
+    {
       if (target_height < height)
         height = target_height;
-   } else {
+    }
+    else
+    {
       // if we couldn't talk to the daemon, check safety margin.
       if (height > blocks_per_month)
         height -= blocks_per_month;
@@ -4826,7 +5700,8 @@ void wallet2::restore(const std::string& wallet_, const epee::wipeable_string& p
     prepare_file_names(wallet_);
 
     boost::system::error_code ignored_ec;
-  if (!wallet_.empty()) {
+    if (!wallet_.empty())
+    {
       THROW_WALLET_EXCEPTION_IF(boost::filesystem::exists(m_wallet_file, ignored_ec), error::file_exists, m_wallet_file);
       THROW_WALLET_EXCEPTION_IF(boost::filesystem::exists(m_keys_file, ignored_ec), error::file_exists, m_keys_file);
     }
@@ -4850,7 +5725,8 @@ void wallet2::restore(const std::string& wallet_, const epee::wipeable_string& p
       m_subaddress_lookahead_minor = 20;
     }
     setup_new_blockchain();
-  if (!wallet_.empty()) {
+    if (!wallet_.empty())
+    {
       store();
     }
   }
@@ -5074,7 +5950,8 @@ std::string wallet2::exchange_multisig_keys(const epee::wipeable_string &passwor
         if (boost::filesystem::exists(m_wallet_file + ".address.txt"))
         {
           r = save_to_file(m_wallet_file + ".address.txt", m_account.get_public_address_str(m_nettype), true);
-        if(!r) MERROR("String with address text not saved");
+          if (!r)
+            MERROR("String with address text not saved");
         }
       }
 
@@ -5368,6 +6245,9 @@ bool wallet2::has_multisig_partial_key_images() const
     for (const auto &td : m_transfers)
       if (td.m_key_image_partial)
         return true;
+    for (const auto &td : m_offshore_transfers)
+      if (td.m_key_image_partial)
+        return true;
     return false;
   }
 
@@ -5376,6 +6256,9 @@ bool wallet2::has_unknown_key_images() const
     for (const auto &td : m_transfers)
       if (!td.m_key_image_known)
         return true;
+    for (const auto &td : m_offshore_transfers)
+      if (!td.m_key_image_known)
+        return true;
     return false;
   }
 
@@ -5487,7 +6370,8 @@ bool wallet2::check_connection(uint32_t *version, bool *ssl, uint32_t timeout)
     }
 
     // TODO: Add light wallet version check.
-  if(m_light_wallet) {
+    if (m_light_wallet)
+    {
       m_rpc_version = 0;
       if (version)
         *version = 0;
@@ -5514,7 +6398,8 @@ bool wallet2::check_connection(uint32_t *version, bool *ssl, uint32_t timeout)
       cryptonote::COMMAND_RPC_GET_VERSION::request req_t = AUTO_VAL_INIT(req_t);
       cryptonote::COMMAND_RPC_GET_VERSION::response resp_t = AUTO_VAL_INIT(resp_t);
       bool r = invoke_http_json_rpc("/json_rpc", "get_version", req_t, resp_t);
-    if(!r || resp_t.status != CORE_RPC_STATUS_OK) {
+      if (!r || resp_t.status != CORE_RPC_STATUS_OK)
+      {
         if (version)
           *version = 0;
         return false;
@@ -5558,7 +6443,7 @@ void wallet2::load(const std::string& wallet_, const epee::wipeable_string& pass
 
     // determine if loading from file system or string buffer
     bool use_fs = !wallet_.empty();
-  THROW_WALLET_EXCEPTION_IF((use_fs && !keys_buf.empty()) || (!use_fs && keys_buf.empty()), error::file_read_error, "must load keys either from file system or from buffer");\
+    THROW_WALLET_EXCEPTION_IF((use_fs && !keys_buf.empty()) || (!use_fs && keys_buf.empty()), error::file_read_error, "must load keys either from file system or from buffer");
 
     boost::system::error_code e;
     if (use_fs)
@@ -5586,7 +6471,7 @@ void wallet2::load(const std::string& wallet_, const epee::wipeable_string& pass
 
     //keys loaded ok!
     //try to load wallet file. but even if we failed, it is not big problem
-  if (use_fs && (!boost::filesystem::exists(m_wallet_file, e) || e))
+    if ((use_fs && (!boost::filesystem::exists(m_wallet_file, e) || e)) || (!use_fs && cache_buf.empty()))
     {
       LOG_PRINT_L0("file not found: " << m_wallet_file << ", starting with empty blockchain");
       m_account_public_address = m_account.get_keys().m_account_address;
@@ -5613,7 +6498,8 @@ void wallet2::load(const std::string& wallet_, const epee::wipeable_string& pass
         cache_data.resize(cache_file_data.cache_data.size());
         crypto::chacha20(cache_file_data.cache_data.data(), cache_file_data.cache_data.size(), m_cache_key, cache_file_data.iv, &cache_data[0]);
 
-      try {
+        try
+        {
           std::stringstream iss;
           iss << cache_data;
           boost::archive::portable_binary_iarchive ar(iss);
@@ -5625,7 +6511,8 @@ void wallet2::load(const std::string& wallet_, const epee::wipeable_string& pass
           crypto::chacha_key key;
           generate_chacha_key_from_secret_keys(key);
           crypto::chacha20(cache_file_data.cache_data.data(), cache_file_data.cache_data.size(), key, cache_file_data.iv, &cache_data[0]);
-        try {
+          try
+          {
             std::stringstream iss;
             iss << cache_data;
             boost::archive::portable_binary_iarchive ar(iss);
@@ -5644,7 +6531,8 @@ void wallet2::load(const std::string& wallet_, const epee::wipeable_string& pass
             catch (...)
             {
               LOG_PRINT_L0("Failed to open portable binary, trying unportable");
-            if (use_fs) boost::filesystem::copy_file(m_wallet_file, m_wallet_file + ".unportable", boost::filesystem::copy_option::overwrite_if_exists);
+              if (use_fs)
+                boost::filesystem::copy_file(m_wallet_file, m_wallet_file + ".unportable", boost::filesystem::copy_option::overwrite_if_exists);
               std::stringstream iss;
               iss.str("");
               iss << cache_data;
@@ -5657,7 +6545,8 @@ void wallet2::load(const std::string& wallet_, const epee::wipeable_string& pass
       catch (...)
       {
         LOG_PRINT_L1("Failed to load encrypted cache, trying unencrypted");
-      try {
+        try
+        {
           std::stringstream iss;
           iss << cache_file_buf;
           boost::archive::portable_binary_iarchive ar(iss);
@@ -5666,7 +6555,8 @@ void wallet2::load(const std::string& wallet_, const epee::wipeable_string& pass
         catch (...)
         {
           LOG_PRINT_L0("Failed to open portable binary, trying unportable");
-        if (use_fs) boost::filesystem::copy_file(m_wallet_file, m_wallet_file + ".unportable", boost::filesystem::copy_option::overwrite_if_exists);
+          if (use_fs)
+            boost::filesystem::copy_file(m_wallet_file, m_wallet_file + ".unportable", boost::filesystem::copy_option::overwrite_if_exists);
           std::stringstream iss;
           iss.str("");
           iss << cache_file_buf;
@@ -5730,6 +6620,10 @@ void wallet2::trim_hashchain()
       if (td.m_block_height < height)
         height = td.m_block_height;
 
+    for (const transfer_details &td : m_offshore_transfers)
+      if (td.m_block_height < height)
+        height = td.m_block_height;
+
     if (!m_blockchain.empty() && m_blockchain.size() == m_blockchain.offset())
     {
       MINFO("Fixing empty hashchain");
@@ -5766,7 +6660,8 @@ void wallet2::trim_hashchain()
     }
   }
   //----------------------------------------------------------------------------------------------------
-void wallet2::check_genesis(const crypto::hash& genesis_hash) const {
+  void wallet2::check_genesis(const crypto::hash &genesis_hash) const
+  {
     std::string what("Genesis block mismatch. You probably use wallet without testnet (or stagenet) flag with blockchain from test (or stage) network or vice versa");
 
     THROW_WALLET_EXCEPTION_IF(genesis_hash != m_blockchain.genesis(), error::wallet_internal_error, what);
@@ -5801,7 +6696,6 @@ void wallet2::store_to(const std::string &path, const epee::wipeable_string &pas
       same_file = pos != std::string::npos;
     }
 
-
     if (!same_file)
     {
       // check if we want to store to directory which doesn't exists yet
@@ -5830,7 +6724,8 @@ void wallet2::store_to(const std::string &path, const epee::wipeable_string &pas
 
     // save keys to the new file
     // if we here, main wallet file is saved and we only need to save keys and address files
-  if (!same_file) {
+    if (!same_file)
+    {
       prepare_file_names(path);
       bool r = store_keys(m_keys_file, password, false);
       THROW_WALLET_EXCEPTION_IF(!r, error::file_save_error, m_keys_file);
@@ -5842,29 +6737,35 @@ void wallet2::store_to(const std::string &path, const epee::wipeable_string &pas
         THROW_WALLET_EXCEPTION_IF(!r, error::file_save_error, m_wallet_file);
         // remove old address file
         r = boost::filesystem::remove(old_address_file);
-      if (!r) {
+        if (!r)
+        {
           LOG_ERROR("error removing file: " << old_address_file);
         }
       }
       // remove old wallet file
       r = boost::filesystem::remove(old_file);
-    if (!r) {
+      if (!r)
+      {
         LOG_ERROR("error removing file: " << old_file);
       }
       // remove old keys file
       r = boost::filesystem::remove(old_keys_file);
-    if (!r) {
+      if (!r)
+      {
         LOG_ERROR("error removing file: " << old_keys_file);
       }
       // remove old message store file
       if (boost::filesystem::exists(old_mms_file))
       {
         r = boost::filesystem::remove(old_mms_file);
-      if (!r) {
+        if (!r)
+        {
           LOG_ERROR("error removing file: " << old_mms_file);
         }
       }
-  } else {
+    }
+    else
+    {
       // save to new file
 #ifdef WIN32
       // On Windows avoid using std::ofstream which does not work with UTF-8 filenames
@@ -5872,7 +6773,8 @@ void wallet2::store_to(const std::string &path, const epee::wipeable_string &pas
       std::ostringstream oss;
       binary_archive<true> oar(oss);
       bool success = ::serialization::serialize(oar, cache_file_data.get());
-    if (success) {
+      if (success)
+      {
         success = save_to_file(new_file, oss.str());
       }
       THROW_WALLET_EXCEPTION_IF(!success, error::file_save_error, new_file);
@@ -5922,7 +6824,7 @@ boost::optional<wallet2::cache_file_data> wallet2::get_cache_file_data(const epe
     }
   }
   //----------------------------------------------------------------------------------------------------
-uint64_t wallet2::balance(uint32_t index_major, bool strict) const
+  uint64_t wallet2::balance(uint32_t index_major, bool strict)
   {
     uint64_t amount = 0;
     if (m_light_wallet)
@@ -5932,7 +6834,7 @@ uint64_t wallet2::balance(uint32_t index_major, bool strict) const
     return amount;
   }
   //----------------------------------------------------------------------------------------------------
-uint64_t wallet2::unlocked_balance(uint32_t index_major, bool strict, uint64_t *blocks_to_unlock, uint64_t *time_to_unlock) const
+  uint64_t wallet2::unlocked_balance(uint32_t index_major, bool strict, uint64_t *blocks_to_unlock, uint64_t *time_to_unlock)
   {
     uint64_t amount = 0;
     if (blocks_to_unlock)
@@ -5952,20 +6854,101 @@ uint64_t wallet2::unlocked_balance(uint32_t index_major, bool strict, uint64_t *
     return amount;
   }
   //----------------------------------------------------------------------------------------------------
-std::map<uint32_t, uint64_t> wallet2::balance_per_subaddress(uint32_t index_major, bool strict) const
+  uint64_t wallet2::offshore_balance(uint32_t index_major, bool strict)
+  {
+    uint64_t amount = 0;
+    // TODO OFFSHORE: Look at light wallet
+    if (m_light_wallet)
+      return m_light_wallet_unlocked_balance;
+    for (const auto &i : offshore_balance_per_subaddress(index_major, strict))
+      amount += i.second;
+    return amount;
+  }
+  //----------------------------------------------------------------------------------------------------
+  uint64_t wallet2::unlocked_offshore_balance(uint32_t index_major, bool strict, uint64_t *blocks_to_unlock, uint64_t *time_to_unlock)
+  {
+    uint64_t amount = 0;
+    // TODO OFFSHORE: Look at light wallet
+    if (blocks_to_unlock)
+      *blocks_to_unlock = 0;
+    if (time_to_unlock)
+      *time_to_unlock = 0;
+    if (m_light_wallet)
+      return m_light_wallet_balance;
+    for (const auto &i : unlocked_offshore_balance_per_subaddress(index_major, strict))
+    {
+      amount += i.second.first;
+      if (blocks_to_unlock && i.second.second.first > *blocks_to_unlock)
+        *blocks_to_unlock = i.second.second.first;
+      if (time_to_unlock && i.second.second.second > *time_to_unlock)
+        *time_to_unlock = i.second.second.second;
+    }
+    return amount;
+  }
+  //----------------------------------------------------------------------------------------------------
+  std::map<uint32_t, uint64_t> wallet2::balance_per_subaddress(uint32_t index_major, bool strict)
   {
     std::map<uint32_t, uint64_t> amount_per_subaddr;
     for (const auto &td : m_transfers)
     {
-    if (td.m_subaddr_index.major == index_major && !is_spent(td, strict) && !td.m_frozen)
+      if (td.m_subaddr_index.major == index_major && !td.m_spent && !td.m_frozen)
+      {
+        auto found = amount_per_subaddr.find(td.m_subaddr_index.minor);
+        if (found == amount_per_subaddr.end())
+          amount_per_subaddr[td.m_subaddr_index.minor] = td.amount();
+        else
+          found->second += td.amount();
+      }
+    }
+    if (!strict)
+    {
+      for (const auto &utx : m_unconfirmed_txs)
+      {
+        if (utx.second.m_subaddr_account == index_major && utx.second.m_state != wallet2::unconfirmed_transfer_details::failed)
+        {
+          // all changes go to 0-th subaddress (in the current subaddress account)
+          auto found = amount_per_subaddr.find(0);
+          if (found == amount_per_subaddr.end())
+          {
+            if (utx.second.m_offshore || (!utx.second.m_onshore && !utx.second.m_offshore_to_offshore))
+            {
+              // Offshore or regular TX - change is XHV
+              amount_per_subaddr[0] = utx.second.m_change;
+            }
+          }
+          else
+          {
+            if (utx.second.m_offshore || (!utx.second.m_onshore && !utx.second.m_offshore_to_offshore))
+            {
+              // Regular TX or Offshore TX - send back change from TX
+              found->second += utx.second.m_change;
+            }
+          }
+        }
+      }
+    }
+    return amount_per_subaddr;
+  }
+  //----------------------------------------------------------------------------------------------------
+  std::map<uint32_t, uint64_t> wallet2::offshore_balance_per_subaddress(uint32_t index_major, bool strict)
+  {
+    std::map<uint32_t, uint64_t> amount_per_subaddr;
+
+    for (const auto &td : m_offshore_transfers)
+    {
+      if (td.m_subaddr_index.major == index_major && !td.m_spent && !td.m_frozen)
       {
         auto found = amount_per_subaddr.find(td.m_subaddr_index.minor);
         if (found == amount_per_subaddr.end())
+        {
           amount_per_subaddr[td.m_subaddr_index.minor] = td.amount();
+        }
         else
+        {
           found->second += td.amount();
         }
       }
+    }
     if (!strict)
     {
       for (const auto &utx : m_unconfirmed_txs)
@@ -5975,16 +6958,28 @@ std::map<uint32_t, uint64_t> wallet2::balance_per_subaddress(uint32_t index_majo
           // all changes go to 0-th subaddress (in the current subaddress account)
           auto found = amount_per_subaddr.find(0);
           if (found == amount_per_subaddr.end())
+          {
+            if (utx.second.m_onshore || utx.second.m_offshore_to_offshore)
+            {
+              // Offshore or regular TX - change is XHV
               amount_per_subaddr[0] = utx.second.m_change;
+            }
+          }
           else
+          {
+            if (utx.second.m_onshore || utx.second.m_offshore_to_offshore)
+            {
+              // Offshore or regular TX - change is XHV
               found->second += utx.second.m_change;
             }
           }
         }
+      }
+    }
     return amount_per_subaddr;
   }
   //----------------------------------------------------------------------------------------------------
-std::map<uint32_t, std::pair<uint64_t, std::pair<uint64_t, uint64_t>>> wallet2::unlocked_balance_per_subaddress(uint32_t index_major, bool strict) const
+  std::map<uint32_t, std::pair<uint64_t, std::pair<uint64_t, uint64_t>>> wallet2::unlocked_balance_per_subaddress(uint32_t index_major, bool strict)
   {
     std::map<uint32_t, std::pair<uint64_t, std::pair<uint64_t, uint64_t>>> amount_per_subaddr;
     const uint64_t blockchain_height = get_blockchain_current_height();
@@ -6024,7 +7019,48 @@ std::map<uint32_t, std::pair<uint64_t, std::pair<uint64_t, uint64_t>>> wallet2::
     return amount_per_subaddr;
   }
   //----------------------------------------------------------------------------------------------------
-uint64_t wallet2::balance_all(bool strict) const
+  std::map<uint32_t, std::pair<uint64_t, std::pair<uint64_t, uint64_t>>> wallet2::unlocked_offshore_balance_per_subaddress(uint32_t index_major, bool strict)
+  {
+    std::map<uint32_t, std::pair<uint64_t, std::pair<uint64_t, uint64_t>>> amount_per_subaddr;
+    const uint64_t blockchain_height = get_blockchain_current_height();
+    const uint64_t now = time(NULL);
+    for (const transfer_details &td : m_offshore_transfers)
+    {
+      if (td.m_subaddr_index.major == index_major && !is_spent(td, strict) && !td.m_frozen)
+      {
+        uint64_t amount = 0, blocks_to_unlock = 0, time_to_unlock = 0;
+        if (is_transfer_unlocked(td))
+        {
+          //amount = (td.amount() / 1000000000000) * usd_rate;
+          amount = td.amount();
+          blocks_to_unlock = 0;
+          time_to_unlock = 0;
+        }
+        else
+        {
+          uint64_t unlock_height = td.m_block_height + std::max<uint64_t>(CRYPTONOTE_DEFAULT_TX_SPENDABLE_AGE, CRYPTONOTE_LOCKED_TX_ALLOWED_DELTA_BLOCKS);
+          if (td.m_tx.unlock_time < CRYPTONOTE_MAX_BLOCK_NUMBER && td.m_tx.unlock_time > unlock_height)
+            unlock_height = td.m_tx.unlock_time;
+          uint64_t unlock_time = td.m_tx.unlock_time >= CRYPTONOTE_MAX_BLOCK_NUMBER ? td.m_tx.unlock_time : 0;
+          time_to_unlock = unlock_time > now ? unlock_time - now : 0;
+          blocks_to_unlock = unlock_height > blockchain_height ? unlock_height - blockchain_height : 0;
+          amount = 0;
+        }
+        auto found = amount_per_subaddr.find(td.m_subaddr_index.minor);
+        if (found == amount_per_subaddr.end())
+          amount_per_subaddr[td.m_subaddr_index.minor] = std::make_pair(amount, std::make_pair(blocks_to_unlock, time_to_unlock));
+        else
+        {
+          found->second.first += amount;
+          found->second.second.first = std::max(found->second.second.first, blocks_to_unlock);
+          found->second.second.second = std::max(found->second.second.second, time_to_unlock);
+        }
+      }
+    }
+    return amount_per_subaddr;
+  }
+  //----------------------------------------------------------------------------------------------------
+  uint64_t wallet2::balance_all(bool strict)
   {
     uint64_t r = 0;
     for (uint32_t index_major = 0; index_major < get_num_subaddress_accounts(); ++index_major)
@@ -6032,7 +7068,7 @@ uint64_t wallet2::balance_all(bool strict) const
     return r;
   }
   //----------------------------------------------------------------------------------------------------
-uint64_t wallet2::unlocked_balance_all(bool strict, uint64_t *blocks_to_unlock, uint64_t *time_to_unlock) const
+  uint64_t wallet2::unlocked_balance_all(bool strict, uint64_t *blocks_to_unlock, uint64_t *time_to_unlock)
   {
     uint64_t r = 0;
     if (blocks_to_unlock)
@@ -6051,11 +7087,43 @@ uint64_t wallet2::unlocked_balance_all(bool strict, uint64_t *blocks_to_unlock,
     return r;
   }
   //----------------------------------------------------------------------------------------------------
+  uint64_t wallet2::offshore_balance_all(bool strict)
+  {
+    uint64_t r = 0;
+    for (uint32_t index_major = 0; index_major < get_num_subaddress_accounts(); ++index_major)
+      r += offshore_balance(index_major, strict);
+    return r;
+  }
+  //----------------------------------------------------------------------------------------------------
+  uint64_t wallet2::unlocked_offshore_balance_all(bool strict, uint64_t *blocks_to_unlock, uint64_t *time_to_unlock)
+  {
+    uint64_t r = 0;
+    if (blocks_to_unlock)
+      *blocks_to_unlock = 0;
+    if (time_to_unlock)
+      *time_to_unlock = 0;
+    for (uint32_t index_major = 0; index_major < get_num_subaddress_accounts(); ++index_major)
+    {
+      uint64_t local_blocks_to_unlock, local_time_to_unlock;
+      r += unlocked_offshore_balance(index_major, strict, blocks_to_unlock ? &local_blocks_to_unlock : NULL, time_to_unlock ? &local_time_to_unlock : NULL);
+      if (blocks_to_unlock)
+        *blocks_to_unlock = std::max(*blocks_to_unlock, local_blocks_to_unlock);
+      if (time_to_unlock)
+        *time_to_unlock = std::max(*time_to_unlock, local_time_to_unlock);
+    }
+    return r;
+  }
+  //----------------------------------------------------------------------------------------------------
   void wallet2::get_transfers(wallet2::transfer_container &incoming_transfers) const
   {
     incoming_transfers = m_transfers;
   }
   //----------------------------------------------------------------------------------------------------
+  void wallet2::get_offshore_transfers(wallet2::transfer_container &incoming_transfers) const
+  {
+    incoming_transfers = m_offshore_transfers;
+  }
+  //----------------------------------------------------------------------------------------------------
   void wallet2::get_payments(const crypto::hash &payment_id, std::list<wallet2::payment_details> &payments, uint64_t min_height, const boost::optional<uint32_t> &subaddr_account, const std::set<uint32_t> &subaddr_indices) const
   {
     auto range = m_payments.equal_range(payment_id);
@@ -6085,7 +7153,18 @@ void wallet2::get_payments(std::list<std::pair<crypto::hash,wallet2::payment_det
   void wallet2::get_payments_out(std::list<std::pair<crypto::hash, wallet2::confirmed_transfer_details>> &confirmed_payments,
                                  uint64_t min_height, uint64_t max_height, const boost::optional<uint32_t> &subaddr_account, const std::set<uint32_t> &subaddr_indices) const
   {
-  for (auto i = m_confirmed_txs.begin(); i != m_confirmed_txs.end(); ++i) {
+    for (auto i = m_confirmed_txs.begin(); i != m_confirmed_txs.end(); ++i)
+    {
+      if (i->second.m_block_height <= min_height || i->second.m_block_height > max_height)
+        continue;
+      if (subaddr_account && *subaddr_account != i->second.m_subaddr_account)
+        continue;
+      if (!subaddr_indices.empty() && std::count_if(i->second.m_subaddr_indices.begin(), i->second.m_subaddr_indices.end(), [&subaddr_indices](uint32_t index) { return subaddr_indices.count(index) == 1; }) == 0)
+        continue;
+      confirmed_payments.push_back(*i);
+    }
+    for (auto i = m_confirmed_offshore_txs.begin(); i != m_confirmed_offshore_txs.end(); ++i)
+    {
       if (i->second.m_block_height <= min_height || i->second.m_block_height > max_height)
         continue;
       if (subaddr_account && *subaddr_account != i->second.m_subaddr_account)
@@ -6098,7 +7177,8 @@ void wallet2::get_payments_out(std::list<std::pair<crypto::hash,wallet2::confirm
   //----------------------------------------------------------------------------------------------------
   void wallet2::get_unconfirmed_payments_out(std::list<std::pair<crypto::hash, wallet2::unconfirmed_transfer_details>> &unconfirmed_payments, const boost::optional<uint32_t> &subaddr_account, const std::set<uint32_t> &subaddr_indices) const
   {
-  for (auto i = m_unconfirmed_txs.begin(); i != m_unconfirmed_txs.end(); ++i) {
+    for (auto i = m_unconfirmed_txs.begin(); i != m_unconfirmed_txs.end(); ++i)
+    {
       if (subaddr_account && *subaddr_account != i->second.m_subaddr_account)
         continue;
       if (!subaddr_indices.empty() && std::count_if(i->second.m_subaddr_indices.begin(), i->second.m_subaddr_indices.end(), [&subaddr_indices](uint32_t index) { return subaddr_indices.count(index) == 1; }) == 0)
@@ -6109,7 +7189,8 @@ void wallet2::get_unconfirmed_payments_out(std::list<std::pair<crypto::hash,wall
   //----------------------------------------------------------------------------------------------------
   void wallet2::get_unconfirmed_payments(std::list<std::pair<crypto::hash, wallet2::pool_payment_details>> &unconfirmed_payments, const boost::optional<uint32_t> &subaddr_account, const std::set<uint32_t> &subaddr_indices) const
   {
-  for (auto i = m_unconfirmed_payments.begin(); i != m_unconfirmed_payments.end(); ++i) {
+    for (auto i = m_unconfirmed_payments.begin(); i != m_unconfirmed_payments.end(); ++i)
+    {
       if ((!subaddr_account || *subaddr_account == i->second.m_pd.m_subaddr_index.major) &&
           (subaddr_indices.empty() || subaddr_indices.count(i->second.m_pd.m_subaddr_index.minor) == 1))
         unconfirmed_payments.push_back(*i);
@@ -6118,39 +7199,39 @@ void wallet2::get_unconfirmed_payments(std::list<std::pair<crypto::hash,wallet2:
   //----------------------------------------------------------------------------------------------------
   void wallet2::rescan_spent()
   {
+    std::vector<transfer_container> specific_transfers = {m_transfers, m_offshore_transfers};
+    for (transfer_container &transfers : specific_transfers)
+    {
+
       // This is RPC call that can take a long time if there are many outputs,
       // so we call it several times, in stripes, so we don't time out spuriously
       std::vector<int> spent_status;
-  spent_status.reserve(m_transfers.size());
+      spent_status.reserve(transfers.size());
       const size_t chunk_size = 1000;
-  for (size_t start_offset = 0; start_offset < m_transfers.size(); start_offset += chunk_size)
+      for (size_t start_offset = 0; start_offset < transfers.size(); start_offset += chunk_size)
       {
-    const size_t n_outputs = std::min<size_t>(chunk_size, m_transfers.size() - start_offset);
-    MDEBUG("Calling is_key_image_spent on " << start_offset << " - " << (start_offset + n_outputs - 1) << ", out of " << m_transfers.size());
+        const size_t n_outputs = std::min<size_t>(chunk_size, transfers.size() - start_offset);
+        MDEBUG("Calling is_key_image_spent on " << start_offset << " - " << (start_offset + n_outputs - 1) << ", out of " << transfers.size());
         COMMAND_RPC_IS_KEY_IMAGE_SPENT::request req = AUTO_VAL_INIT(req);
         COMMAND_RPC_IS_KEY_IMAGE_SPENT::response daemon_resp = AUTO_VAL_INIT(daemon_resp);
         for (size_t n = start_offset; n < start_offset + n_outputs; ++n)
-      req.key_images.push_back(string_tools::pod_to_hex(m_transfers[n].m_key_image));
-
-    {
-      const boost::lock_guard<boost::recursive_mutex> lock{m_daemon_rpc_mutex};
-      uint64_t pre_call_credits = m_rpc_payment_state.credits;
-      req.client = get_client_signature();
-      bool r = epee::net_utils::invoke_http_json("/is_key_image_spent", req, daemon_resp, *m_http_client, rpc_timeout);
-      THROW_ON_RPC_RESPONSE_ERROR(r, {}, daemon_resp, "is_key_image_spent", error::is_key_image_spent_error, get_rpc_status(daemon_resp.status));
+          req.key_images.push_back(string_tools::pod_to_hex(transfers[n].m_key_image));
+        m_daemon_rpc_mutex.lock();
+        bool r = invoke_http_json("/is_key_image_spent", req, daemon_resp, rpc_timeout);
+        m_daemon_rpc_mutex.unlock();
+        THROW_WALLET_EXCEPTION_IF(!r, error::no_connection_to_daemon, "is_key_image_spent");
+        THROW_WALLET_EXCEPTION_IF(daemon_resp.status == CORE_RPC_STATUS_BUSY, error::daemon_busy, "is_key_image_spent");
+        THROW_WALLET_EXCEPTION_IF(daemon_resp.status != CORE_RPC_STATUS_OK, error::is_key_image_spent_error, get_rpc_status(daemon_resp.status));
         THROW_WALLET_EXCEPTION_IF(daemon_resp.spent_status.size() != n_outputs, error::wallet_internal_error,
                                   "daemon returned wrong response for is_key_image_spent, wrong amounts count = " +
                                       std::to_string(daemon_resp.spent_status.size()) + ", expected " + std::to_string(n_outputs));
-      check_rpc_cost("/is_key_image_spent", daemon_resp.credits, pre_call_credits, n_outputs * COST_PER_KEY_IMAGE);
-    }
-
         std::copy(daemon_resp.spent_status.begin(), daemon_resp.spent_status.end(), std::back_inserter(spent_status));
       }
 
       // update spent status
-  for (size_t i = 0; i < m_transfers.size(); ++i)
+      for (size_t i = 0; i < transfers.size(); ++i)
       {
-    transfer_details& td = m_transfers[i];
+        transfer_details &td = transfers[i];
         // a view wallet may not know about key images
         if (!td.m_key_image_known || td.m_key_image_partial)
           continue;
@@ -6171,6 +7252,7 @@ void wallet2::rescan_spent()
         }
       }
     }
+  }
   //----------------------------------------------------------------------------------------------------
   void wallet2::rescan_blockchain(bool hard, bool refresh, bool keep_key_images)
   {
@@ -6222,7 +7304,8 @@ bool wallet2::is_tx_spendtime_unlocked(uint64_t unlock_time, uint64_t block_heig
         return true;
       else
         return false;
-  }else
+    }
+    else
     {
       //interpret as time
       uint64_t current_time = static_cast<uint64_t>(time(NULL));
@@ -6287,7 +7370,7 @@ namespace
         }
       }
     }
-}
+  } // namespace
   //----------------------------------------------------------------------------------------------------
   // This returns a handwavy estimation of how much two outputs are related
   // If they're from the same tx, then they're fully related. From close block
@@ -6369,9 +7452,9 @@ size_t wallet2::pop_best_value_from(const transfer_container &transfers, std::ve
     return pop_index(unused_indices, candidates[idx]);
   }
   //----------------------------------------------------------------------------------------------------
-size_t wallet2::pop_best_value(std::vector<size_t> &unused_indices, const std::vector<size_t>& selected_transfers, bool smallest) const
+  size_t wallet2::pop_best_value(std::vector<size_t> &unused_indices, const std::vector<size_t> &selected_transfers, bool smallest, bool use_offshore_outputs) const
   {
-  return pop_best_value_from(m_transfers, unused_indices, selected_transfers, smallest);
+    return pop_best_value_from((use_offshore_outputs ? m_offshore_transfers : m_transfers), unused_indices, selected_transfers, smallest);
   }
   //----------------------------------------------------------------------------------------------------
   // Select random input sources for transaction.
@@ -6396,11 +7479,43 @@ uint64_t wallet2::select_transfers(uint64_t needed_money, std::vector<size_t> un
   //----------------------------------------------------------------------------------------------------
   void wallet2::add_unconfirmed_tx(const cryptonote::transaction &tx, uint64_t amount_in, const std::vector<cryptonote::tx_destination_entry> &dests, const crypto::hash &payment_id, uint64_t change_amount, uint32_t subaddr_account, const std::set<uint32_t> &subaddr_indices)
   {
+
     unconfirmed_transfer_details &utd = m_unconfirmed_txs[cryptonote::get_transaction_hash(tx)];
+
+    // Check to see if this is an offshore tx
+    bool bOffshoreTx = false;
+    tx_extra_offshore offshore_data;
+    if (tx.extra.size())
+    {
+      bOffshoreTx = get_offshore_from_tx_extra(tx.extra, offshore_data);
+    }
+
+    if (bOffshoreTx)
+    {
+      // Set the bool flags
+      if ((offshore_data.data.at(0) > 'A') && (offshore_data.data.at(1) > 'A'))
+      {
+        utd.m_offshore_to_offshore = true;
+      }
+      else if (offshore_data.data.at(0) > 'A')
+      {
+        utd.m_onshore = true;
+      }
+      else
+      {
+        utd.m_offshore = true;
+      }
+    }
+
     utd.m_amount_in = amount_in;
     utd.m_amount_out = 0;
     for (const auto &d : dests)
+    {
+      if (utd.m_onshore || utd.m_offshore_to_offshore)
+        utd.m_amount_out += d.amount_usd;
+      else
         utd.m_amount_out += d.amount;
+    }
     utd.m_amount_out += change_amount; // dests does not contain change
     utd.m_change = change_amount;
     utd.m_sent_time = time(NULL);
@@ -6413,11 +7528,26 @@ void wallet2::add_unconfirmed_tx(const cryptonote::transaction& tx, uint64_t amo
     utd.m_subaddr_indices = subaddr_indices;
     for (const auto &in : tx.vin)
     {
-    if (in.type() != typeid(cryptonote::txin_to_key))
-      continue;
+      if (in.type() == typeid(cryptonote::txin_to_key))
+      {
         const auto &txin = boost::get<cryptonote::txin_to_key>(in);
         utd.m_rings.push_back(std::make_pair(txin.k_image, txin.key_offsets));
       }
+      else if (in.type() == typeid(cryptonote::txin_offshore))
+      {
+        const auto &txin = boost::get<cryptonote::txin_offshore>(in);
+        utd.m_rings.push_back(std::make_pair(txin.k_image, txin.key_offsets));
+      }
+      else if (in.type() == typeid(cryptonote::txin_onshore))
+      {
+        const auto &txin = boost::get<cryptonote::txin_onshore>(in);
+        utd.m_rings.push_back(std::make_pair(txin.k_image, txin.key_offsets));
+      }
+      else
+      {
+        continue;
+      }
+    }
   }
 
   //----------------------------------------------------------------------------------------------------
@@ -6456,6 +7586,8 @@ void wallet2::commit_tx(pending_tx& ptx)
   {
     using namespace cryptonote;
 
+    transfer_container &specific_transfers = ptx.tx.vin[0].type() == typeid(txin_to_key) ? m_transfers : m_offshore_transfers;
+
     if (m_light_wallet)
     {
       cryptonote::COMMAND_RPC_SUBMIT_RAW_TX::request oreq;
@@ -6492,7 +7624,7 @@ void wallet2::commit_tx(pending_tx& ptx)
       // sanity checks
       for (size_t idx : ptx.selected_transfers)
       {
-      THROW_WALLET_EXCEPTION_IF(idx >= m_transfers.size(), error::wallet_internal_error,
+        THROW_WALLET_EXCEPTION_IF(idx >= specific_transfers.size(), error::wallet_internal_error,
                                   "Bad output index in selected transfers: " + boost::lexical_cast<std::string>(idx));
       }
     }
@@ -6507,9 +7639,37 @@ void wallet2::commit_tx(pending_tx& ptx)
       payment_id = get_payment_id(ptx);
       dests = ptx.dests;
       for (size_t idx : ptx.selected_transfers)
-      amount_in += m_transfers[idx].amount();
+        amount_in += specific_transfers[idx].amount();
+    }
+    // Check to see if this is an offshore tx
+    bool bOffshoreTx = false;
+    tx_extra_offshore offshore_data;
+    if (ptx.tx.extra.size())
+    {
+      bOffshoreTx = get_offshore_from_tx_extra(ptx.tx.extra, offshore_data);
+    }
+
+    bool offshore = false;
+    bool onshore = false;
+    bool offshore_to_offshore = false;
+
+    // Set the bool flags
+    if (bOffshoreTx)
+    {
+      if ((offshore_data.data.at(0) > 'A') && (offshore_data.data.at(1) > 'A'))
+      {
+        offshore_to_offshore = true;
+      }
+      else if (offshore_data.data.at(0) > 'A')
+      {
+        onshore = true;
+      }
+      else
+      {
+        offshore = true;
       }
-  add_unconfirmed_tx(ptx.tx, amount_in, dests, payment_id, ptx.change_dts.amount, ptx.construction_data.subaddr_account, ptx.construction_data.subaddr_indices);
+    }
+    add_unconfirmed_tx(ptx.tx, amount_in, dests, payment_id, (offshore_to_offshore || onshore) ? ptx.change_dts.amount_usd : ptx.change_dts.amount, ptx.construction_data.subaddr_account, ptx.construction_data.subaddr_indices);
     if (store_tx_info() && ptx.tx_key != crypto::null_skey)
     {
       m_tx_keys.insert(std::make_pair(txid, ptx.tx_key));
@@ -6519,13 +7679,20 @@ void wallet2::commit_tx(pending_tx& ptx)
     LOG_PRINT_L2("transaction " << txid << " generated ok and sent to daemon, key_images: [" << ptx.key_images << "]");
 
     for (size_t idx : ptx.selected_transfers)
+    {
+      if (ptx.tx.vin[0].type() == typeid(txin_to_key))
       {
         set_spent(idx, 0);
       }
+      else
+      {
+        set_offshore_spent(idx, 0);
+      }
+    }
 
     // tx generated, get rid of used k values
     for (size_t idx : ptx.selected_transfers)
-    memwipe(m_transfers[idx].m_multisig_k.data(), m_transfers[idx].m_multisig_k.size() * sizeof(m_transfers[idx].m_multisig_k[0]));
+      memwipe(specific_transfers[idx].m_multisig_k.data(), specific_transfers[idx].m_multisig_k.size() * sizeof(specific_transfers[idx].m_multisig_k[0]));
 
     //fee includes dust if dust policy specified it.
     LOG_PRINT_L1("Transaction successfully sent. <" << txid << ">" << ENDL
@@ -6689,7 +7856,13 @@ bool wallet2::sign_tx(unsigned_tx_set &exported_txs, std::vector<wallet2::pendin
       crypto::secret_key tx_key;
       std::vector<crypto::secret_key> additional_tx_keys;
       rct::multisig_out msout;
-    bool r = cryptonote::construct_tx_and_get_tx_key(m_account.get_keys(), m_subaddresses, sd.sources, sd.splitted_dsts, sd.change_dts.addr, sd.extra, ptx.tx, sd.unlock_time, tx_key, additional_tx_keys, sd.use_rct, rct_config, m_multisig ? &msout : NULL);
+      uint64_t current_height = get_blockchain_current_height() - 1;
+      offshore::pricing_record pr;
+      bool b = get_pricing_record(pr, current_height);
+      THROW_WALLET_EXCEPTION_IF(!b, error::wallet_internal_error, "Failed to get pricing record");
+      uint32_t fees_version = use_fork_rules(HF_VERSION_OFFSHORE_FEES_V3, 0) ? 3 : use_fork_rules(HF_VERSION_OFFSHORE_FEES_V2, 0) ? 2 : 1;
+      bool use_offshore_tx_version = use_fork_rules(HF_VERSION_OFFSHORE_FULL, 0);
+      bool r = cryptonote::construct_tx_and_get_tx_key(m_account.get_keys(), m_subaddresses, sd.sources, sd.splitted_dsts, sd.change_dts.addr, sd.extra, ptx.tx, sd.unlock_time, tx_key, additional_tx_keys, current_height, pr, fees_version, use_offshore_tx_version, sd.use_rct, rct_config, m_multisig ? &msout : NULL);
       THROW_WALLET_EXCEPTION_IF(!r, error::tx_not_constructed, sd.sources, sd.splitted_dsts, sd.unlock_time, m_nettype);
       // we don't test tx size, because we don't know the current limit, due to not having a blockchain,
       // and it's a bit pointless to fail there anyway, since it'd be a (good) guess only. We sign anyway,
@@ -6707,8 +7880,7 @@ bool wallet2::sign_tx(unsigned_tx_set &exported_txs, std::vector<wallet2::pendin
       }
 
       std::string key_images;
-    bool all_are_txin_to_key = std::all_of(ptx.tx.vin.begin(), ptx.tx.vin.end(), [&](const txin_v& s_e) -> bool
-    {
+      bool all_are_txin_to_key = std::all_of(ptx.tx.vin.begin(), ptx.tx.vin.end(), [&](const txin_v &s_e) -> bool {
         CHECKED_GET_SPECIFIC_VARIANT(s_e, const txin_to_key, in, false);
         key_images += boost::to_string(in.k_image) + " ";
         return true;
@@ -6717,8 +7889,10 @@ bool wallet2::sign_tx(unsigned_tx_set &exported_txs, std::vector<wallet2::pendin
 
       ptx.key_images = key_images;
       ptx.fee = 0;
-    for (const auto &i: sd.sources) ptx.fee += i.amount;
-    for (const auto &i: sd.splitted_dsts) ptx.fee -= i.amount;
+      for (const auto &i : sd.sources)
+        ptx.fee += i.amount;
+      for (const auto &i : sd.splitted_dsts)
+        ptx.fee -= i.amount;
       ptx.dust = 0;
       ptx.dust_added_to_fee = false;
       ptx.change_dts = sd.change_dts;
@@ -6939,7 +8113,8 @@ bool wallet2::parse_tx_from_str(const std::string &signed_tx_st, std::vector<too
       return false;
     }
     LOG_PRINT_L0("Loaded signed tx data from binary: " << signed_txs.ptx.size() << " transactions");
-  for (auto &c_ptx: signed_txs.ptx) LOG_PRINT_L0(cryptonote::obj_to_json_str(c_ptx.tx));
+    for (auto &c_ptx : signed_txs.ptx)
+      LOG_PRINT_L0(cryptonote::obj_to_json_str(c_ptx.tx));
 
     if (accept_func && !accept_func(signed_txs))
     {
@@ -6949,7 +8124,8 @@ bool wallet2::parse_tx_from_str(const std::string &signed_tx_st, std::vector<too
 
     // import key images
     bool r = import_key_images(signed_txs.key_images);
-  if (!r) return false;
+    if (!r)
+      return false;
 
     // remember key images for this tx, for when we get those txes from the blockchain
     for (const auto &e : signed_txs.tx_key_images)
@@ -7014,7 +8190,9 @@ wallet2::multisig_tx_set wallet2::make_multisig_tx_set(const std::vector<pending
     for (const auto &msk : get_account().get_multisig_keys())
     {
       crypto::public_key pkey = get_multisig_signing_public_key(msk);
-    for (auto &ptx: txs.m_ptx) for (auto &sig: ptx.multisig_sigs) sig.signing_keys.insert(pkey);
+      for (auto &ptx : txs.m_ptx)
+        for (auto &sig : ptx.multisig_sigs)
+          sig.signing_keys.insert(pkey);
     }
 
     txs.m_signers.insert(get_multisig_signer_public_key());
@@ -7087,7 +8265,8 @@ bool wallet2::load_multisig_tx(cryptonote::blobdata s, multisig_tx_set &exported
     }
 
     LOG_PRINT_L1("Loaded multisig tx unsigned data from binary: " << exported_txs.m_ptx.size() << " transactions");
-  for (auto &ptx: exported_txs.m_ptx) LOG_PRINT_L0(cryptonote::obj_to_json_str(ptx.tx));
+    for (auto &ptx : exported_txs.m_ptx)
+      LOG_PRINT_L0(cryptonote::obj_to_json_str(ptx.tx));
 
     if (accept_func && !accept_func(exported_txs))
     {
@@ -7157,13 +8336,18 @@ bool wallet2::sign_multisig_tx(multisig_tx_set &exported_txs, std::vector<crypto
       tools::wallet2::pending_tx &ptx = exported_txs.m_ptx[n];
       THROW_WALLET_EXCEPTION_IF(ptx.multisig_sigs.empty(), error::wallet_internal_error, "No signatures found in multisig tx");
       tools::wallet2::tx_construction_data &sd = ptx.construction_data;
-    LOG_PRINT_L1(" " << (n+1) << ": " << sd.sources.size() << " inputs, mixin " << (sd.sources[0].outputs.size()-1) <<
-        ", signed by " << exported_txs.m_signers.size() << "/" << m_multisig_threshold);
+      LOG_PRINT_L1(" " << (n + 1) << ": " << sd.sources.size() << " inputs, mixin " << (sd.sources[0].outputs.size() - 1) << ", signed by " << exported_txs.m_signers.size() << "/" << m_multisig_threshold);
       cryptonote::transaction tx;
       rct::multisig_out msout = ptx.multisig_sigs.front().msout;
       auto sources = sd.sources;
       rct::RCTConfig rct_config = sd.rct_config;
-    bool r = cryptonote::construct_tx_with_tx_key(m_account.get_keys(), m_subaddresses, sources, sd.splitted_dsts, ptx.change_dts.addr, sd.extra, tx, sd.unlock_time, ptx.tx_key, ptx.additional_tx_keys, sd.use_rct, rct_config, &msout, false);
+      uint64_t current_height = get_blockchain_current_height() - 1;
+      offshore::pricing_record pr;
+      bool b = get_pricing_record(pr, current_height);
+      THROW_WALLET_EXCEPTION_IF(!b, error::wallet_internal_error, "Failed to get pricing record");
+      bool use_offshore_fees_v2 = use_fork_rules(HF_VERSION_OFFSHORE_FEES_V2, 0);
+      bool use_offshore_tx_version = use_fork_rules(HF_VERSION_OFFSHORE_FULL, 0);
+      bool r = cryptonote::construct_tx_with_tx_key(m_account.get_keys(), m_subaddresses, sources, sd.splitted_dsts, ptx.change_dts.addr, sd.extra, tx, sd.unlock_time, ptx.tx_key, ptx.additional_tx_keys, current_height, pr, use_offshore_fees_v2, use_offshore_tx_version, sd.use_rct, rct_config, &msout, false);
       THROW_WALLET_EXCEPTION_IF(!r, error::tx_not_constructed, sd.sources, sd.splitted_dsts, sd.unlock_time, m_nettype);
 
       THROW_WALLET_EXCEPTION_IF(get_transaction_prefix_hash(tx) != get_transaction_prefix_hash(ptx.tx),
@@ -7248,6 +8432,7 @@ bool wallet2::sign_multisig_tx_to_file(multisig_tx_set &exported_txs, const std:
       return false;
     return save_multisig_tx(exported_txs, filename);
   }
+
   //----------------------------------------------------------------------------------------------------
   bool wallet2::sign_multisig_tx_from_file(const std::string &filename, std::vector<crypto::hash> &txids, std::function<bool(const multisig_tx_set &)> accept_func)
   {
@@ -7263,16 +8448,21 @@ bool wallet2::sign_multisig_tx_from_file(const std::string &filename, std::vecto
     return sign_multisig_tx_to_file(exported_txs, filename, txids);
   }
   //----------------------------------------------------------------------------------------------------
-uint64_t wallet2::estimate_fee(bool use_per_byte_fee, bool use_rct, int n_inputs, int mixin, int n_outputs, size_t extra_size, bool bulletproof, uint64_t base_fee, uint64_t fee_multiplier, uint64_t fee_quantization_mask) const
+  uint8_t get_clsag_fork()
+  {
+    return HF_VERSION_CLSAG;
+  }
+  //----------------------------------------------------------------------------------------------------
+  uint64_t wallet2::estimate_fee(bool use_per_byte_fee, bool use_rct, int n_inputs, int mixin, int n_outputs, size_t extra_size, bool bulletproof, bool clsag, uint64_t base_fee, uint64_t fee_multiplier, uint64_t fee_quantization_mask)
   {
     if (use_per_byte_fee)
     {
-    const size_t estimated_tx_weight = estimate_tx_weight(use_rct, n_inputs, mixin, n_outputs, extra_size, bulletproof);
+      const size_t estimated_tx_weight = estimate_tx_weight(use_rct, n_inputs, mixin, n_outputs, extra_size, bulletproof, clsag);
       return calculate_fee_from_weight(base_fee, estimated_tx_weight, fee_multiplier, fee_quantization_mask);
     }
     else
     {
-    const size_t estimated_tx_size = estimate_tx_size(use_rct, n_inputs, mixin, n_outputs, extra_size, bulletproof);
+      const size_t estimated_tx_size = estimate_tx_size(use_rct, n_inputs, mixin, n_outputs, extra_size, bulletproof, clsag);
       return calculate_fee(base_fee, estimated_tx_size, fee_multiplier);
     }
   }
@@ -7283,8 +8473,7 @@ uint64_t wallet2::get_fee_multiplier(uint32_t priority, int fee_algorithm)
     {
       size_t count;
       uint64_t multipliers[4];
-  }
-  multipliers[] =
+    } multipliers[] =
         {
             {3, {1, 2, 3}},
             {3, {1, 20, 166}},
@@ -7332,6 +8521,10 @@ uint64_t wallet2::get_dynamic_base_fee_estimate()
   //----------------------------------------------------------------------------------------------------
   uint64_t wallet2::get_base_fee()
   {
+    if (use_fork_rules(HF_VERSION_PER_BYTE_FEE))
+    {
+      return FEE_PER_BYTE;
+    }
     if (m_light_wallet)
     {
       if (use_fork_rules(HF_VERSION_PER_BYTE_FEE))
@@ -7377,14 +8570,10 @@ int wallet2::get_fee_algorithm()
   //------------------------------------------------------------------------------------------------------------------------------
   uint64_t wallet2::get_min_ring_size()
   {
-  if (use_fork_rules(8, 10))
+    if (use_fork_rules(5, 10))
       return 11;
-  if (use_fork_rules(7, 10))
-    return 7;
-  if (use_fork_rules(6, 10))
-    return 5;
-  if (use_fork_rules(2, 10))
-    return 3;
+    if (use_fork_rules(5, 10))
+      return 10;
     return 0;
   }
   //------------------------------------------------------------------------------------------------------------------------------
@@ -7528,12 +8717,15 @@ crypto::chacha_key wallet2::get_ringdb_key()
     return *m_ringdb_key;
   }
 
-void wallet2::register_devices(){
+  void wallet2::register_devices()
+  {
     hw::trezor::register_all();
   }
 
-hw::device& wallet2::lookup_device(const std::string & device_descriptor){
-  if (!m_devices_registered){
+  hw::device &wallet2::lookup_device(const std::string &device_descriptor)
+  {
+    if (!m_devices_registered)
+    {
       m_devices_registered = true;
       register_devices();
     }
@@ -7545,30 +8737,54 @@ bool wallet2::add_rings(const crypto::chacha_key &key, const cryptonote::transac
   {
     if (!m_ringdb)
       return false;
-  try { return m_ringdb->add_rings(key, tx); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return m_ringdb->add_rings(key, tx);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::add_rings(const cryptonote::transaction_prefix &tx)
   {
-  try { return add_rings(get_ringdb_key(), tx); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return add_rings(get_ringdb_key(), tx);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::remove_rings(const cryptonote::transaction_prefix &tx)
   {
     if (!m_ringdb)
       return false;
-  try { return m_ringdb->remove_rings(get_ringdb_key(), tx); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return m_ringdb->remove_rings(get_ringdb_key(), tx);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::get_ring(const crypto::chacha_key &key, const crypto::key_image &key_image, std::vector<uint64_t> &outs)
   {
     if (!m_ringdb)
       return false;
-  try { return m_ringdb->get_ring(key, key_image, outs); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return m_ringdb->get_ring(key, key_image, outs);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::get_rings(const crypto::hash &txid, std::vector<std::pair<crypto::key_image, std::vector<uint64_t>>> &outs)
@@ -7596,8 +8812,14 @@ bool wallet2::get_rings(const crypto::hash &txid, std::vector<std::pair<crypto::
 
   bool wallet2::get_ring(const crypto::key_image &key_image, std::vector<uint64_t> &outs)
   {
-  try { return get_ring(get_ringdb_key(), key_image, outs); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return get_ring(get_ringdb_key(), key_image, outs);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::set_ring(const crypto::key_image &key_image, const std::vector<uint64_t> &outs, bool relative)
@@ -7605,8 +8827,14 @@ bool wallet2::set_ring(const crypto::key_image &key_image, const std::vector<uin
     if (!m_ringdb)
       return false;
 
-  try { return m_ringdb->set_ring(get_ringdb_key(), key_image, outs, relative); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return m_ringdb->set_ring(get_ringdb_key(), key_image, outs, relative);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::unset_ring(const std::vector<crypto::key_image> &key_images)
@@ -7614,8 +8842,14 @@ bool wallet2::unset_ring(const std::vector<crypto::key_image> &key_images)
     if (!m_ringdb)
       return false;
 
-  try { return m_ringdb->remove_rings(get_ringdb_key(), key_images); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return m_ringdb->remove_rings(get_ringdb_key(), key_images);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::unset_ring(const crypto::hash &txid)
@@ -7640,8 +8874,14 @@ bool wallet2::unset_ring(const crypto::hash &txid)
       return false;
     THROW_WALLET_EXCEPTION_IF(tx_hash != txid, error::wallet_internal_error, "Failed to get the right transaction from daemon");
 
-  try { return m_ringdb->remove_rings(get_ringdb_key(), tx); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return m_ringdb->remove_rings(get_ringdb_key(), tx);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::find_and_save_rings(bool force)
@@ -7715,8 +8955,14 @@ bool wallet2::blackball_output(const std::pair<uint64_t, uint64_t> &output)
   {
     if (!m_ringdb)
       return false;
-  try { return m_ringdb->blackball(output); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return m_ringdb->blackball(output);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::set_blackballed_outputs(const std::vector<std::pair<uint64_t, uint64_t>> &outputs, bool add)
@@ -7731,23 +8977,38 @@ bool wallet2::set_blackballed_outputs(const std::vector<std::pair<uint64_t, uint
       ret &= m_ringdb->blackball(outputs);
       return ret;
     }
-  catch (const std::exception &e) { return false; }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::unblackball_output(const std::pair<uint64_t, uint64_t> &output)
   {
     if (!m_ringdb)
       return false;
-  try { return m_ringdb->unblackball(output); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return m_ringdb->unblackball(output);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::is_output_blackballed(const std::pair<uint64_t, uint64_t> &output) const
   {
     if (!m_ringdb)
       return false;
-  try { return m_ringdb->blackballed(output); }
-  catch (const std::exception &e) { return false; }
+    try
+    {
+      return m_ringdb->blackballed(output);
+    }
+    catch (const std::exception &e)
+    {
+      return false;
+    }
   }
 
   bool wallet2::lock_keys_file()
@@ -7810,7 +9071,8 @@ bool wallet2::tx_add_fake_output(std::vector<std::vector<tools::wallet2::get_out
     return true;
   }
 
-void wallet2::light_wallet_get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>> &outs, const std::vector<size_t> &selected_transfers, size_t fake_outputs_count) {
+  void wallet2::light_wallet_get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>> &outs, const std::vector<size_t> &selected_transfers, size_t fake_outputs_count)
+  {
 
     MDEBUG("LIGHTWALLET - Getting random outs");
 
@@ -7821,7 +9083,8 @@ void wallet2::light_wallet_get_outs(std::vector<std::vector<tools::wallet2::get_
 
     // Amounts to ask for
     // MyMonero api handle amounts and fees as strings
-  for(size_t idx: selected_transfers) {
+    for (size_t idx : selected_transfers)
+    {
       const uint64_t ask_amount = m_transfers[idx].is_rct() ? 0 : m_transfers[idx].amount();
       std::ostringstream amount_ss;
       amount_ss << ask_amount;
@@ -7836,11 +9099,14 @@ void wallet2::light_wallet_get_outs(std::vector<std::vector<tools::wallet2::get_
       m_daemon_rpc_mutex.unlock();
       THROW_WALLET_EXCEPTION_IF(!r, error::no_connection_to_daemon, "get_random_outs");
       THROW_WALLET_EXCEPTION_IF(ores.amount_outs.empty(), error::wallet_internal_error, "No outputs received from light wallet node. Error: " + ores.Error);
-    size_t n_outs = 0; for (const auto &e: ores.amount_outs) n_outs += e.outputs.size();
+      size_t n_outs = 0;
+      for (const auto &e : ores.amount_outs)
+        n_outs += e.outputs.size();
     }
 
     // Check if we got enough outputs for each amount
-  for(auto& out: ores.amount_outs) {
+    for (auto &out : ores.amount_outs)
+    {
       const uint64_t out_amount = boost::lexical_cast<uint64_t>(out.amount);
       THROW_WALLET_EXCEPTION_IF(out.outputs.size() < light_wallet_requested_outputs_count, error::wallet_internal_error, "Not enough outputs for amount: " + boost::lexical_cast<std::string>(out.amount));
       MDEBUG(out.outputs.size() << " outputs for amount " + boost::lexical_cast<std::string>(out.amount) + " received from light wallet node");
@@ -7867,7 +9133,6 @@ void wallet2::light_wallet_get_outs(std::vector<std::vector<tools::wallet2::get_
         order[n] = n;
       std::shuffle(order.begin(), order.end(), crypto::random_device{});
 
-    
       LOG_PRINT_L2("Looking for " << (fake_outputs_count + 1) << " outputs with amounts " << print_money(td.is_rct() ? 0 : td.amount()));
       MDEBUG("OUTS SIZE: " << outs.back().size());
       for (size_t o = 0; o < light_wallet_requested_outputs_count && outs.back().size() < fake_outputs_count + 1; ++o)
@@ -7880,14 +9145,17 @@ void wallet2::light_wallet_get_outs(std::vector<std::vector<tools::wallet2::get_
         size_t amount_key;
         for (amount_key = 0; amount_key < ores.amount_outs.size(); ++amount_key)
         {
-        if(boost::lexical_cast<uint64_t>(ores.amount_outs[amount_key].amount) == amount) {
+          if (boost::lexical_cast<uint64_t>(ores.amount_outs[amount_key].amount) == amount)
+          {
             found_amount = true;
             break;
           }
         }
         THROW_WALLET_EXCEPTION_IF(!found_amount, error::wallet_internal_error, "Outputs for amount " + boost::lexical_cast<std::string>(ores.amount_outs[amount_key].amount) + " not found");
 
-      LOG_PRINT_L2("Index " << i << "/" << light_wallet_requested_outputs_count << ": idx " << ores.amount_outs[amount_key].outputs[i].global_index << " (real " << td.m_global_output_index << "), unlocked " << "(always in light)" << ", key " << ores.amount_outs[0].outputs[i].public_key);
+        LOG_PRINT_L2("Index " << i << "/" << light_wallet_requested_outputs_count << ": idx " << ores.amount_outs[amount_key].outputs[i].global_index << " (real " << td.m_global_output_index << "), unlocked "
+                              << "(always in light)"
+                              << ", key " << ores.amount_outs[0].outputs[i].public_key);
 
         // Convert light wallet string data to proper data structures
         crypto::public_key tx_public_key;
@@ -7899,7 +9167,8 @@ void wallet2::light_wallet_get_outs(std::vector<std::vector<tools::wallet2::get_
         if (!light_wallet_parse_rct_str(ores.amount_outs[amount_key].outputs[i].rct, tx_public_key, 0, mask, rct_commit, false))
           rct_commit = rct::zeroCommit(td.amount());
 
-      if (tx_add_fake_output(outs, global_index, tx_public_key, rct_commit, td.m_global_output_index, true)) {
+        if (tx_add_fake_output(outs, global_index, tx_public_key, rct_commit, td.m_global_output_index, true))
+        {
           MDEBUG("added fake output " << ores.amount_outs[amount_key].outputs[i].public_key);
           MDEBUG("index " << global_index);
         }
@@ -7914,7 +9183,6 @@ void wallet2::light_wallet_get_outs(std::vector<std::vector<tools::wallet2::get_
       // Print output order
       for (auto added_out : outs.back())
         MTRACE(std::get<0>(added_out));
-
     }
   }
 
@@ -7936,12 +9204,12 @@ std::pair<std::set<uint64_t>, size_t> outs_unique(const std::vector<std::vector<
     return std::make_pair(std::move(unique), total);
   }
 
-void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>> &outs, const std::vector<size_t> &selected_transfers, size_t fake_outputs_count)
+  void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>> &outs, const std::vector<size_t> &selected_transfers, size_t fake_outputs_count, bool use_offshore_outputs)
   {
     std::vector<uint64_t> rct_offsets;
     for (size_t attempts = 3; attempts > 0; --attempts)
     {
-    get_outs(outs, selected_transfers, fake_outputs_count, rct_offsets);
+      get_outs(outs, selected_transfers, fake_outputs_count, use_offshore_outputs, rct_offsets);
 
       const auto unique = outs_unique(outs);
       if (tx_sanity_check(unique.first, unique.second, rct_offsets.empty() ? 0 : rct_offsets.back()))
@@ -7960,16 +9228,19 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
     THROW_WALLET_EXCEPTION(error::wallet_internal_error, tr("Transaction sanity check failed"));
   }
 
-void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>> &outs, const std::vector<size_t> &selected_transfers, size_t fake_outputs_count, std::vector<uint64_t> &rct_offsets)
+  void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>> &outs, const std::vector<size_t> &selected_transfers, size_t fake_outputs_count, bool use_offshore_outputs, std::vector<uint64_t> &rct_offsets)
   {
     LOG_PRINT_L2("fake_outputs_count: " << fake_outputs_count);
     outs.clear();
 
-  if(m_light_wallet && fake_outputs_count > 0) {
+    if (m_light_wallet && fake_outputs_count > 0)
+    {
       light_wallet_get_outs(outs, selected_transfers, fake_outputs_count);
       return;
     }
 
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
+
     if (fake_outputs_count > 0)
     {
       uint64_t segregation_fork_height = get_segregation_fork_height();
@@ -7985,10 +9256,10 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
       bool has_rct = false;
       uint64_t max_rct_index = 0;
       for (size_t idx : selected_transfers)
-      if (m_transfers[idx].is_rct())
+        if (specific_transfers[idx].is_rct())
         {
           has_rct = true;
-        max_rct_index = std::max(max_rct_index, m_transfers[idx].m_global_output_index);
+          max_rct_index = std::max(max_rct_index, specific_transfers[idx].m_global_output_index);
         }
       const bool has_rct_distribution = has_rct && (!rct_offsets.empty() || get_rct_distribution(rct_start_height, rct_offsets));
       if (has_rct_distribution)
@@ -8005,8 +9276,8 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
       cryptonote::COMMAND_RPC_GET_OUTPUT_HISTOGRAM::response resp_t = AUTO_VAL_INIT(resp_t);
       // request histogram for all outputs, except 0 if we have the rct distribution
       for (size_t idx : selected_transfers)
-      if (!m_transfers[idx].is_rct() || !has_rct_distribution)
-        req_t.amounts.push_back(m_transfers[idx].is_rct() ? 0 : m_transfers[idx].amount());
+        if (!specific_transfers[idx].is_rct() || !has_rct_distribution)
+          req_t.amounts.push_back(specific_transfers[idx].is_rct() ? 0 : specific_transfers[idx].amount());
       if (!req_t.amounts.empty())
       {
         std::sort(req_t.amounts.begin(), req_t.amounts.end());
@@ -8032,7 +9303,7 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
         cryptonote::COMMAND_RPC_GET_OUTPUT_DISTRIBUTION::request req_t = AUTO_VAL_INIT(req_t);
         cryptonote::COMMAND_RPC_GET_OUTPUT_DISTRIBUTION::response resp_t = AUTO_VAL_INIT(resp_t);
         for (size_t idx : selected_transfers)
-        req_t.amounts.push_back(m_transfers[idx].is_rct() ? 0 : m_transfers[idx].amount());
+          req_t.amounts.push_back(specific_transfers[idx].is_rct() ? 0 : specific_transfers[idx].amount());
         std::sort(req_t.amounts.begin(), req_t.amounts.end());
         auto end = std::unique(req_t.amounts.begin(), req_t.amounts.end());
         req_t.amounts.resize(std::distance(req_t.amounts.begin(), end));
@@ -8048,14 +9319,15 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
           bool r = net_utils::invoke_http_json_rpc("/json_rpc", "get_output_distribution", req_t, resp_t, *m_http_client, rpc_timeout * 1000);
           THROW_ON_RPC_RESPONSE_ERROR(r, {}, resp_t, "get_output_distribution", error::get_output_distribution, get_rpc_status(resp_t.status));
           uint64_t expected_cost = 0;
-        for (uint64_t amount: req_t.amounts) expected_cost += (amount ? COST_PER_OUTPUT_DISTRIBUTION : COST_PER_OUTPUT_DISTRIBUTION_0);
+          for (uint64_t amount : req_t.amounts)
+            expected_cost += (amount ? COST_PER_OUTPUT_DISTRIBUTION : COST_PER_OUTPUT_DISTRIBUTION_0);
           check_rpc_cost("get_output_distribution", resp_t.credits, pre_call_credits, expected_cost);
         }
 
         // check we got all data
         for (size_t idx : selected_transfers)
         {
-        const uint64_t amount = m_transfers[idx].is_rct() ? 0 : m_transfers[idx].amount();
+          const uint64_t amount = specific_transfers[idx].is_rct() ? 0 : specific_transfers[idx].amount();
           bool found = false;
           for (const auto &d : resp_t.distributions)
           {
@@ -8093,7 +9365,7 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
       for (size_t idx : selected_transfers)
       {
         ++num_selected_transfers;
-      const transfer_details &td = m_transfers[idx];
+        const transfer_details &td = specific_transfers[idx];
         const uint64_t amount = td.is_rct() ? 0 : td.amount();
         std::unordered_set<uint64_t> seen_indices;
         // request more for rct in base recent (locked) coinbases are picked, since they're locked for longer
@@ -8190,9 +9462,7 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
           if (td.m_global_output_index >= num_outs - num_recent_outs && recent_outputs_count > 0)
             --recent_outputs_count; // if the real out is recent, pick one less recent fake out
         }
-      LOG_PRINT_L1("Fake output makeup: " << requested_outputs_count << " requested: " << recent_outputs_count << " recent, " <<
-          pre_fork_outputs_count << " pre-fork, " << post_fork_outputs_count << " post-fork, " <<
-          (requested_outputs_count - recent_outputs_count - pre_fork_outputs_count - post_fork_outputs_count) << " full-chain");
+        LOG_PRINT_L1("Fake output makeup: " << requested_outputs_count << " requested: " << recent_outputs_count << " recent, " << pre_fork_outputs_count << " pre-fork, " << post_fork_outputs_count << " post-fork, " << (requested_outputs_count - recent_outputs_count - pre_fork_outputs_count - post_fork_outputs_count) << " full-chain");
 
         uint64_t num_found = 0;
 
@@ -8289,17 +9559,23 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
               // gamma distribution
               if (num_found - 1 < recent_outputs_count + pre_fork_outputs_count)
               {
-              do i = gamma->pick(); while (i >= segregation_limit[amount].first);
+                do
+                  i = gamma->pick();
+                while (i >= segregation_limit[amount].first);
                 type = "pre-fork gamma";
               }
               else if (num_found - 1 < recent_outputs_count + pre_fork_outputs_count + post_fork_outputs_count)
               {
-              do i = gamma->pick(); while (i < segregation_limit[amount].first || i >= num_outs);
+                do
+                  i = gamma->pick();
+                while (i < segregation_limit[amount].first || i >= num_outs);
                 type = "post-fork gamma";
               }
               else
               {
-              do i = gamma->pick(); while (i >= num_outs);
+                do
+                  i = gamma->pick();
+                while (i >= num_outs);
                 type = "gamma";
               }
             }
@@ -8364,8 +9640,7 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
           }
 
           for (const auto &pick : picks)
-          MDEBUG("picking " << pick.first << " outputs: " <<
-              boost::join(pick.second | boost::adaptors::transformed([](uint64_t out){return std::to_string(out);}), " "));
+            MDEBUG("picking " << pick.first << " outputs: " << boost::join(pick.second | boost::adaptors::transformed([](uint64_t out) { return std::to_string(out); }), " "));
 
           // if we had enough unusable outputs, we might fall off here and still
           // have too few outputs, so we stuff with one to keep counts good, and
@@ -8388,8 +9663,7 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
         for (const auto &i : req.outputs)
           outs[i.amount].insert(i.index);
         for (const auto &o : outs)
-        MDEBUG("asking for outputs with amount " << print_money(o.first) << ": " <<
-            boost::join(o.second | boost::adaptors::transformed([](uint64_t out){return std::to_string(out);}), " "));
+          MDEBUG("asking for outputs with amount " << print_money(o.first) << ": " << boost::join(o.second | boost::adaptors::transformed([](uint64_t out) { return std::to_string(out); }), " "));
       }
 
       // get the keys for those
@@ -8412,10 +9686,11 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
       outs.reserve(num_selected_transfers);
       for (size_t idx : selected_transfers)
       {
-      const transfer_details &td = m_transfers[idx];
+        const transfer_details &td = specific_transfers[idx];
         size_t requested_outputs_count = base_requested_outputs_count + (td.is_rct() ? CRYPTONOTE_MINED_MONEY_UNLOCK_WINDOW - CRYPTONOTE_DEFAULT_TX_SPENDABLE_AGE : 0);
         outs.push_back(std::vector<get_outs_entry>());
         outs.back().reserve(fake_outputs_count + 1);
+
         const rct::key mask = td.is_rct() ? rct::commit(td.amount(), td.m_mask) : rct::zeroCommit(td.amount());
 
         uint64_t num_outs = 0;
@@ -8423,7 +9698,8 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
         const bool output_is_pre_fork = td.m_block_height < segregation_fork_height;
         if (is_after_segregation_fork && m_segregate_pre_fork_outputs && output_is_pre_fork)
           num_outs = segregation_limit[amount].first;
-      else for (const auto &he: resp_t.histogram)
+        else
+          for (const auto &he : resp_t.histogram)
           {
             if (he.amount == amount)
             {
@@ -8445,15 +9721,43 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
         {
           size_t i = base + n;
           if (req.outputs[i].index == td.m_global_output_index)
+          {
+            if (td.m_tx.vout[td.m_internal_output_index].target.type() == typeid(txout_to_key))
+            {
               if (daemon_resp.outs[i].key == boost::get<txout_to_key>(td.m_tx.vout[td.m_internal_output_index].target).key)
-            if (daemon_resp.outs[i].mask == mask)
+              {
+                // HERE BE DRAGONS!!!
+                // The following line was commented out because offshore + onshore masks aren't recalculated correctly yet
+                //if (daemon_resp.outs[i].mask == mask)
+                real_out_found = true;
+                // LAND AHOY!!!
+              }
+            }
+            else
+            {
+              if (daemon_resp.outs[i].key == boost::get<txout_offshore>(td.m_tx.vout[td.m_internal_output_index].target).key)
+              {
+                // HERE BE DRAGONS!!!
+                // The following line was commented out because offshore + onshore masks aren't recalculated correctly yet
+                //if (daemon_resp.outs[i].mask == mask)
                 real_out_found = true;
+                // LAND AHOY!!!
+              }
+            }
+          }
         }
         THROW_WALLET_EXCEPTION_IF(!real_out_found, error::wallet_internal_error,
                                   "Daemon response did not include the requested real output");
 
         // pick real out first (it will be sorted when done)
+        if (td.m_tx.vout[td.m_internal_output_index].target.type() == typeid(txout_to_key))
+        {
           outs.back().push_back(std::make_tuple(td.m_global_output_index, boost::get<txout_to_key>(td.m_tx.vout[td.m_internal_output_index].target).key, mask));
+        }
+        else
+        {
+          outs.back().push_back(std::make_tuple(td.m_global_output_index, boost::get<txout_offshore>(td.m_tx.vout[td.m_internal_output_index].target).key, mask));
+        }
 
         // then pick outs from an existing ring, if any
         if (td.m_key_image_known && !td.m_key_image_partial)
@@ -8518,7 +9822,7 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
     {
       for (size_t idx : selected_transfers)
       {
-      const transfer_details &td = m_transfers[idx];
+        const transfer_details &td = specific_transfers[idx];
         std::vector<get_outs_entry> v;
         const rct::key mask = td.is_rct() ? rct::commit(td.amount(), td.m_mask) : rct::zeroCommit(td.amount());
         v.push_back(std::make_tuple(td.m_global_output_index, td.get_public_key(), mask));
@@ -8530,8 +9834,8 @@ void wallet2::get_outs(std::vector<std::vector<tools::wallet2::get_outs_entry>>
     for (size_t i = 0; i < selected_transfers.size(); ++i)
     {
       const size_t idx = selected_transfers[i];
-    THROW_WALLET_EXCEPTION_IF(idx >= m_transfers.size(), error::wallet_internal_error, "selected_transfers entry out of range");
-    const transfer_details &td = m_transfers[idx];
+      THROW_WALLET_EXCEPTION_IF(idx >= specific_transfers.size(), error::wallet_internal_error, "selected_transfers entry out of range");
+      const transfer_details &td = specific_transfers[idx];
       std::vector<uint64_t> ring;
       ring.reserve(outs[i].size());
       for (const auto &e : outs[i])
@@ -8608,8 +9912,7 @@ void wallet2::transfer_selected(const std::vector<cryptonote::tx_destination_ent
       }
 
       //paste real transaction to the random index
-    auto it_to_replace = std::find_if(src.outputs.begin(), src.outputs.end(), [&](const tx_output_entry& a)
-    {
+      auto it_to_replace = std::find_if(src.outputs.begin(), src.outputs.end(), [&](const tx_output_entry &a) {
         return a.first == td.m_global_output_index;
       });
       THROW_WALLET_EXCEPTION_IF(it_to_replace == src.outputs.end(), error::wallet_internal_error,
@@ -8641,11 +9944,12 @@ void wallet2::transfer_selected(const std::vector<cryptonote::tx_destination_ent
     std::vector<cryptonote::tx_destination_entry> splitted_dsts, dust_dsts;
     uint64_t dust = 0;
     destination_split_strategy(dsts, change_dts, dust_policy.dust_threshold, splitted_dsts, dust_dsts);
-  for(auto& d: dust_dsts) {
-    THROW_WALLET_EXCEPTION_IF(dust_policy.dust_threshold < d.amount, error::wallet_internal_error, "invalid dust value: dust = " +
-      std::to_string(d.amount) + ", dust_threshold = " + std::to_string(dust_policy.dust_threshold));
+    for (auto &d : dust_dsts)
+    {
+      THROW_WALLET_EXCEPTION_IF(dust_policy.dust_threshold < d.amount, error::wallet_internal_error, "invalid dust value: dust = " + std::to_string(d.amount) + ", dust_threshold = " + std::to_string(dust_policy.dust_threshold));
     }
-  for(auto& d: dust_dsts) {
+    for (auto &d : dust_dsts)
+    {
       if (!dust_policy.add_to_fee)
         splitted_dsts.push_back(cryptonote::tx_destination_entry(d.amount, dust_policy.addr_for_dust, d.is_subaddress));
       dust += d.amount;
@@ -8655,25 +9959,29 @@ void wallet2::transfer_selected(const std::vector<cryptonote::tx_destination_ent
     std::vector<crypto::secret_key> additional_tx_keys;
     rct::multisig_out msout;
     LOG_PRINT_L2("constructing tx");
-  bool r = cryptonote::construct_tx_and_get_tx_key(m_account.get_keys(), m_subaddresses, sources, splitted_dsts, change_dts.addr, extra, tx, unlock_time, tx_key, additional_tx_keys, false, {}, m_multisig ? &msout : NULL);
+    uint64_t current_height = get_blockchain_current_height() - 1;
+    offshore::pricing_record pr;
+    bool b = get_pricing_record(pr, current_height);
+    THROW_WALLET_EXCEPTION_IF(!b, error::wallet_internal_error, "Failed to get pricing record");
+    uint32_t fees_version = use_fork_rules(HF_VERSION_OFFSHORE_FEES_V3, 0) ? 3 : use_fork_rules(HF_VERSION_OFFSHORE_FEES_V2, 0) ? 2 : 1;
+    bool use_offshore_tx_version = use_fork_rules(HF_VERSION_OFFSHORE_FULL, 0);
+    bool r = cryptonote::construct_tx_and_get_tx_key(m_account.get_keys(), m_subaddresses, sources, splitted_dsts, change_dts.addr, extra, tx, unlock_time, tx_key, additional_tx_keys, current_height, pr, fees_version, use_offshore_tx_version, false, {}, m_multisig ? &msout : NULL);
     LOG_PRINT_L2("constructed tx, r=" << r);
     THROW_WALLET_EXCEPTION_IF(!r, error::tx_not_constructed, sources, splitted_dsts, unlock_time, m_nettype);
     THROW_WALLET_EXCEPTION_IF(upper_transaction_weight_limit <= get_transaction_weight(tx), error::tx_too_big, tx, upper_transaction_weight_limit);
 
     std::string key_images;
-  bool all_are_txin_to_key = std::all_of(tx.vin.begin(), tx.vin.end(), [&](const txin_v& s_e) -> bool
-  {
+    bool all_are_txin_to_key = std::all_of(tx.vin.begin(), tx.vin.end(), [&](const txin_v &s_e) -> bool {
       CHECKED_GET_SPECIFIC_VARIANT(s_e, const txin_to_key, in, false);
       key_images += boost::to_string(in.k_image) + " ";
       return true;
     });
     THROW_WALLET_EXCEPTION_IF(!all_are_txin_to_key, error::unexpected_txin_type, tx);
 
+    bool dust_sent_elsewhere = (dust_policy.addr_for_dust.m_view_public_key != change_dts.addr.m_view_public_key || dust_policy.addr_for_dust.m_spend_public_key != change_dts.addr.m_spend_public_key);
 
-  bool dust_sent_elsewhere = (dust_policy.addr_for_dust.m_view_public_key != change_dts.addr.m_view_public_key
-                                || dust_policy.addr_for_dust.m_spend_public_key != change_dts.addr.m_spend_public_key);
-  
-  if (dust_policy.add_to_fee || dust_sent_elsewhere) change_dts.amount -= dust;
+    if (dust_policy.add_to_fee || dust_sent_elsewhere)
+      change_dts.amount -= dust;
 
     ptx.key_images = key_images;
     ptx.fee = (dust_policy.add_to_fee ? fee + dust : fee);
@@ -8704,12 +10012,18 @@ void wallet2::transfer_selected(const std::vector<cryptonote::tx_destination_ent
 
   void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry> dsts, const std::vector<size_t> &selected_transfers, size_t fake_outputs_count,
                                       std::vector<std::vector<tools::wallet2::get_outs_entry>> &outs,
-  uint64_t unlock_time, uint64_t fee, const std::vector<uint8_t>& extra, cryptonote::transaction& tx, pending_tx &ptx, const rct::RCTConfig &rct_config)
+                                      uint64_t unlock_time, uint64_t fee, const std::vector<uint8_t> &extra, cryptonote::transaction &tx, pending_tx &ptx, const rct::RCTConfig &rct_config, bool offshore, bool onshore, bool offshore_to_offshore)
   {
     using namespace cryptonote;
     // throw if attempting a transaction with no destinations
     THROW_WALLET_EXCEPTION_IF(dsts.empty(), error::zero_destination);
 
+    const bool use_offshore_outputs = onshore || offshore_to_offshore;
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
+
+    // Get the current blockchain height - needed to convert currency amounts
+    uint64_t current_height = get_blockchain_current_height() - 1;
+
     uint64_t upper_transaction_weight_limit = get_upper_transaction_weight_limit();
     uint64_t needed_money = fee;
     LOG_PRINT_L2("transfer_selected_rct: starting with fee " << print_money(needed_money));
@@ -8718,18 +10032,28 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
     // calculate total amount being sent to all destinations
     // throw if total amount overflows uint64_t
     for (auto &dt : dsts)
+    {
+      if (use_offshore_outputs)
+      {
+        THROW_WALLET_EXCEPTION_IF(0 == dt.amount_usd, error::zero_destination);
+        needed_money += dt.amount_usd;
+        LOG_PRINT_L2("transfer: adding " << print_money(dt.amount_usd) << ", for a total of " << print_money(needed_money));
+        THROW_WALLET_EXCEPTION_IF(needed_money < dt.amount_usd, error::tx_sum_overflow, dsts, fee, m_nettype);
+      }
+      else
       {
         THROW_WALLET_EXCEPTION_IF(0 == dt.amount, error::zero_destination);
         needed_money += dt.amount;
         LOG_PRINT_L2("transfer: adding " << print_money(dt.amount) << ", for a total of " << print_money(needed_money));
         THROW_WALLET_EXCEPTION_IF(needed_money < dt.amount, error::tx_sum_overflow, dsts, fee, m_nettype);
       }
+    }
 
     // if this is a multisig wallet, create a list of multisig signers we can use
     std::deque<crypto::public_key> multisig_signers;
     size_t n_multisig_txes = 0;
     std::vector<std::unordered_set<crypto::public_key>> ignore_sets;
-  if (m_multisig && !m_transfers.empty())
+    if (m_multisig && !specific_transfers.empty())
     {
       const crypto::public_key local_signer = get_multisig_signer_public_key();
       size_t n_available_signers = 1;
@@ -8740,7 +10064,7 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
       {
         if (signer == local_signer)
           continue;
-      for (const auto &i: m_transfers[0].m_multisig_info)
+        for (const auto &i : specific_transfers[0].m_multisig_info)
         {
           if (i.m_signer == signer)
           {
@@ -8784,18 +10108,18 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
     uint64_t found_money = 0;
     for (size_t idx : selected_transfers)
     {
-    found_money += m_transfers[idx].amount();
+      found_money += specific_transfers[idx].amount();
     }
 
     LOG_PRINT_L2("wanted " << print_money(needed_money) << ", found " << print_money(found_money) << ", fee " << print_money(fee));
     THROW_WALLET_EXCEPTION_IF(found_money < needed_money, error::not_enough_unlocked_money, found_money, needed_money - fee, fee);
 
-  uint32_t subaddr_account = m_transfers[*selected_transfers.begin()].m_subaddr_index.major;
+    uint32_t subaddr_account = specific_transfers[*selected_transfers.begin()].m_subaddr_index.major;
     for (auto i = ++selected_transfers.begin(); i != selected_transfers.end(); ++i)
-    THROW_WALLET_EXCEPTION_IF(subaddr_account != m_transfers[*i].m_subaddr_index.major, error::wallet_internal_error, "the tx uses funds from multiple accounts");
+      THROW_WALLET_EXCEPTION_IF(subaddr_account != specific_transfers[*i].m_subaddr_index.major, error::wallet_internal_error, "the tx uses funds from multiple accounts");
 
     if (outs.empty())
-    get_outs(outs, selected_transfers, fake_outputs_count); // may throw
+      get_outs(outs, selected_transfers, fake_outputs_count, use_offshore_outputs); // may throw
 
     //prepare inputs
     LOG_PRINT_L2("preparing outputs");
@@ -8806,8 +10130,25 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
     {
       sources.resize(sources.size() + 1);
       cryptonote::tx_source_entry &src = sources.back();
-    const transfer_details& td = m_transfers[idx];
+      const transfer_details &td = specific_transfers[idx];
+      bool b = get_pricing_record(src.pr, td.m_block_height);
+      THROW_WALLET_EXCEPTION_IF(!b, error::wallet_internal_error, "Failed to get pricing record");
+      if (use_offshore_outputs)
+      {
+        // onshore or offshore_to_offshore
+        src.amount = 0;
+        src.amount_usd = td.amount();
+        src.mask_usd = td.m_mask;
+        src.mask = td.m_mask; //HBD rct::commit(src.amount, rct::identity());
+      }
+      else
+      {
+        // offshore or XHV
         src.amount = td.amount();
+        src.amount_usd = 0;
+        src.mask = td.m_mask;
+        src.mask_usd = td.m_mask; //HBD rct::commit(src.amount_usd, rct::identity());
+      }
       src.rct = td.is_rct();
       //paste mixin transaction
 
@@ -8826,8 +10167,7 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
       ++i;
 
       //paste real transaction to the random index
-    auto it_to_replace = std::find_if(src.outputs.begin(), src.outputs.end(), [&](const tx_output_entry& a)
-    {
+      auto it_to_replace = std::find_if(src.outputs.begin(), src.outputs.end(), [&](const tx_output_entry &a) {
         return a.first == td.m_global_output_index;
       });
       THROW_WALLET_EXCEPTION_IF(it_to_replace == src.outputs.end(), error::wallet_internal_error,
@@ -8842,7 +10182,17 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
       src.real_out_additional_tx_keys = get_additional_tx_pub_keys_from_extra(td.m_tx);
       src.real_output = it_to_replace - src.outputs.begin();
       src.real_output_in_tx_index = td.m_internal_output_index;
-    src.mask = td.m_mask;
+
+      // NEAC: Add in the offshore amount and mask, etc, for CLSAG use
+      if (td.m_tx.pricing_record_height != 0)
+      {
+        src.currency_type_burnt = (td.m_tx.offshore_data.at(0) == 'A') ? "XHV" : "xUSD";
+        src.currency_type_minted = (td.m_tx.offshore_data.at(1) == 'A') ? "XHV" : "xUSD";
+      }
+      else
+      {
+      }
+
       if (m_multisig)
       {
         auto ignore_set = ignore_sets.empty() ? std::unordered_set<crypto::public_key>() : ignore_sets.front();
@@ -8855,12 +10205,23 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
     }
     LOG_PRINT_L2("outputs prepared");
 
+    // Put the destinations into the correct currencies
+    for (auto &dt : dsts)
+    {
+      if ((dt.amount_usd == 0) && (offshore || offshore_to_offshore))
+      {
+        // The amount in the dst entry is actually USD, not XHV
+        dt.amount_usd = dt.amount;
+        dt.amount = 0;
+      }
+    }
+
     // we still keep a copy, since we want to keep dsts free of change for user feedback purposes
     std::vector<cryptonote::tx_destination_entry> splitted_dsts = dsts;
     cryptonote::tx_destination_entry change_dts = AUTO_VAL_INIT(change_dts);
-  change_dts.amount = found_money - needed_money;
-  if (change_dts.amount == 0)
+    if (found_money - needed_money == 0)
     {
+      change_dts.amount = change_dts.amount_usd = 0;
       if (splitted_dsts.size() == 1)
       {
         // If the change is 0, send it to a random address, to avoid confusing
@@ -8877,6 +10238,16 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
     }
     else
     {
+      if (use_offshore_outputs)
+      {
+        change_dts.amount_usd = found_money - needed_money;
+        change_dts.amount = 0;
+      }
+      else
+      {
+        change_dts.amount = found_money - needed_money;
+        change_dts.amount_usd = 0;
+      }
       change_dts.addr = get_subaddress({subaddr_account, 0});
       change_dts.is_subaddress = subaddr_account != 0;
       splitted_dsts.push_back(change_dts);
@@ -8887,7 +10258,15 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
     rct::multisig_out msout;
     LOG_PRINT_L2("constructing tx");
     auto sources_copy = sources;
-  bool r = cryptonote::construct_tx_and_get_tx_key(m_account.get_keys(), m_subaddresses, sources, splitted_dsts, change_dts.addr, extra, tx, unlock_time, tx_key, additional_tx_keys, true, rct_config, m_multisig ? &msout : NULL);
+    offshore::pricing_record pr;
+    if (offshore || onshore)
+    {
+      bool b = get_pricing_record(pr, current_height);
+      THROW_WALLET_EXCEPTION_IF(!b, error::wallet_internal_error, "Failed to get pricing record");
+    }
+    uint32_t fees_version = use_fork_rules(HF_VERSION_OFFSHORE_FEES_V3, 0) ? 3 : use_fork_rules(HF_VERSION_OFFSHORE_FEES_V2, 0) ? 2 : 1;
+    bool use_offshore_tx_version = use_fork_rules(HF_VERSION_OFFSHORE_FULL, 0);
+    bool r = cryptonote::construct_tx_and_get_tx_key(m_account.get_keys(), m_subaddresses, sources, splitted_dsts, change_dts.addr, extra, tx, unlock_time, tx_key, additional_tx_keys, current_height, pr, fees_version, use_offshore_tx_version, true, rct_config, m_multisig ? &msout : NULL);
     LOG_PRINT_L2("constructed tx, r=" << r);
     THROW_WALLET_EXCEPTION_IF(!r, error::tx_not_constructed, sources, dsts, unlock_time, m_nettype);
     THROW_WALLET_EXCEPTION_IF(upper_transaction_weight_limit <= get_transaction_weight(tx), error::tx_too_big, tx, upper_transaction_weight_limit);
@@ -8932,7 +10311,16 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
           LOG_PRINT_L2("Creating supplementary multisig transaction");
           cryptonote::transaction ms_tx;
           auto sources_copy_copy = sources_copy;
-        bool r = cryptonote::construct_tx_with_tx_key(m_account.get_keys(), m_subaddresses, sources_copy_copy, splitted_dsts, change_dts.addr, extra, ms_tx, unlock_time,tx_key, additional_tx_keys, true, rct_config, &msout, false);
+          uint64_t current_height = get_blockchain_current_height() - 1;
+          offshore::pricing_record pr;
+          if (offshore || onshore)
+          {
+            bool b = get_pricing_record(pr, current_height);
+            THROW_WALLET_EXCEPTION_IF(!b, error::wallet_internal_error, "Failed to get pricing record");
+          }
+          bool use_offshore_fees_v2 = use_fork_rules(HF_VERSION_OFFSHORE_FEES_V2, 0);
+          bool use_offshore_tx_version = use_fork_rules(HF_VERSION_OFFSHORE_FULL, 0);
+          bool r = cryptonote::construct_tx_with_tx_key(m_account.get_keys(), m_subaddresses, sources_copy_copy, splitted_dsts, change_dts.addr, extra, ms_tx, unlock_time, tx_key, additional_tx_keys, current_height, pr, use_offshore_fees_v2, use_offshore_tx_version, true, rct_config, &msout, false);
           LOG_PRINT_L2("constructed tx, r=" << r);
           THROW_WALLET_EXCEPTION_IF(!r, error::tx_not_constructed, sources, splitted_dsts, unlock_time, m_nettype);
           THROW_WALLET_EXCEPTION_IF(upper_transaction_weight_limit <= get_transaction_weight(tx), error::tx_too_big, tx, upper_transaction_weight_limit);
@@ -8947,13 +10335,28 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
 
     LOG_PRINT_L2("gathering key images");
     std::string key_images;
-  bool all_are_txin_to_key = std::all_of(tx.vin.begin(), tx.vin.end(), [&](const txin_v& s_e) -> bool
+    bool correct_txin_type = std::all_of(tx.vin.begin(), tx.vin.end(), [&](const txin_v &s_e) -> bool {
+      if (s_e.type() == typeid(txin_offshore))
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(s_e, const txin_offshore, in, false);
+        key_images += boost::to_string(in.k_image) + " ";
+        return true;
+      }
+      else if (s_e.type() == typeid(txin_onshore))
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(s_e, const txin_onshore, in, false);
+        key_images += boost::to_string(in.k_image) + " ";
+        return true;
+      }
+      else
       {
         CHECKED_GET_SPECIFIC_VARIANT(s_e, const txin_to_key, in, false);
         key_images += boost::to_string(in.k_image) + " ";
         return true;
+      }
     });
-  THROW_WALLET_EXCEPTION_IF(!all_are_txin_to_key, error::unexpected_txin_type, tx);
+
+    THROW_WALLET_EXCEPTION_IF(!correct_txin_type, error::unexpected_txin_type, tx);
     LOG_PRINT_L2("gathered key images");
 
     ptx.key_images = key_images;
@@ -8975,27 +10378,31 @@ void wallet2::transfer_selected_rct(std::vector<cryptonote::tx_destination_entry
     ptx.construction_data.extra = tx.extra;
     ptx.construction_data.unlock_time = unlock_time;
     ptx.construction_data.use_rct = true;
-  ptx.construction_data.rct_config = { tx.rct_signatures.p.bulletproofs.empty() ? rct::RangeProofBorromean : rct::RangeProofPaddedBulletproof, use_fork_rules(HF_VERSION_SMALLER_BP, -10) ? 2 : 1};
+    ptx.construction_data.rct_config = {
+        tx.rct_signatures.p.bulletproofs.empty() ? rct::RangeProofBorromean : rct::RangeProofPaddedBulletproof,
+        use_fork_rules(HF_VERSION_CLSAG, 0) ? 3 : use_fork_rules(HF_VERSION_SMALLER_BP, -10) ? 2 : 1};
     ptx.construction_data.dests = dsts;
     // record which subaddress indices are being used as inputs
     ptx.construction_data.subaddr_account = subaddr_account;
     ptx.construction_data.subaddr_indices.clear();
     for (size_t idx : selected_transfers)
-    ptx.construction_data.subaddr_indices.insert(m_transfers[idx].m_subaddr_index.minor);
+      ptx.construction_data.subaddr_indices.insert(specific_transfers[idx].m_subaddr_index.minor);
     LOG_PRINT_L2("transfer_selected_rct done");
   }
 
-std::vector<size_t> wallet2::pick_preferred_rct_inputs(uint64_t needed_money, uint32_t subaddr_account, const std::set<uint32_t> &subaddr_indices) const
+  std::vector<size_t> wallet2::pick_preferred_rct_inputs(uint64_t needed_money, uint32_t subaddr_account, const std::set<uint32_t> &subaddr_indices, bool use_offshore_outputs) const
   {
     std::vector<size_t> picks;
     float current_output_relatdness = 1.0f;
 
     LOG_PRINT_L2("pick_preferred_rct_inputs: needed_money " << print_money(needed_money));
 
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
+
     // try to find a rct input of enough size
-  for (size_t i = 0; i < m_transfers.size(); ++i)
+    for (size_t i = 0; i < specific_transfers.size(); ++i)
     {
-    const transfer_details& td = m_transfers[i];
+      const transfer_details &td = specific_transfers[i];
       if (!is_spent(td, false) && !td.m_frozen && td.is_rct() && td.amount() >= needed_money && is_transfer_unlocked(td) && td.m_subaddr_index.major == subaddr_account && subaddr_indices.count(td.m_subaddr_index.minor) == 1)
       {
         if (td.amount() > m_ignore_outputs_above || td.amount() < m_ignore_outputs_below)
@@ -9013,9 +10420,9 @@ std::vector<size_t> wallet2::pick_preferred_rct_inputs(uint64_t needed_money, ui
     // this could be made better by picking one of the outputs to be a small one, since those
     // are less useful since often below the needed money, so if one can be used in a pair,
     // it gets rid of it for the future
-  for (size_t i = 0; i < m_transfers.size(); ++i)
+    for (size_t i = 0; i < specific_transfers.size(); ++i)
     {
-    const transfer_details& td = m_transfers[i];
+      const transfer_details &td = specific_transfers[i];
       if (!is_spent(td, false) && !td.m_frozen && !td.m_key_image_partial && td.is_rct() && is_transfer_unlocked(td) && td.m_subaddr_index.major == subaddr_account && subaddr_indices.count(td.m_subaddr_index.minor) == 1)
       {
         if (td.amount() > m_ignore_outputs_above || td.amount() < m_ignore_outputs_below)
@@ -9024,9 +10431,9 @@ std::vector<size_t> wallet2::pick_preferred_rct_inputs(uint64_t needed_money, ui
           continue;
         }
         LOG_PRINT_L2("Considering input " << i << ", " << print_money(td.amount()));
-      for (size_t j = i + 1; j < m_transfers.size(); ++j)
+        for (size_t j = i + 1; j < specific_transfers.size(); ++j)
         {
-        const transfer_details& td2 = m_transfers[j];
+          const transfer_details &td2 = specific_transfers[j];
           if (td2.amount() > m_ignore_outputs_above || td2.amount() < m_ignore_outputs_below)
           {
             MDEBUG("Ignoring output " << j << " of amount " << print_money(td2.amount()) << " which is outside prescribed range [" << print_money(m_ignore_outputs_below) << ", " << print_money(m_ignore_outputs_above) << "]");
@@ -9060,7 +10467,7 @@ std::vector<size_t> wallet2::pick_preferred_rct_inputs(uint64_t needed_money, ui
     return picks;
   }
 
-bool wallet2::should_pick_a_second_output(bool use_rct, size_t n_transfers, const std::vector<size_t> &unused_transfers_indices, const std::vector<size_t> &unused_dust_indices) const
+  bool wallet2::should_pick_a_second_output(bool use_rct, size_t n_transfers, const std::vector<size_t> &unused_transfers_indices, const std::vector<size_t> &unused_dust_indices, const transfer_container &specific_transfers) const
   {
     if (!use_rct)
       return false;
@@ -9074,15 +10481,16 @@ bool wallet2::should_pick_a_second_output(bool use_rct, size_t n_transfers, cons
     bool found = false;
     for (auto i : unused_dust_indices)
     {
-    if (m_transfers[i].is_rct())
+      if (specific_transfers[i].is_rct())
       {
         found = true;
         break;
       }
     }
-  if (!found) for (auto i: unused_transfers_indices)
+    if (!found)
+      for (auto i : unused_transfers_indices)
       {
-    if (m_transfers[i].is_rct())
+        if (specific_transfers[i].is_rct())
         {
           found = true;
           break;
@@ -9093,14 +10501,15 @@ bool wallet2::should_pick_a_second_output(bool use_rct, size_t n_transfers, cons
     return true;
   }
 
-std::vector<size_t> wallet2::get_only_rct(const std::vector<size_t> &unused_dust_indices, const std::vector<size_t> &unused_transfers_indices) const
+  std::vector<size_t> wallet2::get_only_rct(const std::vector<size_t> &unused_dust_indices, const std::vector<size_t> &unused_transfers_indices, bool use_offshore_outputs) const
   {
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
     std::vector<size_t> indices;
     for (size_t n : unused_dust_indices)
-    if (m_transfers[n].is_rct())
+      if (specific_transfers[n].is_rct())
         indices.push_back(n);
     for (size_t n : unused_transfers_indices)
-    if (m_transfers[n].is_rct())
+      if (specific_transfers[n].is_rct())
         indices.push_back(n);
     return indices;
   }
@@ -9154,7 +10563,6 @@ bool wallet2::light_wallet_import_wallet_request(tools::COMMAND_RPC_IMPORT_WALLE
     m_daemon_rpc_mutex.unlock();
     THROW_WALLET_EXCEPTION_IF(!r, error::no_connection_to_daemon, "import_wallet_request");
 
-
     return true;
   }
 
@@ -9174,7 +10582,6 @@ void wallet2::light_wallet_get_unspent_outs()
     oreq.mixin = 0;
     oreq.use_dust = true;
 
-
     m_daemon_rpc_mutex.lock();
     bool r = invoke_http_json("/get_unspent_outs", oreq, ores, rpc_timeout, "POST");
     m_daemon_rpc_mutex.unlock();
@@ -9196,7 +10603,8 @@ void wallet2::light_wallet_get_unspent_outs()
     // Clear old outputs
     m_transfers.clear();
 
-  for (const auto &o: ores.outputs) {
+    for (const auto &o : ores.outputs)
+    {
       bool spent = false;
       bool add_transfer = true;
       crypto::key_image unspent_key_image;
@@ -9204,17 +10612,20 @@ void wallet2::light_wallet_get_unspent_outs()
       THROW_WALLET_EXCEPTION_IF(string_tools::validate_hex(64, o.tx_pub_key), error::wallet_internal_error, "Invalid tx_pub_key field");
       string_tools::hex_to_pod(o.tx_pub_key, tx_public_key);
 
-    for (const std::string &ski: o.spend_key_images) {
+      for (const std::string &ski : o.spend_key_images)
+      {
         spent = false;
 
         // Check if key image is ours
         THROW_WALLET_EXCEPTION_IF(string_tools::validate_hex(64, ski), error::wallet_internal_error, "Invalid key image");
         string_tools::hex_to_pod(ski, unspent_key_image);
-      if(light_wallet_key_image_is_ours(unspent_key_image, tx_public_key, o.index)){
+        if (light_wallet_key_image_is_ours(unspent_key_image, tx_public_key, o.index))
+        {
           MTRACE("Output " << o.public_key << " is spent. Key image: " << ski);
           spent = true;
           break;
-      } {
+        }
+        {
           MTRACE("Unspent output found. " << o.public_key);
         }
       }
@@ -9230,8 +10641,10 @@ void wallet2::light_wallet_get_unspent_outs()
       string_tools::hex_to_pod(o.public_key, public_key);
       string_tools::hex_to_pod(o.tx_pub_key, tx_pub_key);
 
-    for(auto &t: m_transfers){
-      if(t.get_public_key() == public_key) {
+      for (auto &t : m_transfers)
+      {
+        if (t.get_public_key() == public_key)
+        {
           t.m_spent = spent;
           add_transfer = false;
           break;
@@ -9344,7 +10757,6 @@ void wallet2::light_wallet_get_address_txs()
     //OpenMonero sends status=success, Mymonero doesn't.
     THROW_WALLET_EXCEPTION_IF((!ires.status.empty() && ires.status != "success"), error::no_connection_to_daemon, "get_address_txs");
 
-  
     // Abort if no transactions
     if (ires.transactions.empty())
       return;
@@ -9362,7 +10774,8 @@ void wallet2::light_wallet_get_address_txs()
     // txs in pool
     std::vector<crypto::hash> pool_txs;
 
-  for (const auto &t: ires.transactions) {
+    for (const auto &t : ires.transactions)
+    {
       const uint64_t total_received = t.total_received;
       uint64_t total_sent = t.total_sent;
 
@@ -9376,7 +10789,8 @@ void wallet2::light_wallet_get_address_txs()
         string_tools::hex_to_pod(so.tx_pub_key, tx_public_key);
         string_tools::hex_to_pod(so.key_image, key_image);
 
-      if(!light_wallet_key_image_is_ours(key_image, tx_public_key, so.out_index)) {
+        if (!light_wallet_key_image_is_ours(key_image, tx_public_key, so.out_index))
+        {
           THROW_WALLET_EXCEPTION_IF(so.amount > t.total_sent, error::wallet_internal_error, "Lightwallet: total sent is negative!");
           total_sent -= so.amount;
         }
@@ -9400,7 +10814,7 @@ void wallet2::light_wallet_get_address_txs()
       address_tx.m_tx_hash = tx_hash;
       address_tx.m_incoming = incoming;
       address_tx.m_amount = incoming ? total_received - total_sent : total_sent - total_received;
-    address_tx.m_fee = 0;                 // TODO
+      address_tx.m_fee = 0;
       address_tx.m_block_height = t.height;
       address_tx.m_unlock_time = t.unlock_time;
       address_tx.m_timestamp = t.timestamp;
@@ -9410,7 +10824,8 @@ void wallet2::light_wallet_get_address_txs()
 
       // populate data needed for history (m_payments, m_unconfirmed_payments, m_confirmed_txs)
       // INCOMING transfers
-    if(total_received > total_sent) {
+      if (total_received > total_sent)
+      {
         payment_details payment;
         payment.m_tx_hash = tx_hash;
         payment.m_amount = total_received - total_sent;
@@ -9419,29 +10834,39 @@ void wallet2::light_wallet_get_address_txs()
         payment.m_unlock_time = t.unlock_time;
         payment.m_timestamp = t.timestamp;
         payment.m_coinbase = t.coinbase;
+        payment.m_offshore = false;
 
-      if (t.mempool) {   
-        if (std::find(unconfirmed_payments_txs.begin(), unconfirmed_payments_txs.end(), tx_hash) == unconfirmed_payments_txs.end()) {
+        if (t.mempool)
+        {
+          if (std::find(unconfirmed_payments_txs.begin(), unconfirmed_payments_txs.end(), tx_hash) == unconfirmed_payments_txs.end())
+          {
             pool_txs.push_back(tx_hash);
             // assume false as we don't get that info from the light wallet server
             crypto::hash payment_id;
             THROW_WALLET_EXCEPTION_IF(!epee::string_tools::hex_to_pod(t.payment_id, payment_id),
                                       error::wallet_internal_error, "Failed to parse payment id");
             emplace_or_replace(m_unconfirmed_payments, payment_id, pool_payment_details{payment, false});
-          if (0 != m_callback) {
+            if (0 != m_callback)
+            {
               m_callback->on_lw_unconfirmed_money_received(t.height, payment.m_tx_hash, payment.m_amount);
             }
           }
-      } else {
-        if (std::find(payments_txs.begin(), payments_txs.end(), tx_hash) == payments_txs.end()) {
+        }
+        else
+        {
+          if (std::find(payments_txs.begin(), payments_txs.end(), tx_hash) == payments_txs.end())
+          {
             m_payments.emplace(tx_hash, payment);
-          if (0 != m_callback) {
+            if (0 != m_callback)
+            {
               m_callback->on_lw_money_received(t.height, payment.m_tx_hash, payment.m_amount);
             }
           }
         }
         // Outgoing transfers
-    } else {
+      }
+      else
+      {
         uint64_t amount_sent = total_sent - total_received;
         cryptonote::transaction dummy_tx; // not used by light wallet
         // increase wallet total sent
@@ -9466,7 +10891,8 @@ void wallet2::light_wallet_get_address_txs()
         {
           // Only add if new
           auto confirmed_tx = m_confirmed_txs.find(tx_hash);
-        if(confirmed_tx == m_confirmed_txs.end()) {
+          if (confirmed_tx == m_confirmed_txs.end())
+          {
             // tx is added to m_unconfirmed_txs - move to confirmed
             if (m_unconfirmed_txs.find(tx_hash) != m_unconfirmed_txs.end())
             {
@@ -9529,7 +10955,8 @@ bool wallet2::light_wallet_parse_rct_str(const std::string& rct_string, const cr
     THROW_WALLET_EXCEPTION_IF(string_tools::validate_hex(64, encrypted_mask_str), error::wallet_internal_error, "Invalid rct mask: " + encrypted_mask_str);
     string_tools::hex_to_pod(rct_commit_str, rct_commit);
     string_tools::hex_to_pod(encrypted_mask_str, encrypted_mask);
-  if (decrypt) {
+    if (decrypt)
+    {
       // Decrypt the mask
       crypto::key_derivation derivation;
       bool r = generate_key_derivation(tx_pub_key, get_account().get_keys().m_view_secret_key, derivation);
@@ -9546,7 +10973,8 @@ bool wallet2::light_wallet_key_image_is_ours(const crypto::key_image& key_image,
     // Lookup key image from cache
     std::map<uint64_t, crypto::key_image> index_keyimage_map;
     std::unordered_map<crypto::public_key, std::map<uint64_t, crypto::key_image>>::const_iterator found_pub_key = m_key_image_cache.find(tx_public_key);
-  if(found_pub_key != m_key_image_cache.end()) {
+    if (found_pub_key != m_key_image_cache.end())
+    {
       // pub key found. key image for index cached?
       index_keyimage_map = found_pub_key->second;
       std::map<uint64_t, crypto::key_image>::const_iterator index_found = index_keyimage_map.find(out_index);
@@ -9608,7 +11036,8 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
 
     auto original_dsts = dsts;
 
-  if(m_light_wallet) {
+    if (m_light_wallet)
+    {
       // Populate m_transfers
       light_wallet_get_unspent_outs();
     }
@@ -9616,7 +11045,8 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
     std::vector<std::pair<uint32_t, std::vector<size_t>>> unused_dust_indices_per_subaddr;
     uint64_t needed_money;
     uint64_t accumulated_fee, accumulated_outputs, accumulated_change;
-  struct TX {
+    struct TX
+    {
       std::vector<size_t> selected_transfers;
       std::vector<cryptonote::tx_destination_entry> dsts;
       cryptonote::transaction tx;
@@ -9627,7 +11057,8 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
 
       TX() : weight(0), needed_fee(0) {}
 
-    void add(const cryptonote::tx_destination_entry &de, uint64_t amount, unsigned int original_output_index, bool merge_destinations) {
+      void add(const cryptonote::tx_destination_entry &de, uint64_t amount, uint64_t amount_usd, unsigned int original_output_index, bool merge_destinations)
+      {
         if (merge_destinations)
         {
           std::vector<cryptonote::tx_destination_entry>::iterator i;
@@ -9637,8 +11068,10 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
             dsts.push_back(de);
             i = dsts.end() - 1;
             i->amount = 0;
+            i->amount_usd = 0;
           }
           i->amount += amount;
+          i->amount_usd += amount_usd;
         }
         else
         {
@@ -9648,9 +11081,11 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
           {
             dsts.push_back(de);
             dsts.back().amount = 0;
+            dsts.back().amount_usd = 0;
           }
           THROW_WALLET_EXCEPTION_IF(memcmp(&dsts[original_output_index].addr, &de.addr, sizeof(de.addr)), error::wallet_internal_error, "Mismatched destination address");
           dsts[original_output_index].amount += amount;
+          dsts[original_output_index].amount_usd += amount_usd;
         }
       }
     };
@@ -9661,10 +11096,47 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
     const bool use_per_byte_fee = use_fork_rules(HF_VERSION_PER_BYTE_FEE, 0);
     const bool use_rct = use_fork_rules(4, 0);
     const bool bulletproof = use_fork_rules(get_bulletproof_fork(), 0);
+    const bool clsag = use_fork_rules(get_clsag_fork(), 0);
     const rct::RCTConfig rct_config{
         bulletproof ? rct::RangeProofPaddedBulletproof : rct::RangeProofBorromean,
-    bulletproof ? (use_fork_rules(HF_VERSION_SMALLER_BP, -10) ? 2 : 1) : 0
-  };
+        bulletproof ? (use_fork_rules(HF_VERSION_CLSAG, 0) ? 3 : (use_fork_rules(HF_VERSION_SMALLER_BP, -10) ? 2 : 1)) : 0};
+
+    bool bOffshoreTx = false;
+    tx_extra_offshore offshore_data;
+    if (extra.size())
+    {
+      // Check to see if this is an offshore tx
+      bOffshoreTx = get_offshore_from_tx_extra(extra, offshore_data);
+    }
+
+    bool offshore = false;
+    bool onshore = false;
+    bool offshore_to_offshore = false;
+    if (bOffshoreTx)
+    {
+
+      // HERE BE DRAGONS!!!
+      // Filter out the offshore information?
+      //remove_field_from_tx_extra(tx.extra, typeid(tx_extra_offshore));
+      // LAND AHOY!!!
+
+      // Set the bool flags
+      if ((offshore_data.data.at(0) > 'A') && (offshore_data.data.at(1) > 'A'))
+      {
+        offshore_to_offshore = true;
+      }
+      else if (offshore_data.data.at(0) > 'A')
+      {
+        onshore = true;
+      }
+      else
+      {
+        offshore = true;
+      }
+    }
+
+    const bool use_offshore_outputs = onshore || offshore_to_offshore;
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
 
     const uint64_t base_fee = get_base_fee();
     const uint64_t fee_multiplier = get_fee_multiplier(priority, get_fee_algorithm());
@@ -9673,22 +11145,75 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
     // throw if attempting a transaction with no destinations
     THROW_WALLET_EXCEPTION_IF(dsts.empty(), error::zero_destination);
 
-  // calculate total amount being sent to all destinations
+    // calculate total amount being sent to all destinations IN THE CORRECT CURRENCY
     // throw if total amount overflows uint64_t
+    uint64_t current_height = get_blockchain_current_height() - 1;
     needed_money = 0;
     for (auto &dt : dsts)
     {
       THROW_WALLET_EXCEPTION_IF(0 == dt.amount, error::zero_destination);
+      if (offshore || onshore)
+      {
+        // Only permit input amounts to 4 decimal places, to avoid precision / truncation errors
+        THROW_WALLET_EXCEPTION_IF(dt.amount % 100000000, error::wallet_internal_error, "Offshore TX amounts permit at most 4 decimal places");
+      }
+
+      if (offshore)
+      {
+        // Input amount is in XHV - convert so we have both
+        dt.amount_usd = get_xusd_amount(dt.amount, current_height);
+        THROW_WALLET_EXCEPTION_IF(dt.amount_usd == 0, error::wallet_internal_error, "Failed to convert needed_money to xUSD");
+        needed_money += dt.amount;
+        LOG_PRINT_L2("transfer: adding " << print_money(dt.amount) << ", for a total of " << print_money(needed_money));
+        THROW_WALLET_EXCEPTION_IF(needed_money < dt.amount, error::tx_sum_overflow, dsts, 0, m_nettype);
+      }
+      else if (onshore)
+      {
+        // Input amount is in XHV - convert so we have both
+        dt.amount_usd = get_xusd_amount(dt.amount, current_height);
+        THROW_WALLET_EXCEPTION_IF(dt.amount_usd == 0, error::wallet_internal_error, "Failed to convert needed_money back to xUSD");
+        needed_money += dt.amount_usd;
+        LOG_PRINT_L2("transfer: adding " << print_money(dt.amount_usd) << ", for a total of " << print_money(needed_money));
+        THROW_WALLET_EXCEPTION_IF(needed_money < dt.amount_usd, error::tx_sum_overflow, dsts, 0, m_nettype);
+      }
+      else if (offshore_to_offshore)
+      {
+        // Input amount is in USD
+        dt.amount_usd = dt.amount;
+        dt.amount = 0;
+        needed_money += dt.amount_usd;
+        LOG_PRINT_L2("transfer: adding " << print_money(dt.amount_usd) << ", for a total of " << print_money(needed_money));
+        THROW_WALLET_EXCEPTION_IF(needed_money < dt.amount_usd, error::tx_sum_overflow, dsts, 0, m_nettype);
+      }
+      else
+      {
+        // Input amount is in XHV
         needed_money += dt.amount;
         LOG_PRINT_L2("transfer: adding " << print_money(dt.amount) << ", for a total of " << print_money(needed_money));
         THROW_WALLET_EXCEPTION_IF(needed_money < dt.amount, error::tx_sum_overflow, dsts, 0, m_nettype);
       }
+    }
 
     // throw if attempting a transaction with no money
     THROW_WALLET_EXCEPTION_IF(needed_money == 0, error::zero_destination);
 
-  std::map<uint32_t, std::pair<uint64_t, std::pair<uint64_t, uint64_t>>> unlocked_balance_per_subaddr = unlocked_balance_per_subaddress(subaddr_account, false);
-  std::map<uint32_t, uint64_t> balance_per_subaddr = balance_per_subaddress(subaddr_account, false);
+    // Calculate the offshore fee
+    std::vector<transfer_details> empty;
+    uint64_t offshore_fee = (offshore) ? get_offshore_fee(dsts, priority, empty) : (onshore) ? get_onshore_fee(dsts, priority, empty) : 0;
+
+    std::map<uint32_t, std::pair<uint64_t, std::pair<uint64_t, uint64_t>>> unlocked_balance_per_subaddr;
+    std::map<uint32_t, uint64_t> balance_per_subaddr;
+
+    if (onshore || offshore_to_offshore)
+    {
+      unlocked_balance_per_subaddr = unlocked_offshore_balance_per_subaddress(subaddr_account, false);
+      balance_per_subaddr = offshore_balance_per_subaddress(subaddr_account, false);
+    }
+    else
+    {
+      unlocked_balance_per_subaddr = unlocked_balance_per_subaddress(subaddr_account, false);
+      balance_per_subaddr = balance_per_subaddress(subaddr_account, false);
+    }
 
     if (subaddr_indices.empty()) // "index=<N1>[,<N2>,...]" wasn't specified -> use all the indices with non-zero unlocked balance
     {
@@ -9699,7 +11224,7 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
     // early out if we know we can't make it anyway
     // we could also check for being within FEE_PER_KB, but if the fee calculation
     // ever changes, this might be missed, so let this go through
-  const uint64_t min_fee = (fee_multiplier * base_fee * estimate_tx_size(use_rct, 1, fake_outs_count, 2, extra.size(), bulletproof));
+    const uint64_t min_fee = fee_multiplier * base_fee * estimate_tx_size(use_rct, 1, fake_outs_count, 2, extra.size(), bulletproof, clsag);
     uint64_t balance_subtotal = 0;
     uint64_t unlocked_balance_subtotal = 0;
     for (uint32_t index_minor : subaddr_indices)
@@ -9707,18 +11232,18 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
       balance_subtotal += balance_per_subaddr[index_minor];
       unlocked_balance_subtotal += unlocked_balance_per_subaddr[index_minor].first;
     }
-  THROW_WALLET_EXCEPTION_IF(needed_money + min_fee > balance_subtotal, error::not_enough_money,
+    THROW_WALLET_EXCEPTION_IF(needed_money + min_fee + offshore_fee > balance_subtotal, error::not_enough_money,
                               balance_subtotal, needed_money, 0);
     // first check overall balance is enough, then unlocked one, so we throw distinct exceptions
-  THROW_WALLET_EXCEPTION_IF(needed_money + min_fee > unlocked_balance_subtotal, error::not_enough_unlocked_money,
+    THROW_WALLET_EXCEPTION_IF(needed_money + min_fee + offshore_fee > unlocked_balance_subtotal, error::not_enough_unlocked_money,
                               unlocked_balance_subtotal, needed_money, 0);
 
     for (uint32_t i : subaddr_indices)
       LOG_PRINT_L2("Candidate subaddress index for spending: " << i);
 
     // determine threshold for fractional amount
-  const size_t tx_weight_one_ring = estimate_tx_weight(use_rct, 1, fake_outs_count, 2, 0, bulletproof);
-  const size_t tx_weight_two_rings = estimate_tx_weight(use_rct, 2, fake_outs_count, 2, 0, bulletproof);
+    const size_t tx_weight_one_ring = estimate_tx_weight(use_rct, 1, fake_outs_count, 2, 0, bulletproof, clsag);
+    const size_t tx_weight_two_rings = estimate_tx_weight(use_rct, 2, fake_outs_count, 2, 0, bulletproof, clsag);
     THROW_WALLET_EXCEPTION_IF(tx_weight_one_ring > tx_weight_two_rings, error::wallet_internal_error, "Estimated tx weight with 1 input is larger than with 2 inputs!");
     const size_t tx_weight_per_ring = tx_weight_two_rings - tx_weight_one_ring;
     const uint64_t fractional_threshold = (fee_multiplier * base_fee * tx_weight_per_ring) / (use_per_byte_fee ? 1 : 1024);
@@ -9726,9 +11251,9 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
     // gather all dust and non-dust outputs belonging to specified subaddresses
     size_t num_nondust_outputs = 0;
     size_t num_dust_outputs = 0;
-  for (size_t i = 0; i < m_transfers.size(); ++i)
+    for (size_t i = 0; i < specific_transfers.size(); ++i)
     {
-    const transfer_details& td = m_transfers[i];
+      const transfer_details &td = specific_transfers[i];
       if (m_ignore_fractional_outputs && td.amount() < fractional_threshold)
       {
         MDEBUG("Ignoring output " << i << " of amount " << print_money(td.amount()) << " which is below fractional threshold " << print_money(fractional_threshold));
@@ -9774,8 +11299,7 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
 
     // sort output indices
     {
-    auto sort_predicate = [&unlocked_balance_per_subaddr] (const std::pair<uint32_t, std::vector<size_t>>& x, const std::pair<uint32_t, std::vector<size_t>>& y)
-    {
+      auto sort_predicate = [&unlocked_balance_per_subaddr](const std::pair<uint32_t, std::vector<size_t>> &x, const std::pair<uint32_t, std::vector<size_t>> &y) {
         return unlocked_balance_per_subaddr[x.first].first > unlocked_balance_per_subaddr[y.first].first;
       };
       std::sort(unused_transfers_indices_per_subaddr.begin(), unused_transfers_indices_per_subaddr.end(), sort_predicate);
@@ -9815,16 +11339,18 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
     {
       // this is used to build a tx that's 1 or 2 inputs, and 2 outputs, which
       // will get us a known fee.
-    uint64_t estimated_fee = estimate_fee(use_per_byte_fee, use_rct, 2, fake_outs_count, 2, extra.size(), bulletproof, base_fee, fee_multiplier, fee_quantization_mask);
-    preferred_inputs = pick_preferred_rct_inputs(needed_money + estimated_fee, subaddr_account, subaddr_indices);
+      uint64_t estimated_fee = estimate_fee(use_per_byte_fee, use_rct, 2, fake_outs_count, 2, extra.size(), bulletproof, clsag, base_fee, fee_multiplier, fee_quantization_mask);
+      estimated_fee += offshore_fee;
+      preferred_inputs = pick_preferred_rct_inputs(needed_money + estimated_fee, subaddr_account, subaddr_indices, use_offshore_outputs);
       if (!preferred_inputs.empty())
       {
         string s;
-      for (auto i: preferred_inputs) s += boost::lexical_cast<std::string>(i) + " (" + print_money(m_transfers[i].amount()) + ") ";
+        for (auto i : preferred_inputs)
+          s += boost::lexical_cast<std::string>(i) + " (" + print_money(specific_transfers[i].amount()) + ") ";
         LOG_PRINT_L1("Found preferred rct inputs for rct tx: " << s);
 
         // bring the list of available outputs stored by the same subaddress index to the front of the list
-      uint32_t index_minor = m_transfers[preferred_inputs[0]].m_subaddr_index.minor;
+        uint32_t index_minor = specific_transfers[preferred_inputs[0]].m_subaddr_index.minor;
         for (size_t i = 1; i < unused_transfers_indices_per_subaddr.size(); ++i)
         {
           if (unused_transfers_indices_per_subaddr[i].first == index_minor)
@@ -9854,32 +11380,37 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
     std::vector<size_t> *unused_dust_indices = &unused_dust_indices_per_subaddr[0].second;
 
     hwdev.set_mode(hw::device::TRANSACTION_CREATE_FAKE);
-  while ((!dsts.empty() && dsts[0].amount > 0) || adding_fee || !preferred_inputs.empty() || should_pick_a_second_output(use_rct, txes.back().selected_transfers.size(), *unused_transfers_indices, *unused_dust_indices)) {
+    while ((!dsts.empty() && (use_offshore_outputs ? dsts[0].amount_usd : dsts[0].amount) > 0) || adding_fee || !preferred_inputs.empty() || should_pick_a_second_output(use_rct, txes.back().selected_transfers.size(), *unused_transfers_indices, *unused_dust_indices, specific_transfers))
+    {
       TX &tx = txes.back();
 
       LOG_PRINT_L2("Start of loop with " << unused_transfers_indices->size() << " " << unused_dust_indices->size() << ", tx.dsts.size() " << tx.dsts.size());
       LOG_PRINT_L2("unused_transfers_indices: " << strjoin(*unused_transfers_indices, " "));
       LOG_PRINT_L2("unused_dust_indices: " << strjoin(*unused_dust_indices, " "));
-    LOG_PRINT_L2("dsts size " << dsts.size() << ", first " << (dsts.empty() ? "-" : cryptonote::print_money(dsts[0].amount)));
+      LOG_PRINT_L2("dsts size " << dsts.size() << ", first " << (dsts.empty() ? "-" : cryptonote::print_money((use_offshore_outputs ? dsts[0].amount_usd : dsts[0].amount))));
       LOG_PRINT_L2("adding_fee " << adding_fee << ", use_rct " << use_rct);
 
       // if we need to spend money and don't have any left, we fail
-    if (unused_dust_indices->empty() && unused_transfers_indices->empty()) {
+      if (unused_dust_indices->empty() && unused_transfers_indices->empty())
+      {
         LOG_PRINT_L2("No more outputs to choose from");
-      THROW_WALLET_EXCEPTION_IF(1, error::tx_not_possible, unlocked_balance(subaddr_account, false), needed_money, accumulated_fee + needed_fee);
+        THROW_WALLET_EXCEPTION_IF(1, error::tx_not_possible, (use_offshore_outputs ? unlocked_offshore_balance(subaddr_account, false) : unlocked_balance(subaddr_account, false)), needed_money, accumulated_fee + needed_fee + offshore_fee);
       }
 
       // get a random unspent output and use it to pay part (or all) of the current destination (and maybe next one, etc)
       // This could be more clever, but maybe at the cost of making probabilistic inferences easier
       size_t idx;
-    if (!preferred_inputs.empty()) {
+      if (!preferred_inputs.empty())
+      {
         idx = pop_back(preferred_inputs);
         pop_if_present(*unused_transfers_indices, idx);
         pop_if_present(*unused_dust_indices, idx);
-    } else if ((dsts.empty() || dsts[0].amount == 0) && !adding_fee) {
+      }
+      else if ((dsts.empty() || (use_offshore_outputs ? dsts[0].amount_usd : dsts[0].amount) == 0) && !adding_fee)
+      {
         // the "make rct txes 2/2" case - we pick a small value output to "clean up" the wallet too
-      std::vector<size_t> indices = get_only_rct(*unused_dust_indices, *unused_transfers_indices);
-      idx = pop_best_value(indices, tx.selected_transfers, true);
+        std::vector<size_t> indices = get_only_rct(*unused_dust_indices, *unused_transfers_indices, use_offshore_outputs);
+        idx = pop_best_value(indices, tx.selected_transfers, true, use_offshore_outputs);
 
         // we might not want to add it if it's a large output and we don't have many left
         uint64_t min_output_value = m_min_output_value;
@@ -9889,8 +11420,10 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
           min_output_value = DEFAULT_MIN_OUTPUT_VALUE;
           min_output_count = DEFAULT_MIN_OUTPUT_COUNT;
         }
-      if (m_transfers[idx].amount() >= min_output_value) {
-        if (get_count_above(m_transfers, *unused_transfers_indices, min_output_value) < min_output_count) {
+        if (specific_transfers[idx].amount() >= min_output_value)
+        {
+          if (get_count_above(specific_transfers, *unused_transfers_indices, min_output_value) < min_output_count)
+          {
             LOG_PRINT_L2("Second output was not strictly needed, and we're running out of outputs above " << print_money(min_output_value) << ", not adding");
             break;
           }
@@ -9898,7 +11431,7 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
 
         // since we're trying to add a second output which is not strictly needed,
         // we only add it if it's unrelated enough to the first one
-      float relatedness = get_output_relatedness(m_transfers[idx], m_transfers[tx.selected_transfers.front()]);
+        float relatedness = get_output_relatedness(specific_transfers[idx], specific_transfers[tx.selected_transfers.front()]);
         if (relatedness > SECOND_OUTPUT_RELATEDNESS_THRESHOLD)
         {
           LOG_PRINT_L2("Second output was not strictly needed, and relatedness " << relatedness << ", not adding");
@@ -9906,10 +11439,11 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
         }
         pop_if_present(*unused_transfers_indices, idx);
         pop_if_present(*unused_dust_indices, idx);
-    } else
-      idx = pop_best_value(unused_transfers_indices->empty() ? *unused_dust_indices : *unused_transfers_indices, tx.selected_transfers);
+      }
+      else
+        idx = pop_best_value(unused_transfers_indices->empty() ? *unused_dust_indices : *unused_transfers_indices, tx.selected_transfers, use_offshore_outputs);
 
-    const transfer_details &td = m_transfers[idx];
+      const transfer_details &td = specific_transfers[idx];
       LOG_PRINT_L2("Picking output " << idx << ", amount " << print_money(td.amount()) << ", ki " << td.m_key_image);
 
       // add this output to the list to spend
@@ -9927,24 +11461,31 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
       }
       else
       {
-      while (!dsts.empty() && dsts[0].amount <= available_amount && estimate_tx_weight(use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size()+1, extra.size(), bulletproof) < TX_WEIGHT_TARGET(upper_transaction_weight_limit))
+        while (!dsts.empty() && (use_offshore_outputs ? dsts[0].amount_usd : dsts[0].amount) <= available_amount && estimate_tx_weight(use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size() + 1, extra.size(), bulletproof, clsag) < TX_WEIGHT_TARGET(upper_transaction_weight_limit))
         {
           // we can fully pay that destination
-        LOG_PRINT_L2("We can fully pay " << get_account_address_as_str(m_nettype, dsts[0].is_subaddress, dsts[0].addr) <<
-          " for " << print_money(dsts[0].amount));
-        tx.add(dsts[0], dsts[0].amount, original_output_index, m_merge_destinations);
-        available_amount -= dsts[0].amount;
-        dsts[0].amount = 0;
+          LOG_PRINT_L2("We can fully pay " << get_account_address_as_str(m_nettype, dsts[0].is_subaddress, dsts[0].addr) << " for " << print_money((use_offshore_outputs ? dsts[0].amount_usd : dsts[0].amount)));
+          tx.add(dsts[0], dsts[0].amount, dsts[0].amount_usd, original_output_index, m_merge_destinations);
+          available_amount -= (use_offshore_outputs ? dsts[0].amount_usd : dsts[0].amount);
+          (use_offshore_outputs ? dsts[0].amount_usd : dsts[0].amount) = 0;
+          if (offshore)
+          {
+            tx.dsts.back().amount_usd = get_xusd_amount(tx.dsts.back().amount, current_height);
+          }
+          else if (onshore)
+          {
+            tx.dsts.back().amount = get_xhv_amount(tx.dsts.back().amount_usd, current_height);
+          }
           pop_index(dsts, 0);
           ++original_output_index;
         }
 
-      if (available_amount > 0 && !dsts.empty() && estimate_tx_weight(use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size()+1, extra.size(), bulletproof) < TX_WEIGHT_TARGET(upper_transaction_weight_limit)) {
+        if (available_amount > 0 && !dsts.empty() && estimate_tx_weight(use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size() + 1, extra.size(), bulletproof, clsag) < TX_WEIGHT_TARGET(upper_transaction_weight_limit))
+        {
           // we can partially fill that destination
-        LOG_PRINT_L2("We can partially pay " << get_account_address_as_str(m_nettype, dsts[0].is_subaddress, dsts[0].addr) <<
-          " for " << print_money(available_amount) << "/" << print_money(dsts[0].amount));
-        tx.add(dsts[0], available_amount, original_output_index, m_merge_destinations);
-        dsts[0].amount -= available_amount;
+          LOG_PRINT_L2("We can partially pay " << get_account_address_as_str(m_nettype, dsts[0].is_subaddress, dsts[0].addr) << " for " << print_money(available_amount) << "/" << print_money((dsts[0].amount > 0) ? dsts[0].amount : dsts[0].amount_usd));
+          tx.add(dsts[0], (use_offshore_outputs ? 0 : available_amount), (use_offshore_outputs ? available_amount : 0), original_output_index, m_merge_destinations);
+          (use_offshore_outputs ? dsts[0].amount_usd : dsts[0].amount) -= available_amount;
           available_amount = 0;
         }
       }
@@ -9959,48 +11500,78 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
         if (adding_fee)
         {
           /* might not actually be enough if adding this output bumps size to next kB, but we need to try */
-        try_tx = available_for_fee >= needed_fee;
+          try_tx = available_for_fee >= needed_fee + offshore_fee;
         }
         else
         {
-        const size_t estimated_rct_tx_weight = estimate_tx_weight(use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size()+1, extra.size(), bulletproof);
+          const size_t estimated_rct_tx_weight = estimate_tx_weight(use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size() + 1, extra.size(), bulletproof, clsag);
           try_tx = dsts.empty() || (estimated_rct_tx_weight >= TX_WEIGHT_TARGET(upper_transaction_weight_limit));
           THROW_WALLET_EXCEPTION_IF(try_tx && tx.dsts.empty(), error::tx_too_big, estimated_rct_tx_weight, upper_transaction_weight_limit);
         }
       }
 
-    if (try_tx) {
+      if (try_tx)
+      {
         cryptonote::transaction test_tx;
         pending_tx test_ptx;
 
-      needed_fee = estimate_fee(use_per_byte_fee, use_rct ,tx.selected_transfers.size(), fake_outs_count, tx.dsts.size()+1, extra.size(), bulletproof, base_fee, fee_multiplier, fee_quantization_mask);
-
-      uint64_t inputs = 0, outputs = needed_fee;
-      for (size_t idx: tx.selected_transfers) inputs += m_transfers[idx].amount();
-      for (const auto &o: tx.dsts) outputs += o.amount;
+        needed_fee = estimate_fee(use_per_byte_fee, use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size() + 1, extra.size(), bulletproof, clsag, base_fee, fee_multiplier, fee_quantization_mask);
+        uint64_t inputs = 0;
+        uint64_t outputs = 0;
+        std::vector<transfer_details> fee_sources;
+        for (size_t idx : tx.selected_transfers)
+        {
+          inputs += specific_transfers[idx].amount();
+          fee_sources.push_back(specific_transfers[idx]);
+        }
+        for (const auto &o : tx.dsts)
+          outputs += ((onshore || offshore_to_offshore) ? o.amount_usd : o.amount);
+        offshore_fee = (offshore) ? get_offshore_fee(tx.dsts, priority, fee_sources) : (onshore) ? get_onshore_fee(tx.dsts, priority, fee_sources) : 0;
+        needed_fee += offshore_fee;
 
-      if (inputs < outputs)
+        if (inputs < outputs + needed_fee)
         {
           LOG_PRINT_L2("We don't have enough for the basic fee, switching to adding_fee");
           adding_fee = true;
           goto skip_tx;
         }
 
-      LOG_PRINT_L2("Trying to create a tx now, with " << tx.dsts.size() << " outputs and " <<
-        tx.selected_transfers.size() << " inputs");
+        // HERE BE DRAGONS!!!
+        // NEAC: Adjust the TX dsts here if necessary
+        LOG_PRINT_L1("inputs = " << inputs << ", outputs = " << outputs);
+        if (offshore || onshore)
+        {
+          uint64_t adjustment = (tx.dsts.back().amount % 100000000);
+          tx.dsts.back().amount -= adjustment;
+          tx.dsts.back().amount_usd = get_xusd_amount(tx.dsts.back().amount, current_height);
+          dsts[0].amount += adjustment;
+          outputs -= adjustment;
+        }
+        if (offshore)
+        {
+          THROW_WALLET_EXCEPTION_IF(outputs % 100000000, error::wallet_internal_error, "This transaction will fail because the amounts are incorrect!");
+        }
+        else if (onshore)
+        {
+          THROW_WALLET_EXCEPTION_IF(outputs % 10000, error::wallet_internal_error, "This transaction will fail because the amounts are incorrect!");
+        }
+        // LAND AHOY!!!
+
+        LOG_PRINT_L2("Trying to create a tx now, with " << tx.dsts.size() << " outputs and " << tx.selected_transfers.size() << " inputs");
         if (use_rct)
           transfer_selected_rct(tx.dsts, tx.selected_transfers, fake_outs_count, outs, unlock_time, needed_fee, extra,
-          test_tx, test_ptx, rct_config);
+                                test_tx, test_ptx, rct_config, offshore, onshore, offshore_to_offshore);
         else
           transfer_selected(tx.dsts, tx.selected_transfers, fake_outs_count, outs, unlock_time, needed_fee, extra,
                             detail::digit_split_strategy, tx_dust_policy(::config::DEFAULT_DUST_THRESHOLD), test_tx, test_ptx);
         auto txBlob = t_serializable_object_to_blob(test_ptx.tx);
         needed_fee = calculate_fee(use_per_byte_fee, test_ptx.tx, txBlob.size(), base_fee, fee_multiplier, fee_quantization_mask);
-      available_for_fee = test_ptx.fee + test_ptx.change_dts.amount + (!test_ptx.dust_added_to_fee ? test_ptx.dust : 0);
-      LOG_PRINT_L2("Made a " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(available_for_fee) << " available for fee (" <<
-        print_money(needed_fee) << " needed)");
+        available_for_fee = test_ptx.fee + ((onshore || offshore_to_offshore) ? test_ptx.change_dts.amount_usd : test_ptx.change_dts.amount) + (!test_ptx.dust_added_to_fee ? test_ptx.dust : 0);
+        LOG_PRINT_L2("Made a " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(available_for_fee) << " available for fee (" << print_money(needed_fee + offshore_fee) << " needed)");
 
-      if (needed_fee > available_for_fee && !dsts.empty() && dsts[0].amount > 0)
+        // HERE BE DRAGONS!!!
+        // NEAC: think the following block of code doesn't account for offshore amounts in the dsts vector...
+        if (needed_fee + offshore_fee > available_for_fee && !dsts.empty() && (dsts[0].amount > 0))
         {
           // we don't have enough for the fee, but we've only partially paid the current address,
           // so we can take the fee from the paid amount, since we'll have to make another tx anyway
@@ -10011,15 +11582,14 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
           if (i->amount > needed_fee)
           {
             uint64_t new_paid_amount = i->amount /*+ test_ptx.fee*/ - needed_fee;
-          LOG_PRINT_L2("Adjusting amount paid to " << get_account_address_as_str(m_nettype, i->is_subaddress, i->addr) << " from " <<
-            print_money(i->amount) << " to " << print_money(new_paid_amount) << " to accommodate " <<
-            print_money(needed_fee) << " fee");
+            LOG_PRINT_L2("Adjusting amount paid to " << get_account_address_as_str(m_nettype, i->is_subaddress, i->addr) << " from " << print_money(i->amount) << " to " << print_money(new_paid_amount) << " to accommodate " << print_money(needed_fee) << " fee");
             dsts[0].amount += i->amount - new_paid_amount;
             i->amount = new_paid_amount;
             test_ptx.fee = needed_fee;
             available_for_fee = needed_fee;
           }
         }
+        // LAND AHOY!!!
 
         if (needed_fee > available_for_fee)
         {
@@ -10030,21 +11600,27 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
         else
         {
           LOG_PRINT_L2("We made a tx, adjusting fee and saving it, we need " << print_money(needed_fee) << " and we have " << print_money(test_ptx.fee));
-        while (needed_fee > test_ptx.fee) {
+          while (needed_fee > test_ptx.fee)
+          {
             if (use_rct)
               transfer_selected_rct(tx.dsts, tx.selected_transfers, fake_outs_count, outs, unlock_time, needed_fee, extra,
-              test_tx, test_ptx, rct_config);
+                                    test_tx, test_ptx, rct_config, offshore, onshore, offshore_to_offshore);
             else
               transfer_selected(tx.dsts, tx.selected_transfers, fake_outs_count, outs, unlock_time, needed_fee, extra,
                                 detail::digit_split_strategy, tx_dust_policy(::config::DEFAULT_DUST_THRESHOLD), test_tx, test_ptx);
             txBlob = t_serializable_object_to_blob(test_ptx.tx);
             needed_fee = calculate_fee(use_per_byte_fee, test_ptx.tx, txBlob.size(), base_fee, fee_multiplier, fee_quantization_mask);
-          LOG_PRINT_L2("Made an attempt at a  final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) <<
-            " fee  and " << print_money(test_ptx.change_dts.amount) << " change");
+            LOG_PRINT_L2("Made an attempt at a  final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) << " fee  and " << print_money(test_ptx.change_dts.amount) << " change");
           }
 
-        LOG_PRINT_L2("Made a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) <<
-          " fee  and " << print_money(test_ptx.change_dts.amount) << " change");
+          if (use_offshore_outputs)
+          {
+            LOG_PRINT_L2("Made a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) << " fee  and " << print_money(test_ptx.change_dts.amount_usd) << " change");
+          }
+          else
+          {
+            LOG_PRINT_L2("Made a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) << " fee  and " << print_money(test_ptx.change_dts.amount) << " change");
+          }
 
           tx.tx = test_tx;
           tx.ptx = test_ptx;
@@ -10066,7 +11642,7 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_2(std::vector<cryp
     skip_tx:
       // if unused_*_indices is empty while unused_*_indices_per_subaddr has multiple elements, and if we still have something to pay,
       // pop front of unused_*_indices_per_subaddr and have unused_*_indices point to the front of unused_*_indices_per_subaddr
-    if ((!dsts.empty() && dsts[0].amount > 0) || adding_fee)
+      if ((!dsts.empty() && (dsts[0].amount > 0)) || adding_fee)
       {
         if (unused_transfers_indices->empty() && unused_transfers_indices_per_subaddr.size() > 1)
         {
@@ -10087,8 +11663,7 @@ skip_tx:
       THROW_WALLET_EXCEPTION_IF(1, error::tx_not_possible, unlocked_balance(subaddr_account, false), needed_money, accumulated_fee + needed_fee);
     }
 
-  LOG_PRINT_L1("Done creating " << txes.size() << " transactions, " << print_money(accumulated_fee) <<
-    " total fee, " << print_money(accumulated_change) << " total change");
+    LOG_PRINT_L1("Done creating " << txes.size() << " transactions, " << print_money(accumulated_fee) << " total fee, " << print_money(accumulated_change) << " total change");
 
     hwdev.set_mode(hw::device::TRANSACTION_CREATE_REAL);
     for (std::vector<TX>::iterator i = txes.begin(); i != txes.end(); ++i)
@@ -10096,7 +11671,9 @@ skip_tx:
       TX &tx = *i;
       cryptonote::transaction test_tx;
       pending_tx test_ptx;
-    if (use_rct) {
+
+      if (use_rct)
+      {
         transfer_selected_rct(tx.dsts,               /* NOMOD std::vector<cryptonote::tx_destination_entry> dsts,*/
                               tx.selected_transfers, /* const std::list<size_t> selected_transfers */
                               fake_outs_count,       /* CONST size_t fake_outputs_count, */
@@ -10106,8 +11683,11 @@ skip_tx:
                               extra,                 /* const std::vector<uint8_t>& extra, */
                               test_tx,               /* OUT   cryptonote::transaction& tx, */
                               test_ptx,              /* OUT   cryptonote::transaction& tx, */
-                            rct_config);
-    } else {
+                              rct_config,
+                              offshore, onshore, offshore_to_offshore);
+      }
+      else
+      {
         transfer_selected(tx.dsts,
                           tx.selected_transfers,
                           fake_outs_count,
@@ -10132,21 +11712,23 @@ skip_tx:
       TX &tx = *i;
       uint64_t tx_money = 0;
       for (size_t idx : tx.selected_transfers)
-      tx_money += m_transfers[idx].amount();
-    LOG_PRINT_L1("  Transaction " << (1+std::distance(txes.begin(), i)) << "/" << txes.size() <<
-      " " << get_transaction_hash(tx.ptx.tx) << ": " << get_weight_string(tx.weight) << ", sending " << print_money(tx_money) << " in " << tx.selected_transfers.size() <<
-      " outputs to " << tx.dsts.size() << " destination(s), including " <<
-      print_money(tx.ptx.fee) << " fee, " << print_money(tx.ptx.change_dts.amount) << " change");
+        tx_money += specific_transfers[idx].amount();
+      LOG_PRINT_L1("  Transaction " << (1 + std::distance(txes.begin(), i)) << "/" << txes.size() << " " << get_transaction_hash(tx.ptx.tx) << ": " << get_weight_string(tx.weight) << ", sending " << print_money(tx_money) << " in " << tx.selected_transfers.size() << " outputs to " << tx.dsts.size() << " destination(s), including " << print_money(tx.ptx.fee) << " fee, " << print_money((use_offshore_outputs ? tx.ptx.change_dts.amount_usd : tx.ptx.change_dts.amount)) << " change");
+
       ptx_vector.push_back(tx.ptx);
     }
 
-  THROW_WALLET_EXCEPTION_IF(!sanity_check(ptx_vector, original_dsts), error::wallet_internal_error, "Created transaction(s) failed sanity check");
+    offshore::pricing_record pr;
+    if (offshore || onshore)
+      bool b = get_pricing_record(pr, ptx_vector.back().tx.pricing_record_height);
+
+    THROW_WALLET_EXCEPTION_IF(!sanity_check(ptx_vector, original_dsts, offshore, onshore, offshore_to_offshore, pr), error::wallet_internal_error, "Created transaction(s) failed sanity check");
 
     // if we made it this far, we're OK to actually send the transactions
     return ptx_vector;
   }
 
-bool wallet2::sanity_check(const std::vector<wallet2::pending_tx> &ptx_vector, std::vector<cryptonote::tx_destination_entry> dsts) const
+  bool wallet2::sanity_check(const std::vector<wallet2::pending_tx> &ptx_vector, std::vector<cryptonote::tx_destination_entry> dsts, bool offshore, bool onshore, bool offshore_to_offshore, offshore::pricing_record pr) const
   {
     MDEBUG("sanity_check: " << ptx_vector.size() << " txes, " << dsts.size() << " destinations");
 
@@ -10154,26 +11736,46 @@ bool wallet2::sanity_check(const std::vector<wallet2::pending_tx> &ptx_vector, s
 
     THROW_WALLET_EXCEPTION_IF(ptx_vector.empty(), error::wallet_internal_error, "No transactions");
 
+    const bool use_offshore_outputs = onshore || offshore_to_offshore;
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
+
     // check every party in there does receive at least the required amount
-  std::unordered_map<account_public_address, std::pair<uint64_t, bool>> required;
+    std::unordered_map<account_public_address, std::pair<std::pair<uint64_t, uint64_t>, bool>> required;
     for (const auto &d : dsts)
     {
-    required[d.addr].first += d.amount;
+      if (offshore)
+      {
+        //required[d.addr].first.second += d.amount;
+        required[d.addr].first.first += d.amount;
+      }
+      else if (onshore)
+      {
+        required[d.addr].first.first += d.amount;
+      }
+      else if (offshore_to_offshore)
+      {
+        required[d.addr].first.second += d.amount;
+      }
+      else
+      {
+        required[d.addr].first.first += d.amount;
+      }
       required[d.addr].second = d.is_subaddress;
     }
 
+    /*
   // add change
   uint64_t change = 0;
   for (const auto &ptx: ptx_vector)
   {
     for (size_t idx: ptx.selected_transfers)
-      change += m_transfers[idx].amount();
+      change += specific_transfers[idx].amount();
     change -= ptx.fee;
   }
   for (const auto &r: required)
-    change -= r.second.first;
+    change -= (use_offshore_outputs) ? r.second.first;
   MDEBUG("Adding " << cryptonote::print_money(change) << " expected change");
-
+  */
     // for all txes that have actual change, check change is coming back to the sending wallet
     for (const pending_tx &ptx : ptx_vector)
     {
@@ -10181,7 +11783,8 @@ bool wallet2::sanity_check(const std::vector<wallet2::pending_tx> &ptx_vector, s
         continue;
       THROW_WALLET_EXCEPTION_IF(m_subaddresses.find(ptx.change_dts.addr.m_spend_public_key) == m_subaddresses.end(),
                                 error::wallet_internal_error, "Change address is not ours");
-    required[ptx.change_dts.addr].first += ptx.change_dts.amount;
+      required[ptx.change_dts.addr].first.first += ptx.change_dts.amount;
+      required[ptx.change_dts.addr].first.second += ptx.change_dts.amount_usd;
       required[ptx.change_dts.addr].second = ptx.change_dts.is_subaddress;
     }
 
@@ -10190,24 +11793,113 @@ bool wallet2::sanity_check(const std::vector<wallet2::pending_tx> &ptx_vector, s
       const account_public_address &address = r.first;
       const crypto::public_key &view_pkey = address.m_view_public_key;
 
-    uint64_t total_received = 0;
+      uint64_t total_received = 0, total_received_usd = 0;
       for (const auto &ptx : ptx_vector)
       {
-      uint64_t received = 0;
+        uint64_t received = 0, received_usd = 0;
         try
         {
           std::string proof = get_tx_proof(ptx.tx, ptx.tx_key, ptx.additional_tx_keys, address, r.second.second, "automatic-sanity-check");
-        check_tx_proof(ptx.tx, address, r.second.second, "automatic-sanity-check", proof, received);
+          check_tx_proof(ptx.tx, address, r.second.second, "automatic-sanity-check", proof, received, received_usd);
+        }
+        catch (const std::exception &e)
+        {
+          received = 0;
         }
-      catch (const std::exception &e) { received = 0; }
         total_received += received;
+        total_received_usd += received_usd;
       }
 
+      // Now check the difference is accounted for by the exchange rate
       std::stringstream ss;
+      if (offshore)
+      {
+        /*
+      if ((total_received > 0) && (total_received_usd < r.second.first.second)) {
+
+	boost::multiprecision::uint128_t usd_128 = (r.second.first.second - total_received_usd);
+	boost::multiprecision::uint128_t exchange_128 = pr.unused1;
+	boost::multiprecision::uint128_t xhv_128 = usd_128 * 1000000000000;
+	xhv_128 /= exchange_128;
+	uint64_t xhv_result = (uint64_t)xhv_128;
+
+	ss << "Total received by " << cryptonote::get_account_address_as_str(m_nettype, r.second.second, address) << ": "
+	   << cryptonote::print_money(total_received) << ", expected " << cryptonote::print_money(r.second.first.first);
+	MDEBUG(ss.str());
+	THROW_WALLET_EXCEPTION_IF(total_received < xhv_result, error::wallet_internal_error, ss.str());
+
+      } else {
+	// Staying in same currency - change or offshore fee
+	ss << "Total received by " << cryptonote::get_account_address_as_str(m_nettype, r.second.second, address) << ": "
+	   << cryptonote::print_money(total_received_usd) << ", expected " << cryptonote::print_money(r.second.first.second);
+	MDEBUG(ss.str());
+	THROW_WALLET_EXCEPTION_IF(total_received_usd < r.second.first.second, error::wallet_internal_error, ss.str());
+      }
+      */
+        if ((total_received_usd > 0) && (total_received < r.second.first.first))
+        {
+
+          boost::multiprecision::uint128_t xhv_128 = (r.second.first.first - total_received);
+          boost::multiprecision::uint128_t exchange_128 = pr.unused1;
+          boost::multiprecision::uint128_t usd_128 = xhv_128 * exchange_128;
+          usd_128 /= 1000000000000;
+          uint64_t usd_result = (uint64_t)usd_128;
+
+          ss << "Total received by " << cryptonote::get_account_address_as_str(m_nettype, r.second.second, address) << ": "
+             << cryptonote::print_money(total_received_usd) << ", expected " << cryptonote::print_money(r.second.first.second);
+          MDEBUG(ss.str());
+          THROW_WALLET_EXCEPTION_IF(total_received_usd < usd_result, error::wallet_internal_error, ss.str());
+        }
+        else
+        {
+          // Staying in same currency - change
+          ss << "Total received by " << cryptonote::get_account_address_as_str(m_nettype, r.second.second, address) << ": "
+             << cryptonote::print_money(total_received) << ", expected " << cryptonote::print_money(r.second.first.first);
+          MDEBUG(ss.str());
+          THROW_WALLET_EXCEPTION_IF(total_received < r.second.first.first, error::wallet_internal_error, ss.str());
+        }
+      }
+      else if (onshore)
+      {
+        if ((total_received_usd > 0) && (total_received < r.second.first.first))
+        {
+
+          boost::multiprecision::uint128_t xhv_128 = (r.second.first.first - total_received);
+          boost::multiprecision::uint128_t exchange_128 = pr.unused1;
+          boost::multiprecision::uint128_t usd_128 = xhv_128 * exchange_128;
+          usd_128 /= 1000000000000;
+          uint64_t usd_result = (uint64_t)usd_128;
+
+          ss << "Total received by " << cryptonote::get_account_address_as_str(m_nettype, r.second.second, address) << ": "
+             << cryptonote::print_money(total_received_usd) << ", expected " << cryptonote::print_money(r.second.first.second);
+          MDEBUG(ss.str());
+          THROW_WALLET_EXCEPTION_IF(total_received_usd < usd_result, error::wallet_internal_error, ss.str());
+        }
+        else
+        {
+          // Staying in same currency - change
+          ss << "Total received by " << cryptonote::get_account_address_as_str(m_nettype, r.second.second, address) << ": "
+             << cryptonote::print_money(total_received) << ", expected " << cryptonote::print_money(r.second.first.first);
+          MDEBUG(ss.str());
+          THROW_WALLET_EXCEPTION_IF(total_received < r.second.first.first, error::wallet_internal_error, ss.str());
+        }
+      }
+      else if (offshore_to_offshore)
+      {
+        // Nothing to do here
+        ss << "Total received by " << cryptonote::get_account_address_as_str(m_nettype, r.second.second, address) << ": "
+           << cryptonote::print_money(total_received_usd) << ", expected " << cryptonote::print_money(r.second.first.second);
+        MDEBUG(ss.str());
+        THROW_WALLET_EXCEPTION_IF(total_received_usd < r.second.first.second, error::wallet_internal_error, ss.str());
+      }
+      else
+      {
+        // Nothing to do here
         ss << "Total received by " << cryptonote::get_account_address_as_str(m_nettype, r.second.second, address) << ": "
-        << cryptonote::print_money(total_received) << ", expected " << cryptonote::print_money(r.second.first);
+           << cryptonote::print_money(total_received) << ", expected " << cryptonote::print_money(r.second.first.first);
         MDEBUG(ss.str());
-    THROW_WALLET_EXCEPTION_IF(total_received < r.second.first, error::wallet_internal_error, ss.str());
+        THROW_WALLET_EXCEPTION_IF(total_received < r.second.first.first, error::wallet_internal_error, ss.str());
+      }
     }
 
     return true;
@@ -10222,10 +11914,11 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_all(uint64_t below
     // determine threshold for fractional amount
     const bool use_per_byte_fee = use_fork_rules(HF_VERSION_PER_BYTE_FEE, 0);
     const bool bulletproof = use_fork_rules(get_bulletproof_fork(), 0);
+    const bool clsag = use_fork_rules(get_clsag_fork(), 0);
     const uint64_t base_fee = get_base_fee();
     const uint64_t fee_multiplier = get_fee_multiplier(priority, get_fee_algorithm());
-  const size_t tx_weight_one_ring = estimate_tx_weight(use_rct, 1, fake_outs_count, 2, 0, bulletproof);
-  const size_t tx_weight_two_rings = estimate_tx_weight(use_rct, 2, fake_outs_count, 2, 0, bulletproof);
+    const size_t tx_weight_one_ring = estimate_tx_weight(use_rct, 1, fake_outs_count, 2, 0, bulletproof, clsag);
+    const size_t tx_weight_two_rings = estimate_tx_weight(use_rct, 2, fake_outs_count, 2, 0, bulletproof, clsag);
     THROW_WALLET_EXCEPTION_IF(tx_weight_one_ring > tx_weight_two_rings, error::wallet_internal_error, "Estimated tx weight with 1 input is larger than with 2 inputs!");
     const size_t tx_weight_per_ring = tx_weight_two_rings - tx_weight_one_ring;
     const uint64_t fractional_threshold = (fee_multiplier * base_fee * tx_weight_per_ring) / (use_per_byte_fee ? 1 : 1024);
@@ -10234,11 +11927,48 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_all(uint64_t below
 
     std::map<uint32_t, std::pair<std::vector<size_t>, std::vector<size_t>>> unused_transfer_dust_indices_per_subaddr;
 
+    bool bOffshoreTx = false;
+    tx_extra_offshore offshore_data;
+    if (extra.size())
+    {
+      // Check to see if this is an offshore tx
+      bOffshoreTx = get_offshore_from_tx_extra(extra, offshore_data);
+    }
+
+    bool offshore = false;
+    bool onshore = false;
+    bool offshore_to_offshore = false;
+    if (bOffshoreTx)
+    {
+
+      // HERE BE DRAGONS!!!
+      // Filter out the offshore information?
+      //remove_field_from_tx_extra(tx.extra, typeid(tx_extra_offshore));
+      // LAND AHOY!!!
+
+      // Set the bool flags
+      if ((offshore_data.data.at(0) > 'A') && (offshore_data.data.at(1) > 'A'))
+      {
+        offshore_to_offshore = true;
+      }
+      else if (offshore_data.data.at(0) > 'A')
+      {
+        onshore = true;
+      }
+      else
+      {
+        offshore = true;
+      }
+    }
+
+    const bool use_offshore_outputs = onshore || offshore_to_offshore;
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
+
     // gather all dust and non-dust outputs of specified subaddress (if any) and below specified threshold (if any)
     bool fund_found = false;
-  for (size_t i = 0; i < m_transfers.size(); ++i)
+    for (size_t i = 0; i < specific_transfers.size(); ++i)
     {
-    const transfer_details& td = m_transfers[i];
+      const transfer_details &td = specific_transfers[i];
       if (m_ignore_fractional_outputs && td.amount() < fractional_threshold)
       {
         MDEBUG("Ignoring output " << i << " of amount " << print_money(td.amount()) << " which is below threshold " << print_money(fractional_threshold));
@@ -10312,7 +12042,8 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
     hw::reset_mode rst(hwdev);
 
     uint64_t accumulated_fee, accumulated_outputs, accumulated_change;
-  struct TX {
+    struct TX
+    {
       std::vector<size_t> selected_transfers;
       std::vector<cryptonote::tx_destination_entry> dsts;
       cryptonote::transaction tx;
@@ -10331,9 +12062,10 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
     const bool use_per_byte_fee = use_fork_rules(HF_VERSION_PER_BYTE_FEE);
     const bool use_rct = fake_outs_count > 0 && use_fork_rules(4, 0);
     const bool bulletproof = use_fork_rules(get_bulletproof_fork(), 0);
+    const bool clsag = use_fork_rules(get_clsag_fork(), 0);
     const rct::RCTConfig rct_config{
         bulletproof ? rct::RangeProofPaddedBulletproof : rct::RangeProofBorromean,
-    bulletproof ? (use_fork_rules(HF_VERSION_SMALLER_BP, -10) ? 2 : 1) : 0,
+        bulletproof ? (use_fork_rules(HF_VERSION_CLSAG, 0) ? 3 : use_fork_rules(HF_VERSION_SMALLER_BP, -10) ? 2 : 1) : 0,
     };
     const uint64_t base_fee = get_base_fee();
     const uint64_t fee_multiplier = get_fee_multiplier(priority, get_fee_algorithm());
@@ -10351,9 +12083,47 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
     accumulated_change = 0;
     needed_fee = 0;
 
+    bool bOffshoreTx = false;
+    tx_extra_offshore offshore_data;
+    if (extra.size())
+    {
+      // Check to see if this is an offshore tx
+      bOffshoreTx = get_offshore_from_tx_extra(extra, offshore_data);
+    }
+
+    bool offshore = false;
+    bool onshore = false;
+    bool offshore_to_offshore = false;
+    if (bOffshoreTx)
+    {
+
+      // HERE BE DRAGONS!!!
+      // Filter out the offshore information?
+      //remove_field_from_tx_extra(tx.extra, typeid(tx_extra_offshore));
+      // LAND AHOY!!!
+
+      // Set the bool flags
+      if ((offshore_data.data.at(0) > 'A') && (offshore_data.data.at(1) > 'A'))
+      {
+        offshore_to_offshore = true;
+      }
+      else if (offshore_data.data.at(0) > 'A')
+      {
+        onshore = true;
+      }
+      else
+      {
+        offshore = true;
+      }
+    }
+
+    const bool use_offshore_outputs = onshore || offshore_to_offshore;
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
+
     // while we have something to send
     hwdev.set_mode(hw::device::TRANSACTION_CREATE_FAKE);
-  while (!unused_dust_indices.empty() || !unused_transfers_indices.empty()) {
+    while (!unused_dust_indices.empty() || !unused_transfers_indices.empty())
+    {
       TX &tx = txes.back();
 
       // get a random unspent output and use it to pay next chunk. We try to alternate
@@ -10362,7 +12132,7 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
       uint64_t fee_dust_threshold;
       if (use_fork_rules(HF_VERSION_PER_BYTE_FEE))
       {
-      const uint64_t estimated_tx_weight_with_one_extra_output = estimate_tx_weight(use_rct, tx.selected_transfers.size() + 1, fake_outs_count, tx.dsts.size()+1, extra.size(), bulletproof);
+        const uint64_t estimated_tx_weight_with_one_extra_output = estimate_tx_weight(use_rct, tx.selected_transfers.size() + 1, fake_outs_count, tx.dsts.size() + 1, extra.size(), bulletproof, clsag);
         fee_dust_threshold = calculate_fee_from_weight(base_fee, estimated_tx_weight_with_one_extra_output, fee_multiplier, fee_quantization_mask);
       }
       else
@@ -10379,7 +12149,7 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
                           ? pop_best_value(unused_dust_indices, tx.selected_transfers)
                           : pop_best_value(unused_transfers_indices, tx.selected_transfers);
 
-    const transfer_details &td = m_transfers[idx];
+      const transfer_details &td = specific_transfers[idx];
       LOG_PRINT_L2("Picking output " << idx << ", amount " << print_money(td.amount()));
 
       // add this output to the list to spend
@@ -10393,24 +12163,28 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
       // here, check if we need to sent tx and start a new one
       LOG_PRINT_L2("Considering whether to create a tx now, " << tx.selected_transfers.size() << " inputs, tx limit "
                                                               << upper_transaction_weight_limit);
-    const size_t estimated_rct_tx_weight = estimate_tx_weight(use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size() + 2, extra.size(), bulletproof);
+      const size_t estimated_rct_tx_weight = estimate_tx_weight(use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size() + 2, extra.size(), bulletproof, clsag);
       bool try_tx = (unused_dust_indices.empty() && unused_transfers_indices.empty()) || (estimated_rct_tx_weight >= TX_WEIGHT_TARGET(upper_transaction_weight_limit));
 
-    if (try_tx) {
+      if (try_tx)
+      {
         cryptonote::transaction test_tx;
         pending_tx test_ptx;
 
-      needed_fee = estimate_fee(use_per_byte_fee, use_rct, tx.selected_transfers.size(), fake_outs_count, tx.dsts.size()+1, extra.size(), bulletproof, base_fee, fee_multiplier, fee_quantization_mask);
+        const size_t num_outputs = get_num_outputs(tx.dsts, specific_transfers, tx.selected_transfers);
+        needed_fee = estimate_fee(use_per_byte_fee, use_rct, tx.selected_transfers.size(), fake_outs_count, num_outputs, extra.size(), bulletproof, clsag, base_fee, fee_multiplier, fee_quantization_mask);
 
         // add N - 1 outputs for correct initial fee estimation
         for (size_t i = 0; i < ((outputs > 1) ? outputs - 1 : outputs); ++i)
+          if (use_offshore_outputs)
+            tx.dsts.push_back(tx_destination_entry(0, 1, address, is_subaddress));
+          else
             tx.dsts.push_back(tx_destination_entry(1, address, is_subaddress));
 
-      LOG_PRINT_L2("Trying to create a tx now, with " << tx.dsts.size() << " destinations and " <<
-        tx.selected_transfers.size() << " outputs");
+        LOG_PRINT_L2("Trying to create a tx now, with " << tx.dsts.size() << " destinations and " << tx.selected_transfers.size() << " outputs");
         if (use_rct)
           transfer_selected_rct(tx.dsts, tx.selected_transfers, fake_outs_count, outs, unlock_time, needed_fee, extra,
-          test_tx, test_ptx, rct_config);
+                                test_tx, test_ptx, rct_config, offshore, onshore, offshore_to_offshore);
         else
           transfer_selected(tx.dsts, tx.selected_transfers, fake_outs_count, outs, unlock_time, needed_fee, extra,
                             detail::digit_split_strategy, tx_dust_policy(::config::DEFAULT_DUST_THRESHOLD), test_tx, test_ptx);
@@ -10418,17 +12192,24 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
         needed_fee = calculate_fee(use_per_byte_fee, test_ptx.tx, txBlob.size(), base_fee, fee_multiplier, fee_quantization_mask);
         available_for_fee = test_ptx.fee + test_ptx.change_dts.amount;
         for (auto &dt : test_ptx.dests)
+          if (use_offshore_outputs)
+            available_for_fee += dt.amount_usd;
+          else
             available_for_fee += dt.amount;
-      LOG_PRINT_L2("Made a " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(available_for_fee) << " available for fee (" <<
-        print_money(needed_fee) << " needed)");
+        LOG_PRINT_L2("Made a " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(available_for_fee) << " available for fee (" << print_money(needed_fee) << " needed)");
 
         // add last output, missed for fee estimation
         if (outputs > 1)
+        {
+          if (use_offshore_outputs)
+            tx.dsts.push_back(tx_destination_entry(0, 1, address, is_subaddress));
+          else
             tx.dsts.push_back(tx_destination_entry(1, address, is_subaddress));
-
+        }
         THROW_WALLET_EXCEPTION_IF(needed_fee > available_for_fee, error::wallet_internal_error, "Transaction cannot pay for itself");
 
-      do {
+        do
+        {
           LOG_PRINT_L2("We made a tx, adjusting fee and saving it");
           // distribute total transferred amount between outputs
           uint64_t amount_transferred = available_for_fee - needed_fee;
@@ -10443,22 +12224,23 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
               dt_residue = 1;
               residue -= 1;
             }
+            if (use_offshore_outputs)
+              dt.amount_usd = dt_amount + dt_residue;
+            else
               dt.amount = dt_amount + dt_residue;
           }
           if (use_rct)
             transfer_selected_rct(tx.dsts, tx.selected_transfers, fake_outs_count, outs, unlock_time, needed_fee, extra,
-            test_tx, test_ptx, rct_config);
+                                  test_tx, test_ptx, rct_config, offshore, onshore, offshore_to_offshore);
           else
             transfer_selected(tx.dsts, tx.selected_transfers, fake_outs_count, outs, unlock_time, needed_fee, extra,
                               detail::digit_split_strategy, tx_dust_policy(::config::DEFAULT_DUST_THRESHOLD), test_tx, test_ptx);
           txBlob = t_serializable_object_to_blob(test_ptx.tx);
           needed_fee = calculate_fee(use_per_byte_fee, test_ptx.tx, txBlob.size(), base_fee, fee_multiplier, fee_quantization_mask);
-        LOG_PRINT_L2("Made an attempt at a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) <<
-          " fee  and " << print_money(test_ptx.change_dts.amount) << " change");
+          LOG_PRINT_L2("Made an attempt at a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) << " fee  and " << print_money(test_ptx.change_dts.amount) << " change");
         } while (needed_fee > test_ptx.fee);
 
-      LOG_PRINT_L2("Made a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) <<
-        " fee  and " << print_money(test_ptx.change_dts.amount) << " change");
+        LOG_PRINT_L2("Made a final " << get_weight_string(test_ptx.tx, txBlob.size()) << " tx, with " << print_money(test_ptx.fee) << " fee  and " << print_money(test_ptx.change_dts.amount) << " change");
 
         tx.tx = test_tx;
         tx.ptx = test_ptx;
@@ -10475,8 +12257,7 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
       }
     }
 
-  LOG_PRINT_L1("Done creating " << txes.size() << " transactions, " << print_money(accumulated_fee) <<
-    " total fee, " << print_money(accumulated_change) << " total change");
+    LOG_PRINT_L1("Done creating " << txes.size() << " transactions, " << print_money(accumulated_fee) << " total fee, " << print_money(accumulated_change) << " total change");
 
     hwdev.set_mode(hw::device::TRANSACTION_CREATE_REAL);
     for (std::vector<TX>::iterator i = txes.begin(); i != txes.end(); ++i)
@@ -10484,10 +12265,13 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
       TX &tx = *i;
       cryptonote::transaction test_tx;
       pending_tx test_ptx;
-    if (use_rct) {
+      if (use_rct)
+      {
         transfer_selected_rct(tx.dsts, tx.selected_transfers, fake_outs_count, tx.outs, unlock_time, tx.needed_fee, extra,
-        test_tx, test_ptx, rct_config);
-    } else {
+                              test_tx, test_ptx, rct_config, offshore, onshore, offshore_to_offshore);
+      }
+      else
+      {
         transfer_selected(tx.dsts, tx.selected_transfers, fake_outs_count, tx.outs, unlock_time, tx.needed_fee, extra,
                           detail::digit_split_strategy, tx_dust_policy(::config::DEFAULT_DUST_THRESHOLD), test_tx, test_ptx);
       }
@@ -10503,11 +12287,8 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
       TX &tx = *i;
       uint64_t tx_money = 0;
       for (size_t idx : tx.selected_transfers)
-      tx_money += m_transfers[idx].amount();
-    LOG_PRINT_L1("  Transaction " << (1+std::distance(txes.begin(), i)) << "/" << txes.size() <<
-      " " << get_transaction_hash(tx.ptx.tx) << ": " << get_weight_string(tx.weight) << ", sending " << print_money(tx_money) << " in " << tx.selected_transfers.size() <<
-      " outputs to " << tx.dsts.size() << " destination(s), including " <<
-      print_money(tx.ptx.fee) << " fee, " << print_money(tx.ptx.change_dts.amount) << " change");
+        tx_money += specific_transfers[idx].amount();
+      LOG_PRINT_L1("  Transaction " << (1 + std::distance(txes.begin(), i)) << "/" << txes.size() << " " << get_transaction_hash(tx.ptx.tx) << ": " << get_weight_string(tx.weight) << ", sending " << print_money(tx_money) << " in " << tx.selected_transfers.size() << " outputs to " << tx.dsts.size() << " destination(s), including " << print_money(tx.ptx.fee) << " fee, " << print_money(tx.ptx.change_dts.amount) << " change");
       ptx_vector.push_back(tx.ptx);
     }
 
@@ -10516,12 +12297,20 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
     {
       for (size_t idx : tx.selected_transfers)
       {
-      a += m_transfers[idx].amount();
+        a += specific_transfers[idx].amount();
       }
       a -= tx.ptx.fee;
     }
+    if (use_offshore_outputs)
+    {
+      std::vector<cryptonote::tx_destination_entry> synthetic_dsts(1, cryptonote::tx_destination_entry("", 0, a, address, is_subaddress));
+      THROW_WALLET_EXCEPTION_IF(!sanity_check(ptx_vector, synthetic_dsts), error::wallet_internal_error, "Created transaction(s) failed sanity check");
+    }
+    else
+    {
       std::vector<cryptonote::tx_destination_entry> synthetic_dsts(1, cryptonote::tx_destination_entry("", a, address, is_subaddress));
       THROW_WALLET_EXCEPTION_IF(!sanity_check(ptx_vector, synthetic_dsts), error::wallet_internal_error, "Created transaction(s) failed sanity check");
+    }
 
     // if we made it this far, we're OK to actually send the transactions
     return ptx_vector;
@@ -10530,7 +12319,8 @@ std::vector<wallet2::pending_tx> wallet2::create_transactions_from(const crypton
   void wallet2::cold_tx_aux_import(const std::vector<pending_tx> &ptx, const std::vector<std::string> &tx_device_aux)
   {
     CHECK_AND_ASSERT_THROW_MES(ptx.size() == tx_device_aux.size(), "TX aux has invalid size");
-  for (size_t i = 0; i < ptx.size(); ++i){
+    for (size_t i = 0; i < ptx.size(); ++i)
+    {
       crypto::hash txid;
       txid = get_transaction_hash(ptx[i].tx);
       set_tx_device_aux(txid, tx_device_aux[i]);
@@ -10540,7 +12330,8 @@ void wallet2::cold_tx_aux_import(const std::vector<pending_tx> & ptx, const std:
   void wallet2::cold_sign_tx(const std::vector<pending_tx> &ptx_vector, signed_tx_set &exported_txs, std::vector<cryptonote::address_parse_info> &dsts_info, std::vector<std::string> &tx_device_aux)
   {
     auto &hwdev = get_account().get_device();
-  if (!hwdev.has_tx_cold_sign()){
+    if (!hwdev.has_tx_cold_sign())
+    {
       throw std::invalid_argument("Device does not support cold sign protocol");
     }
 
@@ -10564,10 +12355,12 @@ void wallet2::cold_sign_tx(const std::vector<pending_tx>& ptx_vector, signed_tx_
     tx_device_aux = aux_data.tx_device_aux;
 
     MDEBUG("Signed tx data from hw: " << exported_txs.ptx.size() << " transactions");
-  for (auto &c_ptx: exported_txs.ptx) LOG_PRINT_L0(cryptonote::obj_to_json_str(c_ptx.tx));
+    for (auto &c_ptx : exported_txs.ptx)
+      LOG_PRINT_L0(cryptonote::obj_to_json_str(c_ptx.tx));
   }
   //----------------------------------------------------------------------------------------------------
-uint64_t wallet2::cold_key_image_sync(uint64_t &spent, uint64_t &unspent) {
+  uint64_t wallet2::cold_key_image_sync(uint64_t &spent, uint64_t &unspent)
+  {
     auto &hwdev = get_account().get_device();
     CHECK_AND_ASSERT_THROW_MES(hwdev.has_ki_cold_sync(), "Device does not support cold ki sync protocol");
 
@@ -10645,7 +12438,7 @@ uint64_t wallet2::get_upper_transaction_weight_limit()
     if (m_upper_transaction_weight_limit > 0)
       return m_upper_transaction_weight_limit;
     uint64_t full_reward_zone = use_fork_rules(5, 10) ? CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE_V5 : use_fork_rules(2, 10) ? CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE_V2 : CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE_V1;
-  if (use_fork_rules(8, 10))
+    if (use_fork_rules(5, 10))
       return full_reward_zone / 2 - CRYPTONOTE_COINBASE_BLOB_RESERVED_SIZE;
     else
       return full_reward_zone - CRYPTONOTE_COINBASE_BLOB_RESERVED_SIZE;
@@ -10719,11 +12512,13 @@ std::vector<size_t> wallet2::select_available_outputs_from_histogram(uint64_t co
       if (!allow_rct && td.is_rct())
         return false;
       const uint64_t amount = td.is_rct() ? 0 : td.amount();
-    if (atleast) {
+      if (atleast)
+      {
         if (mixable.find(amount) != mixable.end())
           return true;
       }
-    else {
+      else
+      {
         if (mixable.find(amount) == mixable.end())
           return true;
       }
@@ -10761,6 +12556,12 @@ const wallet2::transfer_details &wallet2::get_transfer_details(size_t idx) const
     return m_transfers[idx];
   }
   //----------------------------------------------------------------------------------------------------
+  const wallet2::transfer_details &wallet2::get_offshore_transfer_details(size_t idx) const
+  {
+    THROW_WALLET_EXCEPTION_IF(idx >= m_offshore_transfers.size(), error::wallet_internal_error, "Bad transfer index");
+    return m_offshore_transfers[idx];
+  }
+  //----------------------------------------------------------------------------------------------------
   std::vector<size_t> wallet2::select_available_unmixable_outputs()
   {
     // request all outputs with less instances than the min ring size
@@ -11126,7 +12927,8 @@ bool wallet2::check_spend_proof(const crypto::hash &txid, const std::string &mes
     }
     std::vector<std::vector<crypto::signature>> signatures = {std::vector<crypto::signature>(1)};
     const size_t sig_len = tools::base58::encode(std::string((const char *)&signatures[0][0], sizeof(crypto::signature))).size();
-  if( sig_str.size() != header_len + num_sigs * sig_len ) {
+    if (sig_str.size() != header_len + num_sigs * sig_len)
+    {
       return false;
     }
 
@@ -11202,7 +13004,7 @@ bool wallet2::check_spend_proof(const crypto::hash &txid, const std::string &mes
   }
   //----------------------------------------------------------------------------------------------------
 
-void wallet2::check_tx_key(const crypto::hash &txid, const crypto::secret_key &tx_key, const std::vector<crypto::secret_key> &additional_tx_keys, const cryptonote::account_public_address &address, uint64_t &received, bool &in_pool, uint64_t &confirmations)
+  void wallet2::check_tx_key(const crypto::hash &txid, const crypto::secret_key &tx_key, const std::vector<crypto::secret_key> &additional_tx_keys, const cryptonote::account_public_address &address, uint64_t &received, uint64_t &received_usd, bool &in_pool, uint64_t &confirmations)
   {
     crypto::key_derivation derivation;
     THROW_WALLET_EXCEPTION_IF(!crypto::generate_key_derivation(address.m_view_public_key, tx_key, derivation), error::wallet_internal_error,
@@ -11214,24 +13016,39 @@ void wallet2::check_tx_key(const crypto::hash &txid, const crypto::secret_key &t
       THROW_WALLET_EXCEPTION_IF(!crypto::generate_key_derivation(address.m_view_public_key, additional_tx_keys[i], additional_derivations[i]), error::wallet_internal_error,
                                 "Failed to generate key derivation from supplied parameters");
 
-  check_tx_key_helper(txid, derivation, additional_derivations, address, received, in_pool, confirmations);
+    check_tx_key_helper(txid, derivation, additional_derivations, address, received, received_usd, in_pool, confirmations);
   }
 
-void wallet2::check_tx_key_helper(const cryptonote::transaction &tx, const crypto::key_derivation &derivation, const std::vector<crypto::key_derivation> &additional_derivations, const cryptonote::account_public_address &address, uint64_t &received) const
+  void wallet2::check_tx_key_helper(const cryptonote::transaction &tx, const crypto::key_derivation &derivation, const std::vector<crypto::key_derivation> &additional_derivations, const cryptonote::account_public_address &address, uint64_t &received, uint64_t &received_usd) const
   {
     received = 0;
 
+    bool bOffshoreTx = false;
+    tx_extra_offshore offshore_data;
+    if (tx.extra.size())
+    {
+      // Check to see if this is an offshore tx
+      bOffshoreTx = get_offshore_from_tx_extra(tx.extra, offshore_data);
+    }
+
     for (size_t n = 0; n < tx.vout.size(); ++n)
+    {
+      bool found = false;
+      bool offshore = false;
+      crypto::public_key derived_out_key;
+      crypto::key_derivation found_derivation;
+
+      // NEAC - check for offshore & onshore types as well as regular outs
+      if (tx.vout[n].target.type() == typeid(txout_to_key))
       {
         const cryptonote::txout_to_key *const out_key = boost::get<cryptonote::txout_to_key>(std::addressof(tx.vout[n].target));
         if (!out_key)
           continue;
 
-    crypto::public_key derived_out_key;
         bool r = crypto::derive_public_key(derivation, n, address.m_spend_public_key, derived_out_key);
         THROW_WALLET_EXCEPTION_IF(!r, error::wallet_internal_error, "Failed to derive public key");
-    bool found = out_key->key == derived_out_key;
-    crypto::key_derivation found_derivation = derivation;
+        found = out_key->key == derived_out_key;
+        found_derivation = derivation;
         if (!found && !additional_derivations.empty())
         {
           r = crypto::derive_public_key(additional_derivations[n], n, address.m_spend_public_key, derived_out_key);
@@ -11239,6 +13056,31 @@ void wallet2::check_tx_key_helper(const cryptonote::transaction &tx, const crypt
           found = out_key->key == derived_out_key;
           found_derivation = additional_derivations[n];
         }
+      }
+      else if (tx.vout[n].target.type() == typeid(txout_offshore))
+      {
+        offshore = true;
+        const cryptonote::txout_offshore *const out_key = boost::get<cryptonote::txout_offshore>(std::addressof(tx.vout[n].target));
+        if (!out_key)
+          continue;
+
+        bool r = crypto::derive_public_key(derivation, n, address.m_spend_public_key, derived_out_key);
+        THROW_WALLET_EXCEPTION_IF(!r, error::wallet_internal_error, "Failed to derive offshore public key");
+        found = out_key->key == derived_out_key;
+        found_derivation = derivation;
+        if (!found && !additional_derivations.empty())
+        {
+          r = crypto::derive_public_key(additional_derivations[n], n, address.m_spend_public_key, derived_out_key);
+          THROW_WALLET_EXCEPTION_IF(!r, error::wallet_internal_error, "Failed to derive offshore public key");
+          found = out_key->key == derived_out_key;
+          found_derivation = additional_derivations[n];
+        }
+      }
+      else
+      {
+        LOG_PRINT_L2(__func__ << ":" << __LINE__ << " : warning - found invalid 'out' type - skipping");
+        continue;
+      }
 
       if (found)
       {
@@ -11252,23 +13094,43 @@ void wallet2::check_tx_key_helper(const cryptonote::transaction &tx, const crypt
           crypto::secret_key scalar1;
           crypto::derivation_to_scalar(found_derivation, n, scalar1);
           rct::ecdhTuple ecdh_info = tx.rct_signatures.ecdhInfo[n];
-        rct::ecdhDecode(ecdh_info, rct::sk2rct(scalar1), tx.rct_signatures.type == rct::RCTTypeBulletproof2);
-        const rct::key C = tx.rct_signatures.outPk[n].mask;
+          rct::ecdhDecode(ecdh_info, rct::sk2rct(scalar1), tx.rct_signatures.type == rct::RCTTypeBulletproof2 || tx.rct_signatures.type == rct::RCTTypeCLSAG);
+          const rct::key C = (offshore ? tx.rct_signatures.outPk_usd[n].mask : tx.rct_signatures.outPk[n].mask);
           rct::key Ctmp;
           THROW_WALLET_EXCEPTION_IF(sc_check(ecdh_info.mask.bytes) != 0, error::wallet_internal_error, "Bad ECDH input mask");
           THROW_WALLET_EXCEPTION_IF(sc_check(ecdh_info.amount.bytes) != 0, error::wallet_internal_error, "Bad ECDH input amount");
           rct::addKeys2(Ctmp, ecdh_info.mask, ecdh_info.amount, rct::H);
           if (rct::equalKeys(C, Ctmp))
+          {
+            amount = rct::h2d(ecdh_info.amount);
+            if (offshore)
+            {
+              LOG_PRINT_L0("rct::equalKeys() passed for OFFSHORE amount " << amount);
+            }
+          }
+          else if (bOffshoreTx)
+          {
             amount = rct::h2d(ecdh_info.amount);
+            LOG_PRINT_L0("rct::equalKeys() FAILED for OFFSHORE amount " << amount);
+          }
           else
+          {
             amount = 0;
           }
+        }
+        if (offshore)
+        {
+          received_usd += amount;
+        }
+        else
+        {
           received += amount;
         }
       }
     }
+  }
 
-void wallet2::check_tx_key_helper(const crypto::hash &txid, const crypto::key_derivation &derivation, const std::vector<crypto::key_derivation> &additional_derivations, const cryptonote::account_public_address &address, uint64_t &received, bool &in_pool, uint64_t &confirmations)
+  void wallet2::check_tx_key_helper(const crypto::hash &txid, const crypto::key_derivation &derivation, const std::vector<crypto::key_derivation> &additional_derivations, const cryptonote::account_public_address &address, uint64_t &received, uint64_t &received_usd, bool &in_pool, uint64_t &confirmations)
   {
     COMMAND_RPC_GET_TRANSACTIONS::request req;
     COMMAND_RPC_GET_TRANSACTIONS::response res;
@@ -11309,7 +13171,7 @@ void wallet2::check_tx_key_helper(const crypto::hash &txid, const crypto::key_de
     THROW_WALLET_EXCEPTION_IF(!additional_derivations.empty() && additional_derivations.size() != tx.vout.size(), error::wallet_internal_error,
                               "The size of additional derivations is wrong");
 
-  check_tx_key_helper(tx, derivation, additional_derivations, address, received);
+    check_tx_key_helper(tx, derivation, additional_derivations, address, received, received_usd);
 
     in_pool = res.txs.front().in_pool;
     confirmations = 0;
@@ -11471,9 +13333,9 @@ std::string wallet2::get_tx_proof(const cryptonote::transaction &tx, const crypt
     std::vector<crypto::key_derivation> additional_derivations(num_sigs - 1);
     for (size_t i = 1; i < num_sigs; ++i)
       THROW_WALLET_EXCEPTION_IF(!crypto::generate_key_derivation(shared_secret[i], rct::rct2sk(rct::I), additional_derivations[i - 1]), error::wallet_internal_error, "Failed to generate key derivation");
-  uint64_t received;
-  check_tx_key_helper(tx, derivation, additional_derivations, address, received);
-  THROW_WALLET_EXCEPTION_IF(!received, error::wallet_internal_error, tr("No funds received in this tx."));
+    uint64_t received, received_usd;
+    check_tx_key_helper(tx, derivation, additional_derivations, address, received, received_usd);
+    THROW_WALLET_EXCEPTION_IF(!received && !received_usd, error::wallet_internal_error, tr("No funds received in this tx."));
 
     // concatenate all signature strings
     for (size_t i = 0; i < num_sigs; ++i)
@@ -11483,7 +13345,7 @@ std::string wallet2::get_tx_proof(const cryptonote::transaction &tx, const crypt
     return sig_str;
   }
 
-bool wallet2::check_tx_proof(const crypto::hash &txid, const cryptonote::account_public_address &address, bool is_subaddress, const std::string &message, const std::string &sig_str, uint64_t &received, bool &in_pool, uint64_t &confirmations)
+  bool wallet2::check_tx_proof(const crypto::hash &txid, const cryptonote::account_public_address &address, bool is_subaddress, const std::string &message, const std::string &sig_str, uint64_t &received, uint64_t &received_usd, bool &in_pool, uint64_t &confirmations)
   {
     // fetch tx pubkey from the daemon
     COMMAND_RPC_GET_TRANSACTIONS::request req;
@@ -11522,7 +13384,7 @@ bool wallet2::check_tx_proof(const crypto::hash &txid, const cryptonote::account
 
     THROW_WALLET_EXCEPTION_IF(tx_hash != txid, error::wallet_internal_error, "Failed to get the right transaction from daemon");
 
-  if (!check_tx_proof(tx, address, is_subaddress, message, sig_str, received))
+    if (!check_tx_proof(tx, address, is_subaddress, message, sig_str, received, received_usd))
       return false;
 
     in_pool = res.txs.front().in_pool;
@@ -11538,7 +13400,7 @@ bool wallet2::check_tx_proof(const crypto::hash &txid, const cryptonote::account
     return true;
   }
 
-bool wallet2::check_tx_proof(const cryptonote::transaction &tx, const cryptonote::account_public_address &address, bool is_subaddress, const std::string &message, const std::string &sig_str, uint64_t &received) const
+  bool wallet2::check_tx_proof(const cryptonote::transaction &tx, const cryptonote::account_public_address &address, bool is_subaddress, const std::string &message, const std::string &sig_str, uint64_t &received, uint64_t &received_usd) const
   {
     const bool is_out = sig_str.substr(0, 3) == "Out";
     const std::string header = is_out ? "OutProofV1" : "InProofV1";
@@ -11587,28 +13449,20 @@ bool wallet2::check_tx_proof(const cryptonote::transaction &tx, const cryptonote
     std::vector<int> good_signature(num_sigs, 0);
     if (is_out)
     {
-    good_signature[0] = is_subaddress ?
-      crypto::check_tx_proof(prefix_hash, tx_pub_key, address.m_view_public_key, address.m_spend_public_key, shared_secret[0], sig[0]) :
-      crypto::check_tx_proof(prefix_hash, tx_pub_key, address.m_view_public_key, boost::none, shared_secret[0], sig[0]);
+      good_signature[0] = is_subaddress ? crypto::check_tx_proof(prefix_hash, tx_pub_key, address.m_view_public_key, address.m_spend_public_key, shared_secret[0], sig[0]) : crypto::check_tx_proof(prefix_hash, tx_pub_key, address.m_view_public_key, boost::none, shared_secret[0], sig[0]);
 
       for (size_t i = 0; i < additional_tx_pub_keys.size(); ++i)
       {
-      good_signature[i + 1] = is_subaddress ?
-        crypto::check_tx_proof(prefix_hash, additional_tx_pub_keys[i], address.m_view_public_key, address.m_spend_public_key, shared_secret[i + 1], sig[i + 1]) :
-        crypto::check_tx_proof(prefix_hash, additional_tx_pub_keys[i], address.m_view_public_key, boost::none, shared_secret[i + 1], sig[i + 1]);
+        good_signature[i + 1] = is_subaddress ? crypto::check_tx_proof(prefix_hash, additional_tx_pub_keys[i], address.m_view_public_key, address.m_spend_public_key, shared_secret[i + 1], sig[i + 1]) : crypto::check_tx_proof(prefix_hash, additional_tx_pub_keys[i], address.m_view_public_key, boost::none, shared_secret[i + 1], sig[i + 1]);
       }
     }
     else
     {
-    good_signature[0] = is_subaddress ?
-      crypto::check_tx_proof(prefix_hash, address.m_view_public_key, tx_pub_key, address.m_spend_public_key, shared_secret[0], sig[0]) :
-      crypto::check_tx_proof(prefix_hash, address.m_view_public_key, tx_pub_key, boost::none, shared_secret[0], sig[0]);
+      good_signature[0] = is_subaddress ? crypto::check_tx_proof(prefix_hash, address.m_view_public_key, tx_pub_key, address.m_spend_public_key, shared_secret[0], sig[0]) : crypto::check_tx_proof(prefix_hash, address.m_view_public_key, tx_pub_key, boost::none, shared_secret[0], sig[0]);
 
       for (size_t i = 0; i < additional_tx_pub_keys.size(); ++i)
       {
-      good_signature[i + 1] = is_subaddress ?
-        crypto::check_tx_proof(prefix_hash, address.m_view_public_key, additional_tx_pub_keys[i], address.m_spend_public_key, shared_secret[i + 1], sig[i + 1]) :
-        crypto::check_tx_proof(prefix_hash, address.m_view_public_key, additional_tx_pub_keys[i], boost::none, shared_secret[i + 1], sig[i + 1]);
+        good_signature[i + 1] = is_subaddress ? crypto::check_tx_proof(prefix_hash, address.m_view_public_key, additional_tx_pub_keys[i], address.m_spend_public_key, shared_secret[i + 1], sig[i + 1]) : crypto::check_tx_proof(prefix_hash, address.m_view_public_key, additional_tx_pub_keys[i], boost::none, shared_secret[i + 1], sig[i + 1]);
       }
     }
 
@@ -11624,7 +13478,7 @@ bool wallet2::check_tx_proof(const cryptonote::transaction &tx, const cryptonote
         if (good_signature[i])
           THROW_WALLET_EXCEPTION_IF(!crypto::generate_key_derivation(shared_secret[i], rct::rct2sk(rct::I), additional_derivations[i - 1]), error::wallet_internal_error, "Failed to generate key derivation");
 
-    check_tx_key_helper(tx, derivation, additional_derivations, address, received);
+      check_tx_key_helper(tx, derivation, additional_derivations, address, received, received_usd);
       return true;
     }
     return false;
@@ -11650,8 +13504,7 @@ std::string wallet2::get_reserve_proof(const boost::optional<std::pair<uint32_t,
     {
       THROW_WALLET_EXCEPTION_IF(account_minreserve->second == 0, error::wallet_internal_error, "Proved amount must be greater than 0");
       // minimize the number of outputs included in the proof, by only picking the N largest outputs that can cover the requested min reserve amount
-    std::sort(selected_transfers.begin(), selected_transfers.end(), [&](const size_t a, const size_t b)
-      { return m_transfers[a].amount() > m_transfers[b].amount(); });
+      std::sort(selected_transfers.begin(), selected_transfers.end(), [&](const size_t a, const size_t b) { return m_transfers[a].amount() > m_transfers[b].amount(); });
       while (selected_transfers.size() >= 2 && m_transfers[selected_transfers[1]].amount() >= account_minreserve->second)
         selected_transfers.erase(selected_transfers.begin());
       size_t sz = 0;
@@ -11869,7 +13722,7 @@ bool wallet2::check_reserve_proof(const cryptonote::account_public_address &addr
         crypto::secret_key shared_secret;
         crypto::derivation_to_scalar(derivation, proof.index_in_tx, shared_secret);
         rct::ecdhTuple ecdh_info = tx.rct_signatures.ecdhInfo[proof.index_in_tx];
-      rct::ecdhDecode(ecdh_info, rct::sk2rct(shared_secret), tx.rct_signatures.type == rct::RCTTypeBulletproof2);
+        rct::ecdhDecode(ecdh_info, rct::sk2rct(shared_secret), tx.rct_signatures.type == rct::RCTTypeBulletproof2 || tx.rct_signatures.type == rct::RCTTypeCLSAG);
         amount = rct::h2d(ecdh_info.amount);
       }
       total += amount;
@@ -11938,17 +13791,18 @@ uint64_t wallet2::get_daemon_blockchain_target_height(string &err)
   uint64_t wallet2::get_approximate_blockchain_height() const
   {
     // time of v2 fork
-  const time_t fork_time = m_nettype == TESTNET ? 1448285909 : m_nettype == STAGENET ? 1520937818 : 1458748658;
+    const time_t fork_time = m_nettype == TESTNET ? 1522713600 : m_nettype == STAGENET ? 1522713600 : 1518826456;
     // v2 fork block
-  const uint64_t fork_block = m_nettype == TESTNET ? 624634 : m_nettype == STAGENET ? 32000 : 1009827;
+    const uint64_t fork_block = m_nettype == TESTNET ? 25 : m_nettype == STAGENET ? 25 : 38500;
     // avg seconds per block
     const int seconds_per_block = DIFFICULTY_TARGET_V2;
     // Calculated blockchain height
     uint64_t approx_blockchain_height = fork_block + (time(NULL) - fork_time) / seconds_per_block;
+    // NO ROLLBACK FOR HAVEN
     // testnet got some huge rollbacks, so the estimation is way off
-  static const uint64_t approximate_testnet_rolled_back_blocks = 303967;
-  if (m_nettype == TESTNET && approx_blockchain_height > approximate_testnet_rolled_back_blocks)
-    approx_blockchain_height -= approximate_testnet_rolled_back_blocks;
+    //static const uint64_t approximate_testnet_rolled_back_blocks = 303967;
+    //if (m_nettype == TESTNET && approx_blockchain_height > approximate_testnet_rolled_back_blocks)
+    //approx_blockchain_height -= approximate_testnet_rolled_back_blocks;
     LOG_PRINT_L2("Calculated blockchain height: " << approx_blockchain_height);
     return approx_blockchain_height;
   }
@@ -12073,19 +13927,22 @@ std::string wallet2::sign(const std::string &data, cryptonote::subaddress_index
   bool wallet2::verify(const std::string &data, const cryptonote::account_public_address &address, const std::string &signature) const
   {
     const size_t header_len = strlen("SigV1");
-  if (signature.size() < header_len || signature.substr(0, header_len) != "SigV1") {
+    if (signature.size() < header_len || signature.substr(0, header_len) != "SigV1")
+    {
       LOG_PRINT_L0("Signature header check error");
       return false;
     }
     crypto::hash hash;
     crypto::cn_fast_hash(data.data(), data.size(), hash);
     std::string decoded;
-  if (!tools::base58::decode(signature.substr(header_len), decoded)) {
+    if (!tools::base58::decode(signature.substr(header_len), decoded))
+    {
       LOG_PRINT_L0("Signature decoding error");
       return false;
     }
     crypto::signature s;
-  if (sizeof(s) != decoded.size()) {
+    if (sizeof(s) != decoded.size())
+    {
       LOG_PRINT_L0("Signature decoding error");
       return false;
     }
@@ -12107,19 +13964,22 @@ std::string wallet2::sign_multisig_participant(const std::string& data) const
 
   bool wallet2::verify_with_public_key(const std::string &data, const crypto::public_key &public_key, const std::string &signature) const
   {
-  if (signature.size() < MULTISIG_SIGNATURE_MAGIC.size() || signature.substr(0, MULTISIG_SIGNATURE_MAGIC.size()) != MULTISIG_SIGNATURE_MAGIC) {
+    if (signature.size() < MULTISIG_SIGNATURE_MAGIC.size() || signature.substr(0, MULTISIG_SIGNATURE_MAGIC.size()) != MULTISIG_SIGNATURE_MAGIC)
+    {
       MERROR("Signature header check error");
       return false;
     }
     crypto::hash hash;
     crypto::cn_fast_hash(data.data(), data.size(), hash);
     std::string decoded;
-  if (!tools::base58::decode(signature.substr(MULTISIG_SIGNATURE_MAGIC.size()), decoded)) {
+    if (!tools::base58::decode(signature.substr(MULTISIG_SIGNATURE_MAGIC.size()), decoded))
+    {
       MERROR("Signature decoding error");
       return false;
     }
     crypto::signature s;
-  if (sizeof(s) != decoded.size()) {
+    if (sizeof(s) != decoded.size())
+    {
       MERROR("Signature decoding error");
       return false;
     }
@@ -12145,7 +14005,8 @@ crypto::public_key wallet2::get_tx_pub_key_from_received_outs(const tools::walle
                               "Public key wasn't found in the transaction extra");
     const crypto::public_key tx_pub_key = pub_key_field.pub_key;
     bool two_found = find_tx_extra_field_by_type(tx_extra_fields, pub_key_field, 1);
-  if (!two_found) {
+    if (!two_found)
+    {
       // easy case, just one found
       return tx_pub_key;
     }
@@ -12155,7 +14016,8 @@ crypto::public_key wallet2::get_tx_pub_key_from_received_outs(const tools::walle
     size_t pk_index = 0;
     hw::device &hwdev = m_account.get_device();
 
-  while (find_tx_extra_field_by_type(tx_extra_fields, pub_key_field, pk_index++)) {
+    while (find_tx_extra_field_by_type(tx_extra_fields, pub_key_field, pk_index++))
+    {
       const crypto::public_key tx_pub_key = pub_key_field.pub_key;
       crypto::key_derivation derivation;
       bool r = hwdev.generate_key_derivation(tx_pub_key, keys.m_view_secret_key, derivation);
@@ -12355,13 +14217,10 @@ uint64_t wallet2::import_key_images(const std::vector<std::pair<crypto::key_imag
         std::vector<const crypto::public_key *> pkeys;
         pkeys.push_back(&pkey);
         THROW_WALLET_EXCEPTION_IF(!(rct::scalarmultKey(rct::ki2rct(key_image), rct::curveOrder()) == rct::identity()),
-          error::wallet_internal_error, "Key image out of validity domain: input " + boost::lexical_cast<std::string>(n + offset) + "/"
-          + boost::lexical_cast<std::string>(signed_key_images.size()) + ", key image " + epee::string_tools::pod_to_hex(key_image));
+                                  error::wallet_internal_error, "Key image out of validity domain: input " + boost::lexical_cast<std::string>(n + offset) + "/" + boost::lexical_cast<std::string>(signed_key_images.size()) + ", key image " + epee::string_tools::pod_to_hex(key_image));
 
         THROW_WALLET_EXCEPTION_IF(!crypto::check_ring_signature((const crypto::hash &)key_image, key_image, pkeys, &signature),
-          error::signature_check_failed, boost::lexical_cast<std::string>(n + offset) + "/"
-          + boost::lexical_cast<std::string>(signed_key_images.size()) + ", key image " + epee::string_tools::pod_to_hex(key_image)
-          + ", signature " + epee::string_tools::pod_to_hex(signature) + ", pubkey " + epee::string_tools::pod_to_hex(*pkeys[0]));
+                                  error::signature_check_failed, boost::lexical_cast<std::string>(n + offset) + "/" + boost::lexical_cast<std::string>(signed_key_images.size()) + ", key image " + epee::string_tools::pod_to_hex(key_image) + ", signature " + epee::string_tools::pod_to_hex(signature) + ", pubkey " + epee::string_tools::pod_to_hex(*pkeys[0]));
       }
       req.key_images.push_back(epee::string_tools::pod_to_hex(key_image));
     }
@@ -12468,7 +14327,6 @@ uint64_t wallet2::import_key_images(const std::vector<std::pair<crypto::key_imag
       for (const crypto::hash &spent_txid : spent_txids)
         gettxs_req.txs_hashes.push_back(epee::string_tools::pod_to_hex(spent_txid));
 
-
       PERF_TIMER_START(import_key_images_E);
       {
         const boost::lock_guard<boost::recursive_mutex> lock{m_daemon_rpc_mutex};
@@ -12765,7 +14623,9 @@ size_t wallet2::import_outputs(const std::pair<size_t, std::vector<tools::wallet
         const transfer_details &org_td = m_transfers[i + offset];
         if (!org_td.m_key_image_known)
           goto process;
-#define CMPF(f) if (!(td.f == org_td.f)) goto process
+#define CMPF(f)            \
+  if (!(td.f == org_td.f)) \
+  goto process
         CMPF(m_txid);
         CMPF(m_key_image);
         CMPF(m_internal_output_index);
@@ -12976,16 +14836,30 @@ crypto::key_image wallet2::get_multisig_composite_key_image(size_t n) const
   //----------------------------------------------------------------------------------------------------
   cryptonote::blobdata wallet2::export_multisig()
   {
-  std::vector<tools::wallet2::multisig_info> info;
-
     const crypto::public_key signer = get_multisig_signer_public_key();
+    std::stringstream oss;
+    boost::archive::portable_binary_oarchive ar(oss);
 
-  info.resize(m_transfers.size());
-  for (size_t n = 0; n < m_transfers.size(); ++n)
+    std::vector<transfer_container> transfer_containers = {m_transfers, m_offshore_transfers};
+    std::string container_sizes;
+    for (transfer_container &specific_transfers : transfer_containers)
     {
-    transfer_details &td = m_transfers[n];
+      // Write the expected number of entries for each container to the stream
+      std::stringstream ss;
+      ss << std::setfill('0') << std::setw(16) << specific_transfers.size();
+      container_sizes += ss.str();
+      MDEBUG("HERE BE DRAGONS!!! " << ss.str());
+    }
+    for (transfer_container &specific_transfers : transfer_containers)
+    {
+
+      std::vector<tools::wallet2::multisig_info> info;
+      info.resize(specific_transfers.size());
+      for (size_t n = 0; n < specific_transfers.size(); ++n)
+      {
+        transfer_details &td = specific_transfers[n];
         crypto::key_image ki;
-    memwipe(td.m_multisig_k.data(), td.m_multisig_k.size() * sizeof(td.m_multisig_k[0]));
+        td.m_multisig_k.clear();
         info[n].m_LR.clear();
         info[n].m_partial_key_images.clear();
 
@@ -13011,27 +14885,29 @@ cryptonote::blobdata wallet2::export_multisig()
         info[n].m_signer = signer;
       }
 
-  std::stringstream oss;
-  boost::archive::portable_binary_oarchive ar(oss);
       ar << info;
+    }
 
     const cryptonote::account_public_address &keys = get_account().get_keys().m_account_address;
     std::string header;
     header += std::string((const char *)&keys.m_spend_public_key, sizeof(crypto::public_key));
     header += std::string((const char *)&keys.m_view_public_key, sizeof(crypto::public_key));
     header += std::string((const char *)&signer, sizeof(crypto::public_key));
+    header += container_sizes;
     std::string ciphertext = encrypt_with_view_secret_key(header + oss.str());
 
     return MULTISIG_EXPORT_FILE_MAGIC + ciphertext;
   }
   //----------------------------------------------------------------------------------------------------
-void wallet2::update_multisig_rescan_info(const std::vector<std::vector<rct::key>> &multisig_k, const std::vector<std::vector<tools::wallet2::multisig_info>> &info, size_t n)
+  void wallet2::update_multisig_rescan_info(const std::vector<std::vector<rct::key>> &multisig_k, const std::vector<std::vector<tools::wallet2::multisig_info>> &info, size_t n, bool use_offshore_outputs)
   {
-  CHECK_AND_ASSERT_THROW_MES(n < m_transfers.size(), "Bad index in update_multisig_info");
-  CHECK_AND_ASSERT_THROW_MES(multisig_k.size() >= m_transfers.size(), "Mismatched sizes of multisig_k and info");
+    transfer_container specific_transfers = use_offshore_outputs ? m_offshore_transfers : m_transfers;
+
+    CHECK_AND_ASSERT_THROW_MES(n < specific_transfers.size(), "Bad index in update_multisig_info");
+    CHECK_AND_ASSERT_THROW_MES(multisig_k.size() >= specific_transfers.size(), "Mismatched sizes of multisig_k and info");
 
     MDEBUG("update_multisig_rescan_info: updating index " << n);
-  transfer_details &td = m_transfers[n];
+    transfer_details &td = specific_transfers[n];
     td.m_multisig_info.clear();
     for (const auto &pi : info)
     {
@@ -13052,6 +14928,7 @@ size_t wallet2::import_multisig(std::vector<cryptonote::blobdata> blobs)
     CHECK_AND_ASSERT_THROW_MES(m_multisig, "Wallet is not multisig");
 
     std::vector<std::vector<tools::wallet2::multisig_info>> info;
+    std::vector<std::vector<tools::wallet2::multisig_info>> info_offshore;
     std::unordered_set<crypto::public_key> seen;
     for (cryptonote::blobdata &data : blobs)
     {
@@ -13061,12 +14938,14 @@ size_t wallet2::import_multisig(std::vector<cryptonote::blobdata> blobs)
 
       data = decrypt_with_view_secret_key(std::string(data, magiclen));
 
-    const size_t headerlen = 3 * sizeof(crypto::public_key);
+      const size_t headerlen = (3 * sizeof(crypto::public_key)) + (2 * 16);
       THROW_WALLET_EXCEPTION_IF(data.size() < headerlen, error::wallet_internal_error, "Bad data size");
 
       const crypto::public_key &public_spend_key = *(const crypto::public_key *)&data[0];
       const crypto::public_key &public_view_key = *(const crypto::public_key *)&data[sizeof(crypto::public_key)];
       const crypto::public_key &signer = *(const crypto::public_key *)&data[2 * sizeof(crypto::public_key)];
+      const std::string str_onshore_count(&data[3 * sizeof(crypto::public_key)], 16);
+      const std::string str_offshore_count(&data[3 * sizeof(crypto::public_key)] + 16, 16);
       const cryptonote::account_public_address &keys = get_account().get_keys().m_account_address;
       THROW_WALLET_EXCEPTION_IF(public_spend_key != keys.m_spend_public_key || public_view_key != keys.m_view_public_key,
                                 error::wallet_internal_error, "Multisig info is for a different account");
@@ -13088,19 +14967,36 @@ size_t wallet2::import_multisig(std::vector<cryptonote::blobdata> blobs)
       boost::archive::portable_binary_iarchive ar(iss);
       ar >> i;
       MINFO(boost::format("%u outputs found") % boost::lexical_cast<std::string>(i.size()));
+      THROW_WALLET_EXCEPTION_IF(i.size() != (std::stoull(str_onshore_count) + stoull(str_offshore_count)),
+                                error::wallet_internal_error, "Multisig info contains incorrect number of entries");
+
+      // Split i into offshore and onshore components
+      std::vector<tools::wallet2::multisig_info> i_offshore;
+      i_offshore.insert(i_offshore.end(),
+                        std::make_move_iterator(i.begin() + std::stoull(str_onshore_count)),
+                        std::make_move_iterator(i.end()));
+      i.erase(i.begin() + std::stoull(str_onshore_count), i.end());
+
       info.push_back(std::move(i));
+      info.push_back(std::move(i_offshore));
     }
 
+    size_t n_outputs_global = 0;
+    std::vector<std::string> modes = {"onshore", "offshore"};
+    for (auto current_mode : modes)
+    {
+
+      transfer_container specific_transfers = (current_mode == "offshore") ? m_offshore_transfers : m_transfers;
+
       CHECK_AND_ASSERT_THROW_MES(info.size() + 1 <= m_multisig_signers.size() && info.size() + 1 >= m_multisig_threshold, "Wrong number of multisig sources");
 
       std::vector<std::vector<rct::key>> k;
-  auto wiper = epee::misc_utils::create_scope_leave_handler([&](){for (auto &v: k) memwipe(v.data(), v.size() * sizeof(v[0]));});
-  k.reserve(m_transfers.size());
-  for (const auto &td: m_transfers)
+      k.reserve(specific_transfers.size());
+      for (const auto &td : specific_transfers)
         k.push_back(td.m_multisig_k);
 
       // how many outputs we're going to update
-  size_t n_outputs = m_transfers.size();
+      size_t n_outputs = specific_transfers.size();
       for (const auto &pi : info)
         if (pi.size() < n_outputs)
           n_outputs = pi.size();
@@ -13108,6 +15004,8 @@ size_t wallet2::import_multisig(std::vector<cryptonote::blobdata> blobs)
       if (n_outputs == 0)
         return 0;
 
+      n_outputs_global = n_outputs;
+
       // check signers are consistent
       for (const auto &pi : info)
       {
@@ -13130,7 +15028,7 @@ size_t wallet2::import_multisig(std::vector<cryptonote::blobdata> blobs)
       // first pass to determine where to detach the blockchain
       for (size_t n = 0; n < n_outputs; ++n)
       {
-    const transfer_details &td = m_transfers[n];
+        const transfer_details &td = specific_transfers[n];
         if (!td.m_key_image_partial)
           continue;
         MINFO("Multisig info importing from block height " << td.m_block_height);
@@ -13138,28 +15036,52 @@ size_t wallet2::import_multisig(std::vector<cryptonote::blobdata> blobs)
         break;
       }
 
-  for (size_t n = 0; n < n_outputs && n < m_transfers.size(); ++n)
+      for (size_t n = 0; n < n_outputs && n < specific_transfers.size(); ++n)
+      {
+        update_multisig_rescan_info(k, info, (current_mode == "offshore"));
+      }
+
+      if (current_mode == "offshore")
+      {
+        m_multisig_rescan_offshore_k = &k;
+        m_multisig_rescan_offshore_info = &info;
+      }
+      else
       {
-    update_multisig_rescan_info(k, info, n);
-  }
-
         m_multisig_rescan_k = &k;
         m_multisig_rescan_info = &info;
+      }
       try
       {
 
         refresh(false);
       }
       catch (...)
+      {
+        if (current_mode == "offshore")
+        {
+          m_multisig_rescan_offshore_info = NULL;
+          m_multisig_rescan_offshore_k = NULL;
+        }
+        else
         {
           m_multisig_rescan_info = NULL;
           m_multisig_rescan_k = NULL;
+        }
         throw;
       }
+      if (current_mode == "offshore")
+      {
+        m_multisig_rescan_offshore_info = NULL;
+        m_multisig_rescan_offshore_k = NULL;
+      }
+      else
+      {
         m_multisig_rescan_info = NULL;
         m_multisig_rescan_k = NULL;
-
-  return n_outputs;
+      }
+    }
+    return n_outputs_global;
   }
   //----------------------------------------------------------------------------------------------------
   std::string wallet2::encrypt(const char *plaintext, size_t len, const crypto::secret_key &skey, bool authenticated) const
@@ -13408,8 +15330,7 @@ uint64_t wallet2::get_blockchain_height_by_date(uint16_t year, uint8_t month, ui
           {
               height_min,
               height_mid,
-      height_max
-    };
+              height_max};
 
       bool r;
       {
@@ -13427,7 +15348,8 @@ uint64_t wallet2::get_blockchain_height_by_date(uint16_t year, uint8_t month, ui
         oss << "failed to get blocks by heights: ";
         for (auto height : req.heights)
           oss << height << ' ';
-      oss << endl << "reason: ";
+        oss << endl
+            << "reason: ";
         if (!r)
           oss << "possibly lost connection to daemon";
         else if (res.status == CORE_RPC_STATUS_BUSY)
@@ -13437,10 +15359,14 @@ uint64_t wallet2::get_blockchain_height_by_date(uint16_t year, uint8_t month, ui
         throw std::runtime_error(oss.str());
       }
       cryptonote::block blk_min, blk_mid, blk_max;
-    if (res.blocks.size() < 3) throw std::runtime_error("Not enough blocks returned from daemon");
-    if (!parse_and_validate_block_from_blob(res.blocks[0].block, blk_min)) throw std::runtime_error("failed to parse blob at height " + std::to_string(height_min));
-    if (!parse_and_validate_block_from_blob(res.blocks[1].block, blk_mid)) throw std::runtime_error("failed to parse blob at height " + std::to_string(height_mid));
-    if (!parse_and_validate_block_from_blob(res.blocks[2].block, blk_max)) throw std::runtime_error("failed to parse blob at height " + std::to_string(height_max));
+      if (res.blocks.size() < 3)
+        throw std::runtime_error("Not enough blocks returned from daemon");
+      if (!parse_and_validate_block_from_blob(res.blocks[0].block, blk_min))
+        throw std::runtime_error("failed to parse blob at height " + std::to_string(height_min));
+      if (!parse_and_validate_block_from_blob(res.blocks[1].block, blk_mid))
+        throw std::runtime_error("failed to parse blob at height " + std::to_string(height_mid));
+      if (!parse_and_validate_block_from_blob(res.blocks[2].block, blk_max))
+        throw std::runtime_error("failed to parse blob at height " + std::to_string(height_max));
       uint64_t timestamp_min = blk_min.timestamp;
       uint64_t timestamp_mid = blk_mid.timestamp;
       uint64_t timestamp_max = blk_max.timestamp;
@@ -13570,8 +15496,7 @@ uint64_t wallet2::get_segregation_fork_height() const
           "segheights.moneropulse.org",
           "segheights.moneropulse.net",
           "segheights.moneropulse.co",
-        "segheights.moneropulse.se"
-    };
+          "segheights.moneropulse.se"};
 
       const uint64_t current_height = get_blockchain_current_height();
       uint64_t best_diff = std::numeric_limits<uint64_t>::max(), best_height = 0;
@@ -13603,8 +15528,9 @@ uint64_t wallet2::get_segregation_fork_height() const
     return SEGREGATION_FORK_HEIGHT;
   }
   //----------------------------------------------------------------------------------------------------
-void wallet2::generate_genesis(cryptonote::block& b) const {
-  cryptonote::generate_genesis_block(b, get_config(m_nettype).GENESIS_TX, get_config(m_nettype).GENESIS_NONCE);
+  void wallet2::generate_genesis(cryptonote::block &b) const
+  {
+    cryptonote::generate_genesis_block(b, get_config(m_nettype).GENESIS_TX, get_config(m_nettype).GENESIS_NONCE, m_nettype);
   }
   //----------------------------------------------------------------------------------------------------
   mms::multisig_wallet_state wallet2::get_multisig_wallet_state() const
@@ -13632,7 +15558,8 @@ mms::multisig_wallet_state wallet2::get_multisig_wallet_state() const
   //----------------------------------------------------------------------------------------------------
   wallet_device_callback *wallet2::get_device_callback()
   {
-  if (!m_device_callback){
+    if (!m_device_callback)
+    {
       m_device_callback.reset(new wallet_device_callback(this));
     }
     return m_device_callback.get();
@@ -13796,8 +15723,10 @@ uint64_t wallet2::hash_m_transfers(int64_t transfer_height, crypto::hash &hash)
     uint64_t current_height = 0;
 
     keccak_init(&state);
-  for(const transfer_details & transfer : m_transfers){
-    if (transfer_height >= 0 && current_height >= (uint64_t)transfer_height){
+    for (const transfer_details &transfer : m_transfers)
+    {
+      if (transfer_height >= 0 && current_height >= (uint64_t)transfer_height)
+      {
         break;
       }
 
@@ -13842,6 +15771,562 @@ uint64_t wallet2::get_bytes_received() const
   {
     return m_http_client->get_bytes_received();
   }
+  uint64_t wallet2::get_offshore_fee(std::vector<cryptonote::tx_destination_entry> dsts, uint32_t priority, std::vector<transfer_details> sources)
+  {
+    // Calculate the amount being sent
+    uint64_t amount = 0, amount_usd = 0;
+    for (auto dt : dsts)
+    {
+      THROW_WALLET_EXCEPTION_IF((0 == dt.amount) && (0 == dt.amount_usd), error::zero_destination);
+      amount += dt.amount;
+      amount_usd += dt.amount_usd;
+    }
+
+    if (use_fork_rules(HF_VERSION_OFFSHORE_FEES_V3, 0))
+    {
+
+      // Get the latest pricing records from the top block
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::request req_last = AUTO_VAL_INIT(req_last);
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::response res_last = AUTO_VAL_INIT(res_last);
+      bool r = invoke_http_json_rpc("/json_rpc", "get_last_block_header", req_last, res_last);
+      THROW_WALLET_EXCEPTION_IF(!r, tools::error::wallet_internal_error, "failed to get last block header");
+      THROW_WALLET_EXCEPTION_IF(res_last.status == CORE_RPC_STATUS_BUSY, error::daemon_busy, "get_offshore_fee");
+      THROW_WALLET_EXCEPTION_IF(res_last.status != CORE_RPC_STATUS_OK, tools::error::wallet_generic_rpc_error, "get_offshore_fee", res_last.status);
+
+      // Get the delta
+      uint64_t pricing_average = res_last.block_header.pricing_record.unused1;
+
+      // abs() implementation for uint64_t's
+      uint64_t delta = (pricing_average > res_last.block_header.pricing_record.xUSD)
+                           ? pricing_average - res_last.block_header.pricing_record.xUSD
+                           : res_last.block_header.pricing_record.xUSD - pricing_average;
+
+      // Estimate the fee components
+      boost::multiprecision::uint128_t conversion_fee = (amount > 0 ? amount : amount_usd) / 500;
+      conversion_fee *= priority;
+      boost::multiprecision::uint128_t conversion_extra = delta;
+      conversion_extra *= (amount > 0 ? amount : amount_usd);
+      uint64_t speed_fee = 0;
+      uint64_t speculation_fee = 0;
+      switch (priority)
+      {
+      case 4:
+        conversion_extra *= 110;
+        conversion_extra /= (100 * 1000000000000);
+        conversion_fee += conversion_extra;
+        break;
+      case 3:
+        conversion_extra /= 1000000000000;
+        conversion_fee += conversion_extra;
+        break;
+      case 2:
+        conversion_extra *= 75;
+        conversion_extra /= (100 * 1000000000000);
+        conversion_fee += conversion_extra;
+        break;
+      case 1:
+      default:
+        conversion_extra *= 25;
+        conversion_extra /= (100 * 1000000000000);
+        conversion_fee += conversion_extra;
+        break;
+      }
+
+      // Calculate the speed fee and speculation fee
+      if (sources.size() == 0)
+      {
+        // Best-case estimates for now
+        speed_fee =
+            (priority == 4) ? ((amount > 0 ? amount : amount_usd) / 50) : (priority == 3) ? ((amount > 0 ? amount : amount_usd) / 125) : 0;
+      }
+      else
+      {
+
+        // Get the current blockchain height
+        uint64_t current_height = get_blockchain_current_height();
+
+        // Take a copy of the sources, so we can sort by age
+        auto sources_copy = sources;
+        std::sort(sources_copy.begin(), sources_copy.end(),
+                  [](const transfer_details &a, const transfer_details &b) { return a.m_block_height < b.m_block_height; });
+
+        // Determine the accurate speed fee and speculation_fee
+        if (priority >= 3)
+        {
+          uint64_t running_total = 0;
+          uint64_t target_total = amount; // - ((dsts.back().amount > 0) ? dsts.back().amount : dsts.back().amount_usd);
+          for (auto src : sources_copy)
+          {
+            uint64_t age = current_height - src.m_block_height;
+            uint64_t src_amount = src.amount();
+            if (running_total + src_amount <= target_total)
+            {
+              if (age < (30 * 24 * 30))
+              {
+                speed_fee += (priority == 4) ? src_amount / 20 : src_amount / 50;
+              }
+              else
+              {
+                speed_fee += (priority == 4) ? src_amount / 50 : src_amount / 125;
+              }
+            }
+            else
+            {
+              // Recalculate the src_amount to finish off the TX
+              src_amount = target_total - running_total;
+              if (age < (30 * 24 * 30))
+              {
+                speed_fee += (priority == 4) ? src_amount / 20 : src_amount / 50;
+              }
+              else
+              {
+                speed_fee += (priority == 4) ? src_amount / 50 : src_amount / 125;
+              }
+            }
+            // Advance the running total
+            running_total += src_amount;
+          }
+        }
+      }
+
+      // Return the fee
+      return (uint64_t)conversion_fee + speed_fee + speculation_fee;
+    }
+    else if (use_fork_rules(HF_VERSION_OFFSHORE_FEES_V2, 0))
+    {
+
+      uint64_t fee_estimate = (amount > 0) ? amount : amount_usd;
+      switch (priority)
+      {
+      case 4:
+        fee_estimate /= 5; // 20% - "workday rush"
+        break;
+      case 3:
+        fee_estimate /= 10; // 10% "1-day rush"
+        break;
+      case 2:
+        fee_estimate /= 20; // 5% - "premium mint"
+        break;
+      default:
+        fee_estimate /= 500; // 0.2% - "standard mint"
+        break;
+      }
+
+      // Return the fee
+      return fee_estimate;
+    }
+    else
+    {
+
+      // Get the latest pricing records from the top block
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::request req_last = AUTO_VAL_INIT(req_last);
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::response res_last = AUTO_VAL_INIT(res_last);
+      bool r = invoke_http_json_rpc("/json_rpc", "get_last_block_header", req_last, res_last);
+      THROW_WALLET_EXCEPTION_IF(!r, tools::error::wallet_internal_error, "failed to get last block header");
+      THROW_WALLET_EXCEPTION_IF(res_last.status == CORE_RPC_STATUS_BUSY, error::daemon_busy, "get_offshore_fee");
+      THROW_WALLET_EXCEPTION_IF(res_last.status != CORE_RPC_STATUS_OK, tools::error::wallet_generic_rpc_error, "get_offshore_fee", res_last.status);
+
+      // Get the delta
+      uint64_t pricing_average = res_last.block_header.pricing_record.unused1;
+
+      // abs() implementation for uint64_t's
+      uint64_t delta = (pricing_average > res_last.block_header.pricing_record.xUSD)
+                           ? pricing_average - res_last.block_header.pricing_record.xUSD
+                           : res_last.block_header.pricing_record.xUSD - pricing_average;
+
+      // Estimate the fee
+      uint64_t unlock_time = 60 * pow(3, 4 - priority);
+      uint64_t fee_estimate = delta * exp((M_PI / -1000.0) * (unlock_time - 60) * 1.2) * (amount > 0 ? amount : amount_usd) / 1000000000000;
+
+      // Return the fee
+      return fee_estimate;
+    }
+  }
+  //----------------------------------------------------------------------------------------------------
+  uint64_t wallet2::get_onshore_fee(std::vector<cryptonote::tx_destination_entry> dsts, uint32_t priority, std::vector<transfer_details> sources)
+  {
+    // Calculate the amount being sent
+    uint64_t amount_usd = 0;
+    for (auto dt : dsts)
+    {
+      THROW_WALLET_EXCEPTION_IF(0 == dt.amount_usd, error::zero_destination);
+      amount_usd += dt.amount_usd;
+    }
+
+    if (use_fork_rules(HF_VERSION_OFFSHORE_FEES_V3, 0))
+    {
+
+      // Get the latest pricing records from the top block
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::request req_last = AUTO_VAL_INIT(req_last);
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::response res_last = AUTO_VAL_INIT(res_last);
+      bool r = invoke_http_json_rpc("/json_rpc", "get_last_block_header", req_last, res_last);
+      THROW_WALLET_EXCEPTION_IF(!r, tools::error::wallet_internal_error, "failed to get last block header");
+      THROW_WALLET_EXCEPTION_IF(res_last.status == CORE_RPC_STATUS_BUSY, error::daemon_busy, "get_onshore_fee");
+      THROW_WALLET_EXCEPTION_IF(res_last.status != CORE_RPC_STATUS_OK, tools::error::wallet_generic_rpc_error, "get_onshore_fee", res_last.status);
+
+      // Get the delta
+      uint64_t pricing_average = res_last.block_header.pricing_record.unused1;
+
+      // abs() implementation for uint64_t's
+      uint64_t delta = (pricing_average > res_last.block_header.pricing_record.xUSD)
+                           ? pricing_average - res_last.block_header.pricing_record.xUSD
+                           : res_last.block_header.pricing_record.xUSD - pricing_average;
+
+      // Estimate the fee components
+      boost::multiprecision::uint128_t conversion_fee = amount_usd / 500;
+      conversion_fee *= priority;
+      boost::multiprecision::uint128_t conversion_extra = delta;
+      conversion_extra *= amount_usd;
+      uint64_t speed_fee = 0;
+      uint64_t speculation_fee = 0;
+      switch (priority)
+      {
+      case 4:
+        conversion_extra *= 110;
+        conversion_extra /= (100 * 1000000000000);
+        conversion_fee += conversion_extra;
+        speed_fee = amount_usd / 20;
+        break;
+      case 3:
+        conversion_extra /= 1000000000000;
+        conversion_fee += conversion_extra;
+        speed_fee = amount_usd / 50;
+        break;
+      case 2:
+        conversion_extra *= 75;
+        conversion_extra /= (100 * 1000000000000);
+        conversion_fee += conversion_extra;
+        speed_fee = 0;
+        break;
+      case 1:
+      default:
+        conversion_extra *= 25;
+        conversion_extra /= (100 * 1000000000000);
+        conversion_fee += conversion_extra;
+        speed_fee = 0;
+        break;
+      }
+
+      // Calculate the speed fee and speculation fee
+      if (sources.size() == 0)
+      {
+        // Best-case estimates for now
+        speed_fee =
+            (priority == 4) ? (amount_usd / 50) : (priority == 3) ? (amount_usd / 125) : 0;
+      }
+      else
+      {
+
+        // Get the current blockchain height
+        uint64_t current_height = get_blockchain_current_height();
+
+        // Take a copy of the sources, so we can sort by age
+        auto sources_copy = sources;
+        std::sort(sources_copy.begin(), sources_copy.end(),
+                  [](const transfer_details &a, const transfer_details &b) { return a.m_block_height < b.m_block_height; });
+
+        // Create a vector of block heights to obtain pricing records for
+        std::vector<uint64_t> heights;
+
+        // Determine the accurate speed fee and speculation_fee
+        if (priority >= 3)
+        {
+          uint64_t running_total = 0;
+          uint64_t target_total = amount_usd;
+          for (auto src : sources_copy)
+          {
+            heights.push_back(src.m_block_height);
+            uint64_t age = current_height - src.m_block_height;
+            uint64_t src_amount = src.amount();
+            if (running_total + src_amount <= target_total)
+            {
+              if (age < (30 * 24 * 30))
+              {
+                speed_fee += (priority == 4) ? src_amount / 20 : src_amount / 50;
+              }
+              else
+              {
+                speed_fee += (priority == 4) ? src_amount / 50 : src_amount / 125;
+              }
+            }
+            else
+            {
+              // Recalculate the src_amount to finish off the TX
+              src_amount = target_total - running_total;
+              if (age < (30 * 24 * 30))
+              {
+                speed_fee += (priority == 4) ? src_amount / 20 : src_amount / 50;
+              }
+              else
+              {
+                speed_fee += (priority == 4) ? src_amount / 50 : src_amount / 125;
+              }
+            }
+            // Advance the running total
+            running_total += src_amount;
+          }
+        }
+
+        // Only bother if we have some heights to use
+        if (heights.size())
+        {
+
+          // Prepare a request + response container
+          COMMAND_RPC_GET_BLOCKS_BY_HEIGHT::request req;
+          COMMAND_RPC_GET_BLOCKS_BY_HEIGHT::response res;
+          req.heights = heights;
+
+          bool r;
+          {
+            const boost::lock_guard<boost::recursive_mutex> lock{m_daemon_rpc_mutex};
+            req.client = get_client_signature();
+            r = net_utils::invoke_http_bin("/getblocks_by_height.bin", req, res, *m_http_client, rpc_timeout);
+          }
+
+          if (!r || res.status != CORE_RPC_STATUS_OK)
+          {
+            std::ostringstream oss;
+            oss << "failed to get blocks by heights: ";
+            for (auto height : req.heights)
+              oss << height << ' ';
+            oss << endl
+                << "reason: ";
+            if (!r)
+              oss << "possibly lost connection to daemon";
+            else if (res.status == CORE_RPC_STATUS_BUSY)
+              oss << "daemon is busy";
+            else
+              oss << get_rpc_status(res.status);
+            throw std::runtime_error(oss.str());
+          }
+          int i = 0;
+          for (auto src : sources_copy)
+          {
+
+            cryptonote::block blk;
+            if (!parse_and_validate_block_from_blob(res.blocks[i++].block, blk))
+              throw std::runtime_error("failed to parse blob at height " + std::to_string(req.heights[i]));
+
+            // Got the block, which means we have the ppricing record as well - compute the difference in XHV prices to see if they made a notional profit
+            if (pricing_average < blk.pricing_record.unused1)
+            {
+              // current exchange rate less than when the input was created - how old is it?
+
+              // Check the age of the input
+              uint64_t age = current_height - src.m_block_height;
+              if (priority == 4)
+              {
+                if (age < (30 * 24))
+                {
+                  // Calculate the speculation fee
+                  speculation_fee = (blk.pricing_record.unused1 - pricing_average) * src.amount() / 2;
+                }
+                else if (age < (30 * 48))
+                {
+                  // Calculate the speculation fee
+                  speculation_fee = ((blk.pricing_record.unused1 - pricing_average) * src.amount() * 4) / 10;
+                }
+                else if (age < (30 * 120))
+                {
+                  // Calculate the speculation fee
+                  speculation_fee = (blk.pricing_record.unused1 - pricing_average) * src.amount() / 10;
+                }
+              }
+              else if (priority == 3)
+              {
+                if (age < (30 * 120))
+                {
+                  // Calculate the speculation fee
+                  speculation_fee = (blk.pricing_record.unused1 - pricing_average) * src.amount() / 10;
+                }
+              }
+            }
+          }
+        }
+      }
+
+      // Return the fee
+      return (uint64_t)conversion_fee + speed_fee + speculation_fee;
+    }
+    else if (use_fork_rules(HF_VERSION_OFFSHORE_FEES_V2, 0))
+    {
+
+      uint64_t fee_estimate = amount_usd;
+      switch (priority)
+      {
+      case 4:
+        fee_estimate /= 5; // 20% - "workday rush"
+        break;
+      case 3:
+        fee_estimate /= 10; // 10% "1-day rush"
+        break;
+      case 2:
+        fee_estimate /= 20; // 5% - "premium mint"
+        break;
+      default:
+        fee_estimate /= 500; // 0.2% - "standard mint"
+        break;
+      }
+
+      // Return the fee
+      return fee_estimate;
+    }
+    else
+    {
+
+      // Get the latest pricing records from the top block
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::request req_last = AUTO_VAL_INIT(req_last);
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::response res_last = AUTO_VAL_INIT(res_last);
+      bool r = invoke_http_json_rpc("/json_rpc", "get_last_block_header", req_last, res_last);
+      THROW_WALLET_EXCEPTION_IF(!r, tools::error::wallet_internal_error, "failed to get last block header");
+      THROW_WALLET_EXCEPTION_IF(res_last.status == CORE_RPC_STATUS_BUSY, error::daemon_busy, "get_onshore_fee");
+      THROW_WALLET_EXCEPTION_IF(res_last.status != CORE_RPC_STATUS_OK, tools::error::wallet_generic_rpc_error, "get_onshore_fee", res_last.status);
+
+      // Get the delta
+      uint64_t pricing_average = res_last.block_header.pricing_record.unused1;
+
+      // abs() implementation for uint64_t's
+      uint64_t delta = (pricing_average > res_last.block_header.pricing_record.xUSD)
+                           ? pricing_average - res_last.block_header.pricing_record.xUSD
+                           : res_last.block_header.pricing_record.xUSD - pricing_average;
+
+      // Estimate the fee
+      uint64_t unlock_time = 60 * pow(3, 4 - priority);
+      uint64_t fee_estimate = (delta * exp((M_PI / -1000.0) * (unlock_time - 60) * 1.2) * amount_usd) / 1000000000000;
+
+      // Return the fee
+      return fee_estimate;
+    }
+  }
+  //----------------------------------------------------------------------------------------------------
+  uint64_t wallet2::get_offshore_to_offshore_fee(std::vector<cryptonote::tx_destination_entry> dsts, uint32_t priority, std::vector<transfer_details> sources)
+  {
+    // Calculate the amount being sent
+    uint64_t amount_usd = 0;
+    for (auto dt : dsts)
+    {
+      THROW_WALLET_EXCEPTION_IF(0 == dt.amount_usd, error::zero_destination);
+      amount_usd += dt.amount_usd;
+    }
+
+    if (use_fork_rules(HF_VERSION_OFFSHORE_FEES_V3, 0))
+    {
+
+      // Get the latest pricing records from the top block
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::request req_last = AUTO_VAL_INIT(req_last);
+      cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER::response res_last = AUTO_VAL_INIT(res_last);
+      bool r = invoke_http_json_rpc("/json_rpc", "get_last_block_header", req_last, res_last);
+      THROW_WALLET_EXCEPTION_IF(!r, tools::error::wallet_internal_error, "failed to get last block header");
+      THROW_WALLET_EXCEPTION_IF(res_last.status == CORE_RPC_STATUS_BUSY, error::daemon_busy, "get_offshore_fee");
+      THROW_WALLET_EXCEPTION_IF(res_last.status != CORE_RPC_STATUS_OK, tools::error::wallet_generic_rpc_error, "get_offshore_fee", res_last.status);
+
+      // Get the delta
+      uint64_t pricing_average = res_last.block_header.pricing_record.unused1;
+
+      // abs() implementation for uint64_t's
+      uint64_t delta = (pricing_average > res_last.block_header.pricing_record.xUSD)
+                           ? pricing_average - res_last.block_header.pricing_record.xUSD
+                           : res_last.block_header.pricing_record.xUSD - pricing_average;
+
+      // Estimate the fee components
+      boost::multiprecision::uint128_t conversion_fee = amount_usd / 500;
+      conversion_fee *= priority;
+      boost::multiprecision::uint128_t conversion_extra = delta;
+      conversion_extra *= amount_usd;
+      uint64_t speed_fee = 0;
+      uint64_t speculation_fee = 0;
+      switch (priority)
+      {
+      case 4:
+        conversion_extra *= 110;
+        conversion_extra /= (100 * 1000000000000);
+        conversion_fee += conversion_extra;
+        speed_fee = amount_usd / 20;
+        break;
+      case 3:
+        conversion_extra /= 1000000000000;
+        conversion_fee += conversion_extra;
+        speed_fee = amount_usd / 50;
+        break;
+      case 2:
+        conversion_extra *= 75;
+        conversion_extra /= (100 * 1000000000000);
+        conversion_fee += conversion_extra;
+        speed_fee = 0;
+        break;
+      case 1:
+      default:
+        conversion_extra *= 25;
+        conversion_extra /= (100 * 1000000000000);
+        conversion_fee += conversion_extra;
+        speed_fee = 0;
+        break;
+      }
+
+      // Calculate the speed fee and speculation fee
+      if (sources.size() == 0)
+      {
+        // Best-case estimates for now
+        speed_fee =
+            (priority == 4) ? (amount_usd / 50) : (priority == 3) ? (amount_usd / 125) : 0;
+      }
+      else
+      {
+
+        // Get the current blockchain height
+        uint64_t current_height = get_blockchain_current_height();
+
+        // Take a copy of the sources, so we can sort by age
+        auto sources_copy = sources;
+        std::sort(sources_copy.begin(), sources_copy.end(),
+                  [](const transfer_details &a, const transfer_details &b) { return a.m_block_height < b.m_block_height; });
+
+        // Determine the accurate speed fee and speculation_fee
+        if (priority >= 3)
+        {
+          uint64_t running_total = 0;
+          uint64_t target_total = amount_usd; // - ((dsts.back().amount > 0) ? dsts.back().amount : dsts.back().amount_usd);
+          for (auto src : sources_copy)
+          {
+            uint64_t age = current_height - src.m_block_height;
+            uint64_t src_amount = src.amount();
+            if (running_total + src_amount <= target_total)
+            {
+              if (age < (30 * 24 * 30))
+              {
+                speed_fee += (priority == 4) ? src_amount / 20 : src_amount / 50;
+              }
+              else
+              {
+                speed_fee += (priority == 4) ? src_amount / 50 : src_amount / 125;
+              }
+            }
+            else
+            {
+              // Recalculate the src_amount to finish off the TX
+              src_amount = target_total - running_total;
+              if (age < (30 * 24 * 30))
+              {
+                speed_fee += (priority == 4) ? src_amount / 20 : src_amount / 50;
+              }
+              else
+              {
+                speed_fee += (priority == 4) ? src_amount / 50 : src_amount / 125;
+              }
+            }
+            // Advance the running total
+            running_total += src_amount;
+          }
+        }
+      }
+
+      // Return the fee
+      return (uint64_t)conversion_fee + speed_fee + speculation_fee;
+    }
+
+    // No fee for offshore-to-offshore prior to v3
+    return 0;
+  }
   //----------------------------------------------------------------------------------------------------
   std::vector<cryptonote::public_node> wallet2::get_public_nodes(bool white_only)
   {
@@ -13876,9 +16361,10 @@ std::pair<size_t, uint64_t> wallet2::estimate_tx_size_and_weight(bool use_rct, i
       n_outputs = 2; // extra dummy output
 
     const bool bulletproof = use_fork_rules(get_bulletproof_fork(), 0);
-  size_t size = estimate_tx_size(use_rct, n_inputs, ring_size - 1, n_outputs, extra_size, bulletproof);
-  uint64_t weight = estimate_tx_weight(use_rct, n_inputs, ring_size - 1, n_outputs, extra_size, bulletproof);
+    const bool clsag = use_fork_rules(get_clsag_fork(), 0);
+    size_t size = estimate_tx_size(use_rct, n_inputs, ring_size - 1, n_outputs, extra_size, bulletproof, clsag);
+    uint64_t weight = estimate_tx_weight(use_rct, n_inputs, ring_size - 1, n_outputs, extra_size, bulletproof, clsag);
     return std::make_pair(size, weight);
   }
   //----------------------------------------------------------------------------------------------------
-}
+} // namespace tools
