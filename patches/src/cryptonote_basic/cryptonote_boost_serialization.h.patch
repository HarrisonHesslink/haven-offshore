--- monero/src/cryptonote_basic/cryptonote_boost_serialization.h	2020-05-28 17:21:37.223695866 +0100
+++ monero-offshore/src/cryptonote_basic/cryptonote_boost_serialization.h	2020-04-17 15:21:28.000000000 +0100
@@ -103,7 +103,13 @@ namespace boost
   {
     a & x.key;
   }
-
+    
+  template <class Archive>
+  inline void serialize(Archive &a, cryptonote::txout_offshore &x, const boost::serialization::version_type ver)
+  {
+    a & x.key;
+  }
+    
   template <class Archive>
   inline void serialize(Archive &a, cryptonote::txout_to_scripthash &x, const boost::serialization::version_type ver)
   {
@@ -142,6 +148,22 @@ namespace boost
   }
 
   template <class Archive>
+  inline void serialize(Archive &a, cryptonote::txin_offshore &x, const boost::serialization::version_type ver)
+  {
+    a & x.amount;
+    a & x.key_offsets;
+    a & x.k_image;
+  }
+
+  template <class Archive>
+  inline void serialize(Archive &a, cryptonote::txin_onshore &x, const boost::serialization::version_type ver)
+  {
+    a & x.amount;
+    a & x.key_offsets;
+    a & x.k_image;
+  }
+
+  template <class Archive>
   inline void serialize(Archive &a, cryptonote::tx_out &x, const boost::serialization::version_type ver)
   {
     a & x.amount;
@@ -187,6 +209,9 @@ namespace boost
     a & b.timestamp;
     a & b.prev_id;
     a & b.nonce;
+    if (b.major_version >= HF_VERSION_OFFSHORE_PRICING) {
+      a & b.pricing_record;
+    }
     //------------------
     a & b.miner_tx;
     a & b.tx_hashes;
@@ -246,6 +271,15 @@ namespace boost
   }
 
   template <class Archive>
+  inline void serialize(Archive &a, rct::clsag &x, const boost::serialization::version_type ver)
+  {
+    a & x.s;
+    a & x.c1;
+    // a & x.I; // not serialized, we can recover it from the tx vin
+    a & x.D;
+  }
+
+  template <class Archive>
   inline void serialize(Archive &a, rct::ecdhTuple &x, const boost::serialization::version_type ver)
   {
     a & x.mask;
@@ -323,7 +357,7 @@ namespace boost
     a & x.type;
     if (x.type == rct::RCTTypeNull)
       return;
-    if (x.type != rct::RCTTypeFull && x.type != rct::RCTTypeSimple && x.type != rct::RCTTypeBulletproof && x.type != rct::RCTTypeBulletproof2)
+    if (x.type != rct::RCTTypeFull && x.type != rct::RCTTypeSimple && x.type != rct::RCTTypeBulletproof && x.type != rct::RCTTypeBulletproof2 && x.type != rct::RCTTypeCLSAG)
       throw boost::archive::archive_exception(boost::archive::archive_exception::other_exception, "Unsupported rct type");
     // a & x.message; message is not serialized, as it can be reconstructed from the tx data
     // a & x.mixRing; mixRing is not serialized, as it can be reconstructed from the offsets
@@ -337,7 +371,9 @@ namespace boost
     if (x.p.rangeSigs.empty())
       a & x.p.bulletproofs;
     a & x.p.MGs;
-    if (x.type == rct::RCTTypeBulletproof || x.type == rct::RCTTypeBulletproof2)
+    if ((int)ver >= 1)
+      a & x.p.CLSAGs;
+    if (x.type == rct::RCTTypeBulletproof || x.type == rct::RCTTypeBulletproof2 || x.type == rct::RCTTypeCLSAG)
       a & x.p.pseudoOuts;
   }
 
@@ -375,6 +411,28 @@ namespace boost
     }
   }
 
+  template <class Archive>
+  inline void serialize(Archive &a, offshore::pricing_record &x, const boost::serialization::version_type ver)
+  {
+    a & x.xAG;
+    a & x.xAU;
+    a & x.xAUD;
+    a & x.xBTC;
+    a & x.xCAD;
+    a & x.xCHF;
+    a & x.xCNY;
+    a & x.xEUR;
+    a & x.xGBP;
+    a & x.xJPY;
+    a & x.xNOK;
+    a & x.xNZD;
+    a & x.xUSD;
+    a & x.unused1;
+    a & x.unused2;
+    a & x.unused3;
+    a & x.signature;
+  }
+
 }
 }
 
